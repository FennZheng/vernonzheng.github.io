<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Vernon Zheng 郑雪峰]]></title>
  <subtitle><![CDATA[tech | life | thinking | note]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://vernonzheng.com/"/>
  <updated>2015-01-25T04:39:50.259Z</updated>
  <id>http://vernonzheng.com/</id>
  
  <author>
    <name><![CDATA[Vernon Zheng]]></name>
    <email><![CDATA[kevonzheng@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[《快学scala》第三章习题解答]]></title>
    <link href="http://vernonzheng.com/2015/01/21/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%AC%AC%E4%B8%89%E7%AB%A0%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94/"/>
    <id>http://vernonzheng.com/2015/01/21/《快学scala》第三章习题解答/</id>
    <published>2015-01-21T14:40:42.000Z</published>
    <updated>2015-01-25T04:39:33.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第三章_数组相关操作">第三章 数组相关操作</h2>
<p><strong>3.1</strong><br>编写一段代码，将a设置为一个n个随机整数的数组，要求随机数介于0(包含)和n(不包含)之间</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.util.Random</div><div class="line"><span class="keyword">import</span> scala.math.random</div><div class="line"><span class="keyword">def</span> randomArray(n: Int) :Array[Int] = {</div><div class="line">  <span class="keyword">val</span> array = <span class="keyword">for</span>( i&lt;- <span class="number">0</span> to n) <span class="keyword">yield</span> Random.nextInt(n)</div><div class="line">  array.toArray</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">def</span> randomArray2(n: Int) :Array[Int] = {</div><div class="line">  <span class="keyword">val</span> array = <span class="keyword">for</span>( i&lt;- <span class="number">0</span> to n) <span class="keyword">yield</span> (random * n).toInt</div><div class="line">  array.toArray</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>3.2</strong><br>编写一个循环，将整数数组中相邻的元素置换。例如,Array(1,2,3,4,5)经过置换后变为Array(2,1,4,3,5)</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> arrayChange(array: Array[Int]) :Array[Int] = {</div><div class="line">  <span class="keyword">if</span>(array == <span class="keyword">null</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span></div><div class="line"></div><div class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until array.length <span class="keyword">if</span> i % <span class="number">2</span> ==<span class="number">0</span> && i &gt; <span class="number">0</span>){</div><div class="line">    <span class="keyword">val</span> tmp = array(i-<span class="number">1</span>)</div><div class="line">    array(i-<span class="number">1</span>) = array(i)</div><div class="line">    array(i) = tmp</div><div class="line">  }</div><div class="line">  array</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">def</span> arrayChange2(arr: Array[Int]) :Array[Int] = {</div><div class="line">  <span class="keyword">val</span> t = arr.toBuffer</div><div class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until (t.length,<span class="number">2</span>) <span class="keyword">if</span> i + <span class="number">1</span> &lt; t.length){</div><div class="line">    <span class="keyword">val</span> a = t(i)</div><div class="line">    <span class="keyword">val</span> b = t(i + <span class="number">1</span>)</div><div class="line">    t.remove(i,<span class="number">2</span>)</div><div class="line">    t.insert(i,b)</div><div class="line">    t.insert(i + <span class="number">1</span>,a)</div><div class="line">  }</div><div class="line">  t.toArray</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>3.3</strong><br>重复前一个练习，不过这一次生成一个新的值交换过的数组。用for/yield</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> arrayChange(array: Array[Int]) :Array[Int] = {</div><div class="line">  <span class="keyword">if</span>(array == <span class="keyword">null</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span></div><div class="line"></div><div class="line">  <span class="keyword">val</span> length = array.length</div><div class="line">  <span class="keyword">var</span> flag = <span class="keyword">true</span></div><div class="line">  <span class="keyword">val</span> newArray = <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until length <span class="keyword">if</span> flag) <span class="keyword">yield</span>{</div><div class="line">    <span class="keyword">var</span> item = <span class="number">0</span></div><div class="line">    <span class="keyword">if</span>(i+<span class="number">1</span> &gt;= length){</div><div class="line">      flag = <span class="keyword">false</span></div><div class="line">    }</div><div class="line">    <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>){</div><div class="line">      item = array(i+<span class="number">1</span>)</div><div class="line">    }<span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">1</span>){</div><div class="line">      item = array(i-<span class="number">1</span>)</div><div class="line">    }</div><div class="line">    item</div><div class="line">  }</div><div class="line">  newArray.toArray</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>3.4</strong><br>给定一个整数数组，产生一个新的数组，包含元数组中的所有正值，以原有顺序排列，之后的元素是所有零或负值，以原有顺序排列</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> sortArray(array:Array[Int]):Array[Int] = {</div><div class="line">  <span class="keyword">val</span> newArrayBuffer = <span class="keyword">new</span> ArrayBuffer[Int]()</div><div class="line">  <span class="keyword">val</span> positiveIndex = <span class="keyword">for</span>(i &lt;- <span class="number">0</span> to array.length <span class="keyword">if</span> array(i) &gt; <span class="number">0</span> ) <span class="keyword">yield</span> {array(i)}</div><div class="line">  newArrayBuffer ++= positiveIndex.toBuffer</div><div class="line">  newArrayBuffer ++= (<span class="keyword">for</span>(i &lt;- <span class="number">0</span> to array.length <span class="keyword">if</span> !positiveIndex.contains(i)) <span class="keyword">yield</span>{array(i)}).toBuffer</div><div class="line">  newArrayBuffer.toArray</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">def</span> sortArray2(array:Array[Int]):Array[Int] = {</div><div class="line">  <span class="keyword">val</span> a = ArrayBuffer[Int]()</div><div class="line">  <span class="keyword">val</span> b = ArrayBuffer[Int]()</div><div class="line">  array.foreach(arg =&gt; <span class="keyword">if</span>(arg &gt; <span class="number">0</span>) a += arg <span class="keyword">else</span> b += arg)</div><div class="line">  a ++= b</div><div class="line">  a.toArray</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">def</span> sortArray3(array:Array[Int]):Array[Int] = {</div><div class="line">  <span class="keyword">val</span> a = array.filter(_&gt;<span class="number">0</span>).map(_*<span class="number">1</span>)</div><div class="line">  <span class="keyword">val</span> b = array.filter(_&lt;=<span class="number">0</span>).map(_*<span class="number">1</span>)</div><div class="line">  <span class="keyword">var</span> c = a.toBuffer</div><div class="line">  c ++= b.toBuffer</div><div class="line">  c.toArray</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>3.5</strong><br>如何计算Array[Double]的平均值</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> avgArray(array:Array[Double]):Double={</div><div class="line">  array.sum/array.length</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>3.6</strong><br>如何重新组织Array[Int]的元素将他们以反序排列？对于ArrayBuffer[Int]你又会怎么做呢？</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> reverseArray(arr:Array[Int]):Array[Int]={</div><div class="line">  arr.reverse</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>3.7</strong><br>编写一段代码，产出数组中的所有值，去掉重复项。(提示：查看Scaladoc)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> removeArray1(arr:Array[Int]):Array[Int]={</div><div class="line">  <span class="keyword">val</span> t = arr.toBuffer</div><div class="line">  <span class="keyword">val</span> idx =(<span class="keyword">for</span>(i &lt;- <span class="number">0</span> until t.length <span class="keyword">if</span> t(i) &lt; <span class="number">0</span>) <span class="keyword">yield</span> { i }).reverse.toBuffer</div><div class="line">  idx.trimEnd(<span class="number">1</span>)</div><div class="line">  idx.foreach(arg =&gt; t.remove(arg))</div><div class="line">  t.toArray</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">def</span> removeArray2(array:Array[Int]):Array[Int]={</div><div class="line">  <span class="keyword">val</span> arr = array.toBuffer</div><div class="line">  <span class="keyword">var</span> first = <span class="keyword">true</span></div><div class="line">  <span class="keyword">val</span> indexes = <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until arr.length <span class="keyword">if</span> first || arr(i) &gt;= <span class="number">0</span>) <span class="keyword">yield</span>{</div><div class="line">    <span class="keyword">if</span>(arr(i) &lt; <span class="number">0</span>) first = <span class="keyword">false</span>;i</div><div class="line">  }</div><div class="line">  <span class="keyword">for</span>(j &lt;- <span class="number">0</span> until indexes.length) arr(j) = arr(indexes(j))</div><div class="line">  arr.trimEnd(arr.length - indexes.length)</div><div class="line">  arr.toArray</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">def</span> performance():Unit={</div><div class="line">  <span class="keyword">val</span> array = Array(<span class="number">1</span>,-<span class="number">2</span>,<span class="number">3</span>,<span class="number">55</span>,<span class="number">3</span>,-<span class="number">4</span>,-<span class="number">6</span>,-<span class="number">2</span>,-<span class="number">1</span>,<span class="number">55</span>,-<span class="number">3</span>,<span class="number">5</span>)</div><div class="line">  <span class="keyword">val</span> startTime1 = System.currentTimeMillis()</div><div class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> to <span class="number">10000</span>) {</div><div class="line">    removeArray1(array)</div><div class="line">  }</div><div class="line">  <span class="keyword">val</span> endTime1 = System.currentTimeMillis()</div><div class="line">  <span class="keyword">val</span> startTime2 = System.currentTimeMillis()</div><div class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> to <span class="number">10000</span>) {</div><div class="line">    <span class="keyword">val</span> result2 = removeArray2(array)</div><div class="line">  }</div><div class="line">  <span class="keyword">val</span> endTime2 = System.currentTimeMillis()</div><div class="line">  println(<span class="string">"removeArray1 cost:"</span>+(endTime1-startTime1))</div><div class="line">  println(<span class="string">"removeArray2 cost:"</span>+(endTime2-startTime2))</div><div class="line">  <span class="comment">//10000次 201：81</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>3.9</strong><br>创建一个由java.util.TimeZone.getAvailableIDs返回ide时区集合，判断条件是它们在美洲。去掉”America/“前缀并排序</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> sortAmericaTimeZone():Unit = {</div><div class="line">  <span class="keyword">val</span> array = java.util.TimeZone.getAvailableIDs</div><div class="line">  <span class="keyword">val</span> result = array.filter(_.startsWith(<span class="string">"America"</span>)).map(_.replace(<span class="string">"America/"</span>,<span class="string">""</span>)).sorted</div><div class="line">  result.foreach(println(_))</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>3.10</strong><br>引入java.awt.datatransfer.并构建一个类型为SystemFlavorMap类型的对象:<br>  val flavors = SystemFlavorMap.getDefaultFlavorMap().asInstanceOf[SystemFlavorMap]<br>  然后以DataFlavor.imageFlavor为参数调用getNativesForFlavor方法，以Scala缓冲保存返回值。<br> (为什么用这样一个晦涩难懂的类？因为在Java标准库中很难找到使用java.util.List的代码)</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.awt.datatransfer.{DataFlavor, SystemFlavorMap}</div><div class="line"><span class="keyword">import</span> collection.JavaConversions.asScalaBuffer</div><div class="line"><span class="keyword">import</span> scala.collection.mutable</div><div class="line"></div><div class="line"><span class="keyword">def</span> test():Unit = {</div><div class="line">  <span class="keyword">val</span> flavors = SystemFlavorMap.getDefaultFlavorMap().asInstanceOf[SystemFlavorMap]</div><div class="line">  <span class="keyword">val</span> res:mutable.Buffer[String] = flavors.getNativesForFlavor(DataFlavor.imageFlavor)</div><div class="line">  println(res)</div><div class="line">}</div></pre></td></tr></table></figure>

<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第二章习题解答]]></title>
    <link href="http://vernonzheng.com/2015/01/20/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94/"/>
    <id>http://vernonzheng.com/2015/01/20/《快学scala》第二章习题解答/</id>
    <published>2015-01-20T14:46:42.000Z</published>
    <updated>2015-01-21T05:21:43.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第二章_控制结构与函数">第二章 控制结构与函数</h2>
<p><strong>2.1</strong><br>一个数字如果为正数，则它的signum为1;如果是负数,则signum为-1;如果为0,则signum为0.编写一个函数来计算这个值。</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> sigNum(num: Int):Int = {</div><div class="line">	<span class="keyword">if</span> (num &gt; <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">0</span>) -<span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></div><div class="line">}</div><div class="line"></div><div class="line">println(signum(<span class="number">10000</span>));</div><div class="line">println(signum(-<span class="number">22</span>));</div><div class="line">println(signum(<span class="number">0</span>));</div></pre></td></tr></table></figure>

<p><strong>2.2</strong><br>一个空的块表达式{}的值是什么？类型是什么？</p>
<p>答：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scala&gt; val x = {}</div><div class="line">x: Unit = ()</div></pre></td></tr></table></figure>

<p><strong>2.3</strong><br>指出在Scala中何种情况下赋值语句x=y=1是合法的。(提示：给x找个合适的类型定义)</p>
<p>答：<br>因为赋值语句的值是Unit型，所以x可定义为Unit型。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="keyword">var</span> y = <span class="number">5</span></div><div class="line">y: Int = <span class="number">5</span></div><div class="line"></div><div class="line">scala&gt; <span class="keyword">var</span> x = {}</div><div class="line">x: Unit = ()</div><div class="line"></div><div class="line">scala&gt; x = y= <span class="number">1</span></div><div class="line">x: Unit = ()</div></pre></td></tr></table></figure>

<p><strong>2.4</strong><br>针对下列Java循环编写一个Scala版本:<br> for(int i=10;i&gt;=0;i—) System.out.println(i);</p>
<p>答：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="keyword">for</span>(i &lt;- <span class="number">0</span> to <span class="number">10</span> reverse) println(i)</div><div class="line">warning: there was one feature warning; re-run <span class="keyword">with</span> -feature <span class="keyword">for</span> details</div><div class="line"><span class="number">10</span></div><div class="line"><span class="number">9</span></div><div class="line"><span class="number">8</span></div><div class="line"><span class="number">7</span></div><div class="line"><span class="number">6</span></div><div class="line"><span class="number">5</span></div><div class="line"><span class="number">4</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">0</span></div></pre></td></tr></table></figure>

<p><strong>2.5</strong><br>编写一个过程countdown(n:Int)，打印从n到0的数字。</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="keyword">def</span> countdown(n:Int){</div><div class="line">         <span class="keyword">for</span>(i &lt;- <span class="number">0</span> to n reverse){</div><div class="line">           println(i)</div><div class="line">         }</div><div class="line">       }</div><div class="line">warning: there was one feature warning; re-run <span class="keyword">with</span> -feature <span class="keyword">for</span> details</div><div class="line">countdown: (n: Int)Unit</div><div class="line"></div><div class="line">scala&gt; countdown(<span class="number">2</span>)</div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">0</span></div></pre></td></tr></table></figure>

<p><strong>2.6</strong><br>编写一个for循环,计算字符串中所有字母的Unicode代码的乘积。举例来说，”Hello”中所有字符串的乘积为9415087488L</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="keyword">def</span> test(str:String):Long = {</div><div class="line">         <span class="keyword">var</span> result:Long = <span class="number">1</span></div><div class="line">         <span class="keyword">for</span>(i &lt;- str) result *= i</div><div class="line">         result</div><div class="line">       }</div><div class="line">test: (str: String)Long</div><div class="line"></div><div class="line">scala&gt; test(<span class="string">"oh,yeah"</span>)</div><div class="line">res5: Long = <span class="number">62621117315328</span></div></pre></td></tr></table></figure>

<p><strong>2.7</strong><br>同样是解决前一个练习的问题，但这次不使用循环。（提示：在Scaladoc中查看StringOps）</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> test(str:String):Long = {</div><div class="line">  <span class="keyword">var</span> result:Long = <span class="number">1</span></div><div class="line">  str.foreach( ch =&gt; {result *= (ch.toLong)})</div><div class="line">  result</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>2.8</strong><br>编写一个函数product(s:String), 计算前面习题中提到的乘积。</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> product(str:String):Long = {</div><div class="line">  <span class="keyword">var</span> result:Long = <span class="number">1</span></div><div class="line">  str.foreach( result *= _.toLong )</div><div class="line">  result</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>2.9</strong><br>把前一个练习中的函数改成递归函数。</p>
<p>答:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> product(str:String):Long = {</div><div class="line">  <span class="keyword">var</span> result:Long = <span class="number">1</span></div><div class="line">  <span class="keyword">if</span> (str.length==<span class="number">1</span>)</div><div class="line">    result = str.head.toLong</div><div class="line">  <span class="keyword">else</span></div><div class="line">    result = str.head.toLong * product(str.tail)</div><div class="line">  result</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>2.10</strong><br>编写函数计算x^n, 其中n为整数。使用如下的递归定义：</p>
<ul>
<li>x^n = y^2,如果</li>
<li>x^n = x*x^(n-1)</li>
<li>x^0 = 1</li>
<li>x^n = 1/x^(-n)</li>
</ul>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> getPower(x:Double, n:Int):Double = {</div><div class="line">  <span class="keyword">if</span> (n == <span class="number">0</span> ) <span class="number">1</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( n&gt;<span class="number">0</span> && n % <span class="number">2</span> != <span class="number">0</span> ) x * getPower(x, n-<span class="number">1</span>)</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;<span class="number">0</span> && n % <span class="number">2</span> == <span class="number">0</span> ) getPower (x, n/<span class="number">2</span>) * getPower (x, n/<span class="number">2</span>)</div><div class="line">  <span class="keyword">else</span> <span class="number">1</span>/getPower( x, -n) </div><div class="line">}</div></pre></td></tr></table></figure>

<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《MongoDB实战》笔记]]></title>
    <link href="http://vernonzheng.com/2015/01/19/%E3%80%8AMongoDB%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://vernonzheng.com/2015/01/19/《MongoDB实战》笔记/</id>
    <published>2015-01-19T08:26:23.000Z</published>
    <updated>2015-01-21T06:36:21.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《MongoDB实战》的学习笔记。
</code></pre><h2 id="第一章_为现代Web而生的数据库">第一章 为现代Web而生的数据库</h2>
<p><em>特性</em><br>mongodb适合做水平扩展的数据库。<br>mongodb把文档组织成集合，无schema。</p>
<p><strong>索引</strong><br>mongodb的二级索引是B树实现。<br>每个集合最多可以创建64个索引，</p>
<p><strong>副本集</strong><br>mongodb通过副本集（replication set）的结构提供了复制功能。<br>副本集有一个主节点(primary node)和一个或多个从节点(secondary node)构成。主节点支持读写，从节点只读。而且副本集支持自动故障转移：如果主节点出了问题，集群会选一个从节点自动将它提升为主节点，在先前的主节点恢复之后，它就变成一个从节点。</p>
<p><strong>journaling日志</strong><br>mongodb中，用户可以选择写入语义，决定是否开启Journaling日志记录，控制写入速度与持久性的之间的平衡，Journaling日志是默认开启的，所有写操作都会被提交到一个只能追加的日志里。</p>
<p><strong>fire-and-forget</strong><br>mongodb默认是fire-and-forget，即写操作通过TCP套接字发送，不要求数据库应答。如果需要应该，需要开启特殊的安全模式。安全模式可配置，还可以用于阻塞操作，知道写操作被复制到特定数量的服务器。</p>
<p><strong>自动分片</strong><br>mongodb是基于范围的分片方式，自动分片（auto-sharding)。单个分片由一个副本集组成，每个副本集至少三个节点，两个携带数据的副本，就能保证自动恢复，没有单点失败。</p>
<p><strong>副本集</strong><br>通常副本集由两个副本组成，再加上一个部署在第三台服务器上的仲裁进程（arbiter process）。对于mongodb的自动分片架构而言，其组建包含配置为预先分片的副本集的mongod进程，以及特殊的元数据服务器，称为配置服务器（config server），另外还有单独名为mongos的路由服务器向适当的分片发送请求。</p>
<p><strong>_id</strong><br>所有文档都要有一个主键，存储在_id字段里，只要保证唯一性，也可以输入自定义_id.如果省略了_id，会自动插入一个mongo对象ID。</p>
<h2 id="第二章_MongoDB_Javascript_Shell">第二章 MongoDB Javascript Shell</h2>
<p><strong>针对性更新（targeted modification)</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.users.update({“favorites.movies”:”sxxx”},{$addToSet:{“favorites.movies”:”ssff”},<span class="literal">false</span>,<span class="literal">true</span>)</div></pre></td></tr></table></figure>

<p>第四个参数为多项更新，如果为false，则更新（默认）只应用于查询选择器匹配的第一个文档。</p>
<p><strong>创建索引</strong><br>ensureIndex({num:1}),其中1表示升序，getIndexes()验证。<br>在查询语句后面紧跟.explain()可以看到查询计划。</p>
<p><strong>db.stats</strong><br>获取数据库与集合更底层的信息，db.stats()。<br>stats只是辅助方法，他封装了shell的命令调用方法，等同于<br>db.runCommand({dbstats:1})，往runCommand传递文档定义。<br>看下文档定义，执行去掉无括号的版本，db.runCommand。</p>
<h2 id="第三章_使用MongoDB编程程序">第三章 使用MongoDB编程程序</h2>
<p><strong>mongo数据驱动</strong><br>mongodb数据驱动三个功能：</p>
<ul>
<li>生成mongodb对象ID，即所有文档_id字段的默认值。</li>
<li>将所有语言特定的文档表述和BSON（mongodb的二级制数据格式）互相转化。</li>
<li>使用mongodb的网络协议通过TCP套接字与数据库通信。</li>
</ul>
<p><strong>对象ID</strong><br>mongodb对象ID是全局唯一的标识符，不会重复。<br>它由12个字节构成，<br>4字节时间戳，3字节机器ID，2字节进程ID，3字节计数器<br>如：4c291856 238d3b 19b2 000001<br>可以看到对象ID包含了时间戳，从而提供对象创建时间（秒）</p>
<p><strong>BSON数据类型</strong><br>BSON规范包含了19种数据类型，如UTF-8字符串，32位和64位整数，双精度浮点数，布尔值，时间戳，UTC时间（datetime），针对模糊对象的大数据（opaque blob），部分语言支持的符号类型（symbol type）</p>
<p><em>BSON格式</em><br>文档转化为BSON：头部4字节表明文档的大小，接下来N个键值对，<br>每对都由一个表示其类型的字节开头，随后由null结尾的字符串表示键名，然后是被存储的值，最后是一个null字节表示文档结束。如图：<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/mongoinaction1.png" alt="BSON格式"></p>
<p><strong>对象ID请使用BSON对象</strong><br>如果要存储mongodb对象id，应该使用mongodb对象ID，<br>而不是字符串，除了遵循对象ID的存储惯例，BSON对象还能比字符串省一半以上的空间。</p>
<p><strong>安全模式</strong><br>mongodb安全模式写入时，驱动会在插入消息后追加一条getlaterror命令。它做了两件事，getlasterror命令需要与服务器做一次通信，它确保写操作已经送达服务器。第二，验证服务器在当前链接中没有抛出任何错误。</p>
<h2 id="第四章_面向文档的数据">第四章 面向文档的数据</h2>
<p><strong>事务与原子性</strong><br>mongodb不支持事务，但它支持多种原子更新操作，用于复杂文档。</p>
<p><strong>数据库文件</strong><br>mongodb创建数据库时候，会在磁盘上分配一组数据文件，所有集合，索引和数据库其他元数据都保存在这个文件里。数据文件都被放在启动mongod时指定的dbpath里，如未指定，则保存在/data/db里。<br>如图：<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/mongoinaction2.png" alt="数据库文件"><br>各文件说明：<br>mongod.lock文件，其中存储了服务器进程ID（不要删除，会影响异常恢复）。<br>数据库文件本身依赖所属的数据库命令，garden.ns是第一个生成的文件，ns后缀表示namespaces，数据库每个集合和索引都有自己的namespace，namespace的元数据都放在这个文件里。</p>
<p>默认情况下.ns文件固定在16MB，大约可以存24000个命令空间，也就是数据库索引和集合总数不能超过24000，通过—nssize配置。<br>看文件大小garden.0 64mb,garden.1 128mb,这些是mongoldb预先分配的数据文件，新数据文件大小是前一个的两倍，直达上限2G，通过—noprealloc和—small files配置。</p>
<p><strong>空间使用</strong><br>stats命令检查已使用空间和已分配空间。<br>如图:<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/mongoinaction3.png" alt="空间使用"><br>其中fileSize字段表示数据分配文件空间的总和。也就是前面garden数据库两个文件之和。<br>dataSize是数据库BSON对象的实际大小，storageSize是dataSize加上集合增长预留的额外空间和未分配的已删除空间。<br>indexSize是索引大小的总和。<br>另：集合的每个数据文件里按照块分配文件，这些块称为区段（extent）。storageSize就是集合区段所分配空间的总和。</p>
<p><strong>固定集合capped collection</strong><br>原本只针对高性能日志场景设计的。大小固定，满了以后，后续插入会覆盖集合最先插入的文档。<br>与标准集合的区别：</p>
<ul>
<li>固定集合默认不为_id创建索引，插入更快，也可以自己构建。（不定义索引情况下，最好把固定集合用于顺序处理的数据结构，而非用于随机查询，为此，mongodb提供了一个特殊的排序操作符$natural，按照文档的插入顺序返回文档。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.user.actions.find().sort({“$natural”:-<span class="number">1</span>})）</div></pre></td></tr></table></figure>

<ul>
<li>固定集合不能删除文档，不能执行任何增加文档大小的更新操作。</li>
</ul>
<p>mongodb使用固定集合来完成复制，每个副本集的成员都会把所有的写操作记录到一个特殊的oplog.rs固定集合里。从节点顺序读取这个集合内容，然后应用到自己数据库内。</p>
<p><strong>BSON数字类型</strong><br>BSON只定义了三种数字类型，double，int，long。而javascript只支持一种数据类型Number，等价于IEEE的双精度浮点数。如果要存储为整数，需要NumberLong()或者NumberInt</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.numbers.save({n:NumberLong(<span class="number">5</span>)})</div></pre></td></tr></table></figure>

<p><strong>BSON type</strong><br>每种BSON类型有一个整数标识，<br>db.numbers.find({n:{$type:18}});<br>{“_id”: ObjectId(“4c581c9bd5bbeb2365a838fa”)}</p>
<p>BSON缺少对小数的支持</p>
<p><strong>BSON 日期与时间</strong><br>javascript里月份是从零开始<br>new Date(2011,5,11)是2011年6月11号</p>
<p><strong>文档大小限制</strong><br>v2.0中BSON文档大小限制在16MB，不同版本输入db.isMaster查看maxBsonObjectSize字段。<br>大小限制的原因，一是防止设计深层嵌套，二是性能，在服务器端查询大文档，在讲结果发送给客户端前需要将文档复制到缓冲区里，同时驱动反序列化开销很大。</p>
<h2 id="第五章_查询与聚合">第五章 查询与聚合</h2>
<p><strong>find与findOne</strong><br>find返回的是游标对象，findOne返回一个文档</p>
<p><strong>分页</strong><br>分页可以使用：skip，limit，sort，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">products = db.products.find({‘category_id’:category[‘_id<span class="string">']}).skip((page_number-1)*12).limit(12).sort({helpful_votes:-1})</span></div></pre></td></tr></table></figure>

<p><strong>集合操作</strong><br>$in,$all,$nin,接受数组参数</p>
<p><strong>布尔操作符</strong><br>$ne,$not,$or,$and,$exists<br>如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.products.find(‘details.manufacturer’:’ACME’,tags:{$ne:”gardening”})</div></pre></td></tr></table></figure>

<p>or可以应用于条件选择器数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.products.find({$or:[{‘details.color’:’blue’},{‘details.manufacturer’:’ACME<span class="string">'}]})</span></div></pre></td></tr></table></figure>

<p><strong>数组下标表示</strong><br>db.users.find({‘address.0.state’:’NY’})<br>其中0表示数组的第一个</p>
<p><strong>$elemMatch</strong><br>用于子文档的多个条件限制查询<br>db.users.find({address: {$elemMatch: {name: ‘home’,state: ’NY’}})</p>
<p><strong>size</strong><br>根据数组大小查询，$size，不走索引，只支持精确查找。推荐将数组大小作为一个字段放入集合中。</p>
<p><strong>$where</strong><br>可以手动编写javacript执行<br>db.reviews.find({$where: “function(){ return this.helpful_votes &gt; 3;}”})<br>this指向当前文档，不走索引，性能低。<br>可以配合一般查询语句缩小遍历集合后使用，</p>
<p><strong>正则表达式</strong><br>使用了忽略大小写的选项则无法在查询中使用索引，就算在前缀匹配中也是如此。原生正则表达式例子：<br>db.reviews.find({user_id: ObjectId(“xxxx”), text: /best|worst/i})<br>不能用原生，则用$regex和$options</p>
<p><strong>投影</strong><br>返回结果中去掉不需要的字段，如<br>db.users.find({}, {address:0, payment_method:0})</p>
<p><strong>$slince</strong><br>返回头多少条或者尾多少条信息，也可以接受两参数的形式，一个是跳过多少，一个是返回元素个数限制。</p>
<p><strong>$skip</strong><br>类似于offset ,最好省略skip，添加一个范围条件，提高性能。</p>
<p><strong>min与max</strong><br>不提供min(),max()，自己实现，按照某字段降序排序，再limit。</p>
<p><strong>distinct</strong><br>默认覆盖整个集合，返回字段的不同值集合，也可传入查询器。</p>
<p><strong>group</strong><br>group最少需要三个参数，第一个参数定义对key怎么分组，第二个参数是聚合的js函数，叫reduce函数，第三个参数为reduce函数初始文档。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">results = db.views.group({key:{user_id:<span class="literal">true</span>}, initial = {review:<span class="number">0</span>, vote:<span class="number">0.0</span>},</div><div class="line">    reduce = <span class="function"><span class="keyword">function</span><span class="params">(doc, aggregator)</span></span>{</div><div class="line">        aggregator.views += <span class="number">1.0</span>;</div><div class="line">        aggregator.votes += doc.votes;</div><div class="line">    },</div><div class="line">    finalize: <span class="function"><span class="keyword">function</span><span class="params">(doc)</span></span>{</div><div class="line">        doc.average_votes = doc.votes /doc.reviews;</div><div class="line">   }</div><div class="line">});</div></pre></td></tr></table></figure>

<p><strong>distinct与group结果集合大小限制</strong><br>distinct和group返回结果集合不能超过16MB，因为这两个命令是对特殊$cmd集合的查询。同时group不会处理多余10000个唯一键，不能满足的情况，使用map-reduce。</p>
<p><strong>map-reduce</strong><br>定义一个map函数，内部调用emit()，emit方法第一个参数是分组依据的key，第二个参数是包含执行reduce的文档。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">map = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">	<span class="keyword">var</span> shipping_moth = <span class="keyword">this</span>.purchase_date.getMonth() + ‘-‘+<span class="keyword">this</span>.purchase_data.getFullYear();</div><div class="line">	<span class="keyword">var</span> items = <span class="number">0</span>;</div><div class="line">	<span class="keyword">this</span>.line_items.forEach(<span class="function"><span class="keyword">function</span><span class="params">(item)</span></span>{</div><div class="line">		tmpItems += item.qunatity;</div><div class="line">	});</div><div class="line">	emit(shipping_month,{order_total:<span class="keyword">this</span>.sub_total, item_total:<span class="number">0</span>})</div><div class="line">}</div><div class="line">reduce = <span class="function"><span class="keyword">function</span><span class="params">(key,values)</span></span>{</div><div class="line">	<span class="keyword">var</span> tmpTotal = <span class="number">0</span>;</div><div class="line">	<span class="keyword">var</span> tmpItems = <span class="number">0</span>;</div><div class="line">	tmpTotal += doc.order_total;</div><div class="line">	tmpItems += doc.items_total;</div><div class="line">	<span class="keyword">return</span> ({total: tmpTotal, items:tmpItems)});</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="第六章_更新、原子操作与删除">第六章 更新、原子操作与删除</h2>
<p><strong>原子性</strong><br>所有发往核心服务器的更新都是原子的，以文档为单位进行隔离。说更新操作符是原子性的是因为他们能在不先查询的前提下完成更新。</p>
<p><strong>findAndModify</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">db.orders.findAndModify({</div><div class="line">	query:{}</div><div class="line">	update:{}</div><div class="line">})</div></pre></td></tr></table></figure>

<p>默认情况下findAndModify返回更新前的文档，要返回更新后的文档，要制定{new:true}</p>
<p><strong>多文档更新</strong><br>db.products.update({},{$addToSet:{tags:’cheap’’}}, false,true)</p>
<p><strong>upsert</strong><br>如果查询选择器匹配到文档则更新，无匹配则新增。一次只插入或更新一个文档。</p>
<p><strong>$inc</strong><br>递增，递减操作</p>
<p><strong>$unset</strong><br>能删除文档中特定的键，但作用在数组上，只是置为null，要删除删除，调用$pull和$pop.</p>
<p><strong>$addToSet和$each</strong><br>如果想在一个操作里向数组添加多个唯一的值，必须结合$each操作符来使用$addToSet</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.products.update({slug:’shovel’},{$addToSet: {’tags’: {$each: [’tools’,’dirts<span class="string">']}})</span></div></pre></td></tr></table></figure>

<p><strong>$pop</strong><br>删除最后添加的内容</p>
<p><strong>$pull</strong><br>与$pop类似，但更高级，可以明确制定删除哪个数组元素，而不是位置。</p>
<p><strong>基于位置的更新</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">query = {_id: ObjectId(“<span class="number">4</span>c4d1476238d3b4dd5003981”),</div><div class="line">‘line_items.sku’:”<span class="number">10027</span>”}</div><div class="line">update = {$set: {‘line_items.$.quantity’:<span class="number">5</span>}}</div><div class="line">db.orders.update(query,update)</div></pre></td></tr></table></figure>

<p>在line_items.$quantity字符串中$表示位置操作符,如果查询选择器匹配到了这个文档，那么有10027这个sku的文档的下标就会替换位置操作符，从而正确更新文档。</p>
<p><strong>mongodb锁策略</strong><br>全局锁，已废弃,具体参考mongodb jira<br>写锁让步，可以使用$atomic参数控制隔离执行，不被暂停</p>
<p><strong>更新性能</strong><br>文档更新三种：</p>
<ul>
<li>BSON大小不改变</li>
<li>BSON大小改变，头四个字节需要修改，或者增加字段</li>
<li>重写文档，预分配磁盘放不下，需要移动，为降低这类开销，mongodb会根据每个集合的情况动态调整填充因子(padding factor),也就是如果一个集合会发生很多重新分配的情况，会自动增加填充因子。填充因子*插入文档的大小后，为要额外创建的空间。</li>
</ul>
<h2 id="第七章_索引与查询优化">第七章 索引与查询优化</h2>
<p><strong>$or与索引</strong><br>$or查询里，每个$or查询子句，都能使用不同的索引，但每个子句本身只能使用一个索引。</p>
<p><strong>tip</strong><br>就算拥有正确索引，还是可能得不到快速的查询，索引和数据集无法完全加入内存，是要考虑的问题。</p>
<p><strong>标准索引</strong><br>索引是B树，集合存储为双向列表<br>mongodb的B树实现里，新节点会被分配8192字节，也就是说实际上每个节点能包含几百个键。请牢记，默认情况下，B节点内容有意维持在60%左右。</p>
<p><strong>稀疏索引</strong><br>当集合中大量文档都不包含被索引键。创建时指定{sparse:true}。在稀疏索引中，只会出现被索引键有值的情况。</p>
<p><strong>声明索引要小心</strong><br>构建会花很长时间，则无法中止。最明智的建议，将索引构建当成某类数据库迁移来看。</p>
<p><strong>后台索引</strong><br>不暂停数据库访问，在后台构建索引，对读操作主动让步。{background:true}</p>
<p><strong>备份</strong><br>如果想在备份中包含索引，需要直接备份mongodb的数据文件。</p>
<p><strong>reIndex</strong><br>reIndex，重建索引，占写锁，实例暂时无法使用。</p>
<p><strong>慢查询</strong><br>mongod服务器启动，—slowms 50会把筛选日志。</p>
<p><strong>剖析器</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">use stocks</div><div class="line">db.setProfilingLevel(<span class="number">2.50</span>)</div></pre></td></tr></table></figure>

<p>第一个参数，2表示读写，第二参数表示超过50ms都写日志。</p>
<p><strong>查询优化器的三个规则</strong></p>
<ul>
<li>避免scanAndOrder，使用索引排序</li>
<li>通过有效索引约束来满足所有字段</li>
<li>如果查询包含范围查询或者排序，对于选择的索引，其中最后用到的键需能满足该范围查询或者索引</li>
</ul>
<p><strong>查询计划</strong><br>explain，传入true，输出查询计划</p>
<p><strong>查询计划器的缓存</strong><br>在发现了一个成功的计划之后，会记录下查询模式(query pattern)/nscanned的值以及索引说明，如<br>{pattern: {stock_symbol:’equality’, close: ‘bound’}, index:{stock_symbol:1}, scanned:894}<br>查询模式记录下每个键匹配的类型，你正请求对stock_symbol的精确匹配（相等），对close的范围匹配，就会使用这个索引。</p>
<p><strong>查询计划期缓存过期</strong></p>
<ul>
<li>对集合执行了100次写操作</li>
<li>在集合上增加或删除了索引</li>
<li>虽然使用了缓存的查询计划，但工作量大于预期，及nscanned超过缓存nsscanned的10倍</li>
</ul>
<h2 id="第八章_复制">第八章 复制</h2>
<p><strong>两种复制风格</strong><br>mongodb提供了两种复制风格：主从复制，副本集。都是主节点写，异步同步到从节点。<br>推荐使用副本集，因为支持自动故障转移，只有mongodb需要超过11个从节点，则需要主从复制。</p>
<p>虽然副本是冗余的，但副本不是备份的替代品。</p>
<p><strong>副本集</strong><br>副本集，至少三个节点，包括一个仲裁节点，选主。<br>启服务略<br>isMaster查看副本信息，rs.status()更详细信息，启动完成stateStr字段会从revocering到primary，secondary，arbiter。</p>
<p><strong>测试选主</strong><br>ctrl-c,kill -2或者连接上主节点，db.shutdownServer()</p>
<p><strong>副本集的基础机制</strong><br>副本集依赖于两个基础机制，oplog和心跳。<br>oplog是个固定集合，位于每个复制节点的local数据库里，记录所有对数据的变更。查看当前副本状态的基本信息，db.getReplicationInfo()</p>
<p><strong>local库</strong><br>replset.minvalid指定副本集成员的初始同步信息<br>system.replset保存了副本集配置文档<br>me和slaves实现写专注<br>system.indeses标准索引</p>
<p><strong>副本同步</strong><br>从节点从主节点赋值oplog，做三件事</p>
<ul>
<li>查看oplog最后一条的时间戳</li>
<li>查询主节点oplog里所有大于此时间戳的记录</li>
<li>将这些记录添加到自己库里</li>
</ul>
<p><strong>心跳检测</strong><br>默认情况下，每个副本集成员每两秒ping一下其他所有成员。<br>如果没有多数节点，主节点会自动降为从节点。</p>
<p><strong>回滚</strong><br>当mongodb从节点升为主节点，会触发其他从节点回滚。略<br>在数据路径下rollback子目录保存了呗回滚的写操作，对每个回滚写操作集合，创建独立BSON文件，通过bsondump查询，mongorestore恢复。</p>
<p><strong>重新配置副本集</strong><br>无论何时，重新配置副本集导致重新选举新的主节点，那么所有客户端的链接都会被关闭，防止fire-and-forget风格的写操作。</p>
<p><strong>配置文件</strong></p>
<ul>
<li>arbiterOnly：仲裁节点只存储配置数据。</li>
<li>priority，决定了选举的权重，设置为0，表示被动节点，永远不会被选为主节点，可以用于灾难恢复节点。</li>
<li>buildIndex：如果永远不会成为主节点，priority为0，可以设置。</li>
<li>slaveDelay：如果要设置大于0，务必保证priority为0.<br>其他略</li>
</ul>
<p><strong>写关注</strong><br>getlastError(w,timeout，j:true)<br>第一个参数为需要同步到服务器的数量,w可以等于”majority”。<br>第二参数为超时时间。<br>j表示强制同步到journaing日志。</p>
<p><strong>读扩展</strong><br>Mongo:: ReplSetConnection.new([‘arete’, 40000], [‘arete’,40001], :read =&gt; :secondary)<br>read的设置，读会从选择附近一个从节点读取。</p>
<p>副本扩展无法处理一致性读，需要将一致性读的部分抽取出来。</p>
<h2 id="第九章_分片">第九章 分片</h2>
<p><strong>分片集群</strong><br>分片集群由分片，mongos路由器和配置服务器组成。<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/mongoinaction4.png" alt="分片集群"></p>
<p><strong>mongos路由器</strong><br>通常运行于应用服务器相同的机器上，提供所有读写请求的统一系统视图。mongos进程是轻量级非持久化的。</p>
<p><strong>配置服务器</strong><br>持久化分片集群的元数据，包括集群配置，每个数据库集合特定范围数据的位置，一份变更记录，保证数据在分片之间迁移的历史。</p>
<p>mongos对配置服务器写入时候，使用二阶段提交。配置服务器最好三个以上，同时存在于不同机器实现冗余。</p>
<p><strong>分片与块</strong><br>分片是基于范围的，分片建(shared key)。<br>块（chunk），位于分片种的一段连续的分片范围，如<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/mongoinaction5.png" alt="块与分片"></p>
<p>分片的重点是块的拆分和迁移，拆分是对元数据的逻辑操作，迁移是均衡器(balancer)处理的物理操作。</p>
<p><strong>分片索引</strong><br>每个分片都维护了自己的索引，分片集合上的索引声明，会对所有分片起效。<br>分片集合只允许在_id和分片键上添加唯一索引。</p>
<p>分片键无法修改。</p>
<p><strong>拓扑结构</strong><br>运行mongodb两分片集群，一共要启动九个进程，每个副本集三个mongod，外加三个配置服务器。其中副本集是资源密集型，需要暂用独立的机器，仲裁节点不需要，配置服务器间不共用机器。如图：<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/mongoinaction6.png" alt="两分片集群"></p>
<p>考虑到灾难恢复<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/mongoinaction7.png" alt="两分片集群+容灾"></p>
<p><strong>监控</strong><br>mongos上运行serverStatus和currentOp看到所有分片的聚合统计信息，或者查询config数据库，对于不均衡的块，进行split，movechunk。</p>
<p><strong>增加分片</strong><br>考虑向新分片移动的时间，预计每分钟100-200MB。在现有索引和工作集达到分片的90%就要开始计划。</p>
<p><strong>移除分片</strong><br>removeshard，会删除块，重新分配到其他分片上。</p>
<p><strong>集合去分片</strong><br>导出集合，再用不同名字将数据恢复到一个新的集合里。用mongodump连接mongos导出。</p>
<h2 id="第十章_部署与管理">第十章 部署与管理</h2>
<p><strong>时钟</strong><br>不同服务器见都是用NTP，网络时间，在linux上使用ntpd守护进程。</p>
<p><strong>journaling日志</strong></p>
<ul>
<li>会降低写操作性能</li>
<li>不保证不丢失写操作，只保证恢复一致状态。每100ms将写缓冲同步到磁盘。</li>
</ul>
<p><strong>副本集验证</strong><br>启动—keyfile指定密码文件，为至少6个base64字符集。</p>
<p><strong>服务器监控</strong></p>
<ul>
<li>serverStatus<br>输出页错误，B树访问率，打开连接数，总的插入，更新，查询和删除等。globalLock会显示所有锁的时间，currentQueue显示读写队列。mem部分是内存，理想状况下所有工作集都应该放到内存中。</li>
<li>top<br>操作计数器，显示操作的平均耗时。</li>
<li>db.currentOp()<br>返回正在运行的所有操作。要杀掉，db.killOp(opid)</li>
<li>mongostat<br>显示实时活动视图，以固定时间查询服务器信息，显示统计数据的矩阵，从每秒插入数到常驻内存量，再到B树页丢失频率。</li>
<li>web控制台<br>mongod的端口+1000为web控制台端口，一般为28017.</li>
</ul>
<p><strong>诊断工具</strong><br>mongosniff，mongodump略</p>
<p><strong>数据备份与恢复</strong><br>两种方式</p>
<ul>
<li>一个是mongodump，mongorestore</li>
<li>一个是基于原始数据的备份，大多数情况更快，但是要求锁定数据库，可以选择锁定从节点（可以保留全部索引）。</li>
</ul>
<p><strong>锁定数据库</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">use admin</div><div class="line">db.rumCommand({fsync:<span class="number">1</span>,lock:<span class="literal">true</span>})</div></pre></td></tr></table></figure>

<p>此时数据库是写锁定的。<br>解锁:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.$cmd.sys.unlock.findOne()</div></pre></td></tr></table></figure>

<p>再查看db.currentOp是否解锁</p>
<p><strong>压紧与修复</strong><br>mongod —repair<br>或者单个数据库<br>use cloud-docs<br>db.runCommand({repairDatabase:1})</p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
<hr>
<p>参考：《MongoDB实战》：<a href="http://book.douban.com/subject/19977785/" target="_blank" rel="external">http://book.douban.com/subject/19977785/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《MongoDB实战》的学习笔记。
</code></pre><h2 id="第一章_为现代Web而生的数据库">第一章 为现代Web而生的数据库</h2>
<p><em>特性</em><br>mongodb适合做水平扩展的数据库。<br>mongodb把文]]>
    </summary>
    
      <category term="mongodb" scheme="http://vernonzheng.com/tags/mongodb/"/>
    
      <category term="nosql" scheme="http://vernonzheng.com/tags/nosql/"/>
    
      <category term="mongodb" scheme="http://vernonzheng.com/categories/mongodb/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第一章习题解答]]></title>
    <link href="http://vernonzheng.com/2015/01/12/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94/"/>
    <id>http://vernonzheng.com/2015/01/12/《快学scala》第一章习题解答/</id>
    <published>2015-01-12T14:20:42.000Z</published>
    <updated>2015-01-20T14:46:18.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。 </p>
<h2 id="第一章_基础">第一章 基础</h2>
<p><strong>1.1</strong><br>在Scala REPL中键入3,然后按Tab键。有哪些方法可以被应用? </p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">%   +   &gt;    &gt;&gt;&gt;            isInstanceOf   toDouble   toLong     unary_+   |</div><div class="line">&   -   &gt;=   ^              toByte         toFloat    toShort    unary_-</div><div class="line">*   /   &gt;&gt;   asInstanceOf   toChar         toInt      toString   unary_~</div></pre></td></tr></table></figure>

<p><strong>1.2</strong><br>在Scala REPL中，计算3的平方根,然后再对该值求平方。现在，这个结果与3相差多少？(提示:res变量是你的朋友) </p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="keyword">import</span> scala.math._</div><div class="line"><span class="keyword">import</span> scala.math._</div><div class="line"></div><div class="line">scala&gt; sqrt(<span class="number">3</span>)</div><div class="line">res7: Double = <span class="number">1.7320508075688772</span></div><div class="line"></div><div class="line">scala&gt; <span class="number">3</span> - res7</div><div class="line">res8: Double = <span class="number">1.2679491924311228</span></div></pre></td></tr></table></figure>

<p><strong>1.3</strong><br>res变量是val还是var? </p>
<p>答：<br>res变量是val</p>
<p><strong>1.4</strong><br>Scala允许你用数字去乘字符串—去REPL中试一下”crazy”*3。这个操作做什么？在Scaladoc中如何找到这个操作? </p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="string">"crazy"</span>*<span class="number">3</span></div><div class="line">res9: String = crazycrazycrazy</div></pre></td></tr></table></figure>

<p>scala docs 去查StringOps:<a href="http://www.scala-lang.org/api/current/#scala.collection.immutable.StringOps" target="_blank" rel="external">http://www.scala-lang.org/api/current/#scala.collection.immutable.StringOps</a></p>
<p><strong>1.5</strong><br>10 max 2的含义是什么？max方法定义在哪个类中？</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="number">10</span> max <span class="number">2</span></div><div class="line">res10: Int = <span class="number">10</span></div></pre></td></tr></table></figure>

<p>返回两者中比较大的一个<br>max方法定义在RichInt方法中。<a href="http://www.scala-lang.org/api/current/#scala.runtime.RichInt" target="_blank" rel="external">http://www.scala-lang.org/api/current/#scala.runtime.RichInt</a></p>
<p><strong>1.6</strong><br>用BigInt计算2的1024次方</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scala&gt; BigInt(<span class="number">2</span>).pow(<span class="number">1024</span>)</div><div class="line">res13: scala.math.BigInt = <span class="number">179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216</span></div></pre></td></tr></table></figure>

<p><strong>1.7</strong><br>为了在使用probablePrime(100,Random)获取随机素数时不在probablePrime和Radom之前使用任何限定符，你需要引入什么？</p>
<p>答：<br>import需要的包。Random在scala.util中，而probablePrime是BigInt中的方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.math.BigInt._  </div><div class="line"><span class="keyword">import</span> scala.util.Random  </div><div class="line">  </div><div class="line">probablePrime(<span class="number">100</span>,Random) </div><div class="line">res15: scala.math.BigInt = <span class="number">1137139793510393954801305013479</span></div></pre></td></tr></table></figure>

<p><strong>1.8</strong><br>创建随机文件的方式之一是生成一个随机的BigInt，然后将它转换成三十六进制，输出类似”qsnvbevtomcj38o06kul”这样的字符串。查阅Scaladoc，找到在Scala中实现该逻辑的办法。</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scala&gt; scala.math.BigInt(scala.util.Random.nextInt).toString(<span class="number">36</span>)</div><div class="line">res19: String = -wda3r0</div></pre></td></tr></table></figure>

<p><strong>1.9</strong><br>在Scala中如何获取字符串的首字符和尾字符？</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="string">"Hello"</span>(<span class="number">0</span>)</div><div class="line">res20: Char = H</div><div class="line"></div><div class="line">scala&gt; <span class="string">"Hello"</span>.take(<span class="number">1</span>)</div><div class="line">res21: String = H</div><div class="line"></div><div class="line">scala&gt; <span class="string">"Hello"</span>.reverse(<span class="number">0</span>)</div><div class="line">res22: Char = o</div><div class="line"></div><div class="line">scala&gt; <span class="string">"Hello"</span>.takeRight(<span class="number">1</span>)</div><div class="line">res23: String = o</div></pre></td></tr></table></figure>

<p><strong>1.10</strong><br>take,drop,takeRight和dropRight这些字符串函数是做什么用的？和substring相比，他们的优点和缺点都是哪些？</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="string">"Hello world"</span>.take(<span class="number">3</span>)</div><div class="line">res26: String = Hel</div><div class="line"></div><div class="line">scala&gt; <span class="string">"Hello world"</span>.takeRight(<span class="number">3</span>)</div><div class="line">res27: String = rld</div><div class="line"></div><div class="line">scala&gt; <span class="string">"Hello world"</span>.drop(<span class="number">3</span>)</div><div class="line">res28: String = lo world</div><div class="line"></div><div class="line">scala&gt; <span class="string">"Hello world"</span>.dropRight(<span class="number">3</span>)</div><div class="line">res29: String = Hello wo</div><div class="line"></div><div class="line">scala&gt; <span class="string">"Hello world"</span>.take(<span class="number">3</span>).drop(<span class="number">1</span>)</div><div class="line">res32: String = el</div></pre></td></tr></table></figure>

<p>take,drop,takeRight,dropRight适合从两边处理字符串，很方便可以配合使用，substring适合处理中间的字符串。</p>
<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2014年终小结与书单]]></title>
    <link href="http://vernonzheng.com/2014/12/28/2014%E5%B9%B4%E7%BB%88%E5%B0%8F%E7%BB%93%E4%B8%8E%E4%B9%A6%E5%8D%95/"/>
    <id>http://vernonzheng.com/2014/12/28/2014年终小结与书单/</id>
    <published>2014-12-28T08:36:23.000Z</published>
    <updated>2014-12-28T11:10:11.000Z</updated>
    <content type="html"><![CDATA[<pre><code>年初觉得可能发生的事情，大多数都发生了。
</code></pre><h2 id="一、2014小结">一、2014小结</h2>
<p>去了青岛，舟山，上海，路过香港，台湾12天环岛。（台湾之行，加大我对环球游梦的‘执念’）</p>
<p>11月份，根据地从杭州搬到了北京。（搬家是件痛苦的事情，特别是书都得处理掉，好处是杂乱的东西都可以丢了）</p>
<p>工作换了两家，经历了一些波折，11月连续两周的面试，第一次体会了面霸的感觉，这也是大北京的优势，公司多。离年初和同学戏称的30岁金钱目标，意外的跨了一大步，同时又觉得路程还很远，养成习惯和身体健康的重要性。</p>
<p>学习方面，英语没有任何质变。。唯一欣慰的是今年读了39本书。</p>
<p>附：<br>我的足迹：<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/2014_year_foot_print" alt="2014_foot_print"></p>
<h2 id="二、2015目标">二、2015目标</h2>
<p>既然是总结，就不得不写一些2015的目标。</p>
<ul>
<li>英语：为了环球游的‘执念’，蹩脚的英语得加把劲了，每天90分钟的听说练习，至少日常口语没问题，流利的聊天更好。</li>
<li>刷书，积累：技术类30本，其他类20本，英语原版书3本以上。</li>
<li>坚持锻炼：养成每天早上起床锻炼的习惯，《囚徒健身》。</li>
<li>旅行：精神和身体都得奔跑在路上。既然base在北京，周边几个省的旅游机会别浪费了。</li>
<li>职业：写的像招聘信息。。熟练掌握scala，nodejs，仔细阅读kafka，nignx源码，了解下大数据处理相关（spark，hadoop），分析问题能追到c实现，能写点基于unix的偏底层的网络程序，用scala写一些中间件。技能水平，从应用级别高级开发到类库框架级别的高级开发吧。</li>
</ul>
<h2 id="三、2014书单">三、2014书单</h2>
<p>我的2014书单，书封面就不贴了，可以参考我的豆瓣读书：<a href="http://book.douban.com/people/vernonzheng/" target="_blank" rel="external">http://book.douban.com/people/vernonzheng/</a></p>
<h3 id="3-1_IT技术类">3.1 IT技术类</h3>
<ul>
<li><p>《深入理解Java虚拟机：JVM高级特性与最佳实践》<br>周志明<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/深入理解Java虚拟机.jpg" alt="深入理解Java虚拟机"><br>5星，非常推荐。</p>
</li>
<li><p>《Java并发编程实践》<br>Brian Goetz、Tim Peierls、Joshua Bloch、Joseph Bowbeer、David Holmes、Doug Lea / 童云兰<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/Java并发编程实战.jpg" alt="Java并发编程实践"><br>5星，非常推荐，有点理论程度的。</p>
</li>
<li><p>《高性能MySQL》<br>Baron Schwartz、Peter Zaitsev、Vadim Tkachenko、Jeremy D.Zawodny、Arjen Lent、Derek J.Ballin / 王小东、李军、康建勋<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/高性能MySQL.jpg" alt="高性能MySQL"><br>5星，非常推荐，特别是4，5，6章的索引，查询优化等等讲的很透彻。</p>
</li>
<li><p>《领域特定语言》<br>Martin Fowler / ThoughtWorks中国<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/领域特定语言.jpg" alt="领域特定语言"><br>5星，Martin难得出那么厚的书，写的很好，只看了前几章理论部分，后面的实用性挺高。</p>
</li>
<li><p>《设计模式：可复用面向对象软件的基础》<br>GOF<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/设计模式 - 可复用面向对象软件的基础.jpg" alt="设计模式"><br>5星，不是很推荐，惜字如金，有点难度，以后还得翻。</p>
</li>
<li><p>《点石成金：访客至上的网页设计秘笈》<br>[美] 史蒂夫·克鲁克 / De Dream’<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/点石成金.jpg" alt="点石成金"><br>5星，推荐，英文名是Don’t make me think，特点是很薄，147页。</p>
</li>
<li><p>《大型网站系统与Java中间件开发实践》<br>曾宪杰<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/大型网站系统与Java中间件开发实践.jpg" alt="大型网站系统与Java中间件开发实践"><br>5星，没有特别高深的概念，能学会解决这类问题的思路，结合非常实际的案例在讲。</p>
</li>
<li><p>《人月神话》<br>弗雷德里克.布鲁克斯 / UMLChina翻译组、汪颖<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/人月神话.jpg" alt="人月神话"><br>4星，多少年前的书，却相当经典。</p>
</li>
<li><p>《MySQL技术内幕：SQL编程》<br>姜承尧<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/MySQL技术内幕 - SQL编程.jpg" alt="MySQL技术内幕：SQL编程"><br>4星，对于有一些数据库设计开发经验的人，有许多技巧性和细节性的建议和提高。</p>
</li>
<li><p>《测试驱动开发：实战与模式解析》<br>Kent Beck / 白云鹏<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/测试驱动开发.jpg" alt="测试驱动开发"><br>4星，翻译不太好，kent beck的书实在少，只能看个经典旧书了。</p>
</li>
<li><p>《The Little Book on CoffeeScript》<br>Alex MacCaw<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/The Little Book on CoffeeScript.jpg" alt="The Little Book on CoffeeScript"><br>4星，实用，简短，快速上手。</p>
</li>
<li><p>《Node.js实战》<br>[美] Mike Cantelon、[美] TJ Holowaychuk、[美] Nathan Rajlich<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/node.js 实战.jpg" alt="Node.js实战"><br>4星，有些翻译问题，适合做nodejs的前两本入门书。</p>
</li>
<li><p>《Spring实战》<br>沃尔斯 (Craig Walls) / 耿渊、张卫滨<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/Spring实战.jpg" alt="Spring实战"><br>4星，过一下基础。</p>
</li>
<li><p>《Maven实战》<br>许晓斌<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/Maven实战.jpg" alt="Maven实战"><br>4星，内容比较全，稍微有点拖沓。</p>
</li>
<li><p>《Robust Java中文版：Java异常处理、测试与调试》<br>史德汀<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/Robust Java 中文版 - Java异常处理、测试与调试.jpg" alt="Robust Java中文版"><br>3星，介绍了java异常的体系结构，设计，开发，测试，架构，比较基础和全面。</p>
</li>
<li><p>《Java 7 Concurrency Cookbook》<br>Fernandez Javier / Packt Publishing<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/Java 7 Concurrency Cookbook.jpg" alt="Java 7 Concurrency Cookbook"><br>3星，就当查漏补缺了。</p>
</li>
<li><p>《Netty权威指南》<br>李林峰<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/Netty权威指南.jpg" alt="Netty权威指南"><br>3星，作者没有用心写感觉。。</p>
</li>
</ul>
<h3 id="3-2_IT非技术类">3.2 IT非技术类</h3>
<ul>
<li><p>《重来》<br>[美] 贾森·弗里德、[丹] 戴维·海涅迈尔·汉森 / 李瑜偲<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/重来.jpg" alt="重来"><br>5星，推荐，设计商业，创业，软件设计，需求，技术等，触发思考的内容远超一个创业书的范围。</p>
</li>
<li><p>《黑客与画家》<br>[美] Paul Graham / 阮一峰<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/黑客与画家.jpg" alt="黑客与画家"><br>5星，硅谷创业之父Paul Graham文集，黑客精神，创业，lisp等。</p>
</li>
<li><p>《暗时间》<br>刘未鹏<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/暗时间.jpg" alt="暗时间"><br>5星，知识密度相当大</p>
</li>
<li><p>《MacTalk 人生元编程》<br>池建强<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/MacTalk 人生元编程.jpg" alt="MacTalk 人生元编程"><br>3星，如果你喜欢编程的乐趣和mac相关内容，可以翻一翻。</p>
</li>
<li><p>《软件架构师的12项修炼》<br>Dave Hendricksen / 张菲<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/软件架构师的12项修炼.jpg" alt="软件架构师的12项修炼"><br>2星，讲的太泛了，没啥实用性</p>
</li>
</ul>
<h3 id="3-3_其他杂类">3.3 其他杂类</h3>
<ul>
<li><p>《人间词话》<br>王国维<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/人间词话.jpg" alt="人间词话"><br>5星，有一半是对古人词的赏析，之外对于境界的理解部分收获很多。</p>
</li>
<li><p>《正见：佛陀的证悟》<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/正见.jpg" alt="正见"><br>宗萨蒋扬钦哲仁波切 / 姚仁喜<br>5星，有兴趣的人可以看看，讲佛家四见地的。因为书中“佛陀看一个人，是看到他的圆熟和衰朽同时在发生。”这句话，去看了这本书。</p>
</li>
<li><p>《囚徒健身》<br>保罗·威德<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/囚徒健身.jpg" alt="囚徒健身"><br>5星，简单，实用。</p>
</li>
<li><p>《少有人走过的路：心智成熟的旅程》<br>[美] M·斯科特·派克 / 于海生<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/少有人走的路 - 心智成熟的旅程.jpg" alt="少有人走过的路：心智成熟的旅程"><br>5星，推荐前半部分</p>
</li>
<li><p>《撒哈拉的故事》<br>三毛<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/撒哈拉的故事.jpg" alt="撒哈拉的故事"><br>5星，echo作品里最喜欢的一本。她的文字和独特壮阔的生活方式，有一种特别的魅力，无论是孤独还是爱的追寻，真实＆真挚的让人感动。</p>
</li>
<li><p>《穷游锦囊：骑行台湾》<br>穷游网<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/穷游锦囊：骑行台湾.jpg" alt="穷游锦囊"><br>5星，穷游系列的书都很不错。台湾环岛攻略就靠这个系列。</p>
</li>
<li><p>《如何阅读一本书》<br>[美] 莫提默·J. 艾德勒、查尔斯·范多伦 / 郝明义、朱衣<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/如何阅读一本书.jpg" alt="如何阅读一本书"><br>4星，推荐，多读书，多总结适合自己的方式。</p>
</li>
<li><p>《女人的性爱动机》<br>【美】辛迪•梅斯顿、【美】戴维•巴斯 / 海兰、插画师：顾爷<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/女人的性爱动机.jpg" alt="女人的性爱动机"><br>4星，生理和心理角度看待问题，前几章不错。</p>
</li>
<li><p>《我所理解的生活》<br>韩寒<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/我所理解的生活.jpg" alt="我所理解的生活"><br>4星，多年没读韩寒，变化挺大。</p>
</li>
<li><p>《天才在左，疯子在右》<br>高铭<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/天才在左 疯子在右.jpg" alt="天才在左，疯子在右"><br>4星，国内第一本精神病人访谈手记，你可以把它当做故事书，很有趣。</p>
</li>
<li><p>《慢慢来，一切都来得及》<br>meiya<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/慢慢来.一切都来得及.jpg" alt="慢慢来，一切都来得及"><br>4星，被打动的一本书，讲述奋斗路上作者的生命体验。</p>
</li>
<li><p>《魔鬼约会学》<br>魔鬼咨询师<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/魔鬼约会学.jpg" alt="魔鬼约会学"><br>4星，男女思考行为的差距，还有一些活泼的例子。</p>
</li>
<li><p>《5分钟和陌生人成为朋友-101个瞬间化解尴尬的沟通技巧-II : 101个瞬间化解尴尬的沟通技巧》<br>唐·加博尔 / 何云<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/5分钟和陌生人成为朋友-101个瞬间化解尴尬的沟通技巧-II - 101个瞬间化解尴尬的沟通技巧.jpg" alt="5分钟和陌生人成为朋友"><br>3星，例子比较实用，先有心，后有术。</p>
</li>
<li><p>《二十五岁的世界：我在25座城市，遇见的25个人》<br>(西)马克•塞雷纳 / 吴娴敏<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/二十五岁的世界.jpg" alt="二十五岁的世界"><br>3星，印度，菲利宾，津巴布韦到日本寺庙。。有许多细节被震撼到。</p>
</li>
<li><p>《我是个算命先生》<br>易之<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/我是个算命先生.jpg" alt="我是个算命先生"><br>3星，amazon上卖的很火，但是和盗墓笔记比差太多，是纯小说。</p>
</li>
<li><p>《潜伏职场心理学》<br>张超<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/职场潜伏心理学.jpg" alt="潜伏职场心理学"><br>3星，茶语饭后翻一番，还是有收获的。</p>
</li>
<li><p>《软件架构师的12项修炼》<br>Dave Hendricksen / 张菲<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/软件架构师的12项修炼.jpg" alt="软件架构师的12项修炼"><br>2星，讲的太泛了，没啥实用性</p>
</li>
</ul>
<p>完。</p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>年初觉得可能发生的事情，大多数都发生了。
</code></pre><h2 id="一、2014小结">一、2014小结</h2>
<p>去了青岛，舟山，上海，路过香港，台湾12天环岛。（台湾之行，加大我对环球游梦的‘执念’）</p>
<p>11月份，根据地]]>
    </summary>
    
      <category term="日记" scheme="http://vernonzheng.com/tags/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="书单" scheme="http://vernonzheng.com/tags/%E4%B9%A6%E5%8D%95/"/>
    
      <category term="日记" scheme="http://vernonzheng.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NodeJS实战经验总结]]></title>
    <link href="http://vernonzheng.com/2014/12/28/NodeJS%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <id>http://vernonzheng.com/2014/12/28/NodeJS实战经验总结/</id>
    <published>2014-12-28T05:07:57.000Z</published>
    <updated>2014-12-29T01:17:18.000Z</updated>
    <content type="html"><![CDATA[<pre><code>看完《Node.js 实战》，整理总结了觉得比较有价值的内容。
</code></pre><h2 id="1、require">1、require</h2>
<p>require是少有的同步i/o操作，请只在模块初始化时候使用require。</p>
<h2 id="2、exports与module-exports的区别">2、exports与module.exports的区别</h2>
<p>最终程序里导出的都是module.exports。<br>而exports只是对module.exports的一个<strong>全局引用</strong>，如exports.myFunc为module.exports.myFunc的简写。<br>为了不破坏exports对module.exports的引用，不能设置exports。<br>如果破坏了，修复方式：<br>module.exports = exports = Currency;</p>
<h2 id="3、模块缓存与猴子补丁：">3、模块缓存与猴子补丁：</h2>
<p>Node 能把模块作为对象缓存起来。<br>如果程序中的两个文件引入了相同的模块，第一个文件会把模块返回的数据存到程序的内存中，这样第二个文件就不用再去访问和计算模块的源文件了。<br>实际上在第二个引入是有机会修改缓存数据的。这种方式称为“猴子补丁”（monkey patching ）：让一个模块可以改变另一个模块的行为，开发人员可以不用创建它的新版本。</p>
<h2 id="4、Node两种常用的响应逻辑组织方式">4、Node两种常用的响应逻辑组织方式</h2>
<p><strong>一次性为回调函数，绑定的为事件</strong>（继承event emitter事件发射器，emit发射消息）</p>
<p>这里给个event emitter的例子：</p>
<p>扩展文件监视器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**Watcher构造器**/</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Watch</span><span class="params">(watchDir, processDir)</span></span>{</div><div class="line">	<span class="keyword">this</span>.watchDir = watchDir;</div><div class="line">	<span class="keyword">this</span>.processedDir = processDir;</div><div class="line">}</div><div class="line"><span class="comment">/**继承eventEmitter行为**/</span></div><div class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(‘events’);</div><div class="line">util = reuqire(‘util’);</div><div class="line">util = util.inherits(Watcher, event.EventEmitter);</div><div class="line"></div><div class="line"><span class="comment">/**相当于Watcher.prototype = new events.EventEmitter();**/</span></div><div class="line"></div><div class="line"><span class="comment">/**再增加两个功能**/</span></div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(‘fs’)</div><div class="line">, watchDir = ‘./watch’</div><div class="line">, processedDir = ‘./done’</div><div class="line"></div><div class="line">Watcher.prototype.watch = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">	<span class="keyword">var</span> watcher = <span class="keyword">this</span>;</div><div class="line">	fs.readdir(<span class="keyword">this</span>.watchDir, <span class="function"><span class="keyword">function</span><span class="params">(err, files)</span></span>{</div><div class="line">		<span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</div><div class="line">		<span class="keyword">for</span>( <span class="keyword">var</span> index <span class="keyword">in</span> files){</div><div class="line">			watcher.emit(‘process’, files[index]);</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div><div class="line">Watcher.prototype.start = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">	<span class="keyword">var</span> watcher = <span class="keyword">this</span>;</div><div class="line">	fs.watchFile(watchDir, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">		watcher.watch();</div><div class="line">	});</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="5、减少if/else引起的回调嵌套">5、减少if/else引起的回调嵌套</h2>
<p>有两种方式，可以结合到一起用：</p>
<ul>
<li>（1）嵌套间引入中间函数，通过函数调用拆分嵌套</li>
<li>（2）尽早从函数中返回</li>
</ul>
<h2 id="6、Node的异步回调惯例">6、Node的异步回调惯例</h2>
<p>Node大多数内置模块使用回调会带两个参数，一个是err或者er，一个是存放结果。</p>
<h2 id="7、进程退出会等待事件异步完成">7、进程退出会等待事件异步完成</h2>
<p>Node的事件轮询会跟踪还没有完成的异步逻辑，只要有未完成的异步逻辑，Node进程就不会退出。事件轮询会跟踪所有数据库连接，知道它们关闭，以防止Node退出。</p>
<h2 id="8、在Node中使用闭包保留全局变量示例">8、在Node中使用闭包保留全局变量示例</h2>
<p>示例，用闭包私有化color值：<br>这里有一个asyncFunction函数，对它的调用被封装到一个匿名函数里，参数为color。<br>这样你就可以马上执行这个匿名函数，把当前的 color 的值传给它。而color 变成了匿名函数内部的本地变量，当 匿名函数外面的color 值发生变化时，本地版的color 不会受影响。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunction</span><span class="params">(callback)</span></span>{</div><div class="line">     setTimeout(callback, <span class="number">200</span>);</div><div class="line">}</div><div class="line"><span class="keyword">var</span> color = ‘blue’;</div><div class="line">(<span class="function"><span class="keyword">function</span><span class="params">(color)</span></span>{</div><div class="line">     asyncFunction(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">         <span class="built_in">console</span>.log(’The color is ‘ + color);</div><div class="line">     })(color);</div><div class="line">color = ‘green’;</div></pre></td></tr></table></figure>

<h2 id="9、Node的content-length与chunk">9、Node的content-length与chunk</h2>
<p>Node默认是chunk方式传输（块编码）。当设置content-length时，会隐含禁用Node的块编码。设置content-length传输，数据更少，提升性能。</p>
<p><strong>注意</strong>：<br>content-length是字节长度，不是字符长度，一般用Buffer.byteLength(body)</p>
<h2 id="10、__dirname">10、__dirname</h2>
<p>__dirname表示文件所在目录的路径，在开发时，这个目录和当前工作目录（CWD）是同个目录，但是生产环境可能是从另外一个目录运行。</p>
<h2 id="11、中间件设计惯例">11、中间件设计惯例</h2>
<p>中间件一般有三个参数：请求，响应，回调函数next<br>为了提供可配置能力，中间件遵循一个惯例：用函数返回另一个函数（闭包）</p>
<p>可配置中间件的<strong>基本结构</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setup</span><span class="params">(options)</span></span>{</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(req,res,next)</span></span>{</div><div class="line">	<span class="comment">//中间件逻辑</span></div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.use(setup({some:’options’}))</div></pre></td></tr></table></figure>

<h2 id="12、错误处理中间件">12、错误处理中间件</h2>
<p>错误处理中间件与普通中间三个参数不同，多了第一个参数err，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">errorHandler</span><span class="params">()</span></span>{</div><div class="line">	<span class="keyword">var</span> env = process.env.NODE_ENV || ‘development’;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(err, req, res, next)</span></span>{</div><div class="line">		res.statusCode = <span class="number">500</span>;</div><div class="line">		<span class="keyword">switch</span>(env){</div><div class="line">		<span class="keyword">case</span> ‘development’:</div><div class="line">			res.setHeader(‘content-type’, ‘application/json’);</div><div class="line">			res.end(<span class="built_in">JSON</span>.stringify(err));</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			res.end(’Server error’);</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>当Connect遇到错误，它会跳过后续的中间件，只调用错误处理中间件。</strong></p>
<p>在使用connect时，错误处理有三种方式：</p>
<ul>
<li>（1）使用Connect 默认的错误处理器；</li>
<li>（2）自己处理程序错误；</li>
<li>（3）使用多个错误处理中间件组件。</li>
</ul>
<p>第三种给个示例：<br>多个错误处理器的实现：<br>api挂载在/api上：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> api = connect()</div><div class="line">	.use(users)</div><div class="line">	.use(pets)</div><div class="line">	.use(errorHandler);</div><div class="line"></div><div class="line"><span class="keyword">var</span> app = connec()</div><div class="line">	.use(hello)</div><div class="line">	.use(<span class="string">'/api'</span>, api)</div><div class="line">	.use(errorPage)</div><div class="line">	.listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure>

<p><img src="http://7te9ul.com1.z0.glb.clouddn.com/nodejs_in_action_duplicate_error_handle.png" alt="connect_dumplicate_error"><br>其中errorHandler处理来自api的所有错误，error处理来自app的所有错误。</p>
<h2 id="13、connect中间件">13、connect中间件</h2>
<p>包括：</p>
<ul>
<li>（1）cookieParser：为后续中间件提供req.cookies和req.signedCookies，<br>设置cookie这样用：res.setHeader(’Set-Cookie’,’’)</li>
<li>（2）bodyParser：为后续中间件提供req.body和req.files</li>
<li>（3）limit：基于给定字节长度限制请求主体的大小。必须用在bodyParser中间件之前，防止攻击。<br>更灵活的使用：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">app.use(type(‘application/x-www-form-urlencoded’, connect.limit(‘<span class="number">64</span>kb’))</div><div class="line">app.use(type(‘appication/json’, connect.limit(‘<span class="number">32</span>kb’)))</div></pre></td></tr></table></figure>

<ul>
<li>（4）query：为后续中间件提供req.query</li>
<li>（5）logger：将http请求的信息输出到stdout或日志文件之类的流中</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.user(connect.logger(‘dev’))</div></pre></td></tr></table></figure>

<p>输出有颜色区分的日志，便于开发调试<br><strong>两种输出日志频率</strong><br>immediate，表示一收到请求，就写日志。<br>buffer，以毫秒为单位，指定缓冲区刷新的时间间隔。</p>
<ul>
<li>（6）favicon：响应/favicon.ico http请求。通常放在中间件logger前面，这样它就不会出现在你的日志中了</li>
<li>（7）methodOverride：可以替不能使用正确请求方法的浏览器仿造req.method,依赖于bodyParser</li>
<li>（8）vhost：根据制定的主机名（如nodejs.org)使用给定的中间件和http服务器实例<br>可以做反向代理，缺点：一个网站崩溃，他的所有网站都会崩溃，一个都在同一个进程</li>
<li>（9）session：为用户设置一个http回话，并提供一个可以跨域请求的持久化req.session对象，依赖于cookieParser</li>
<li>（10）basicAuth：为程序提供http基础认证</li>
<li>（11）csrf：防止http表单中的跨站请求仿造攻击，依赖于session</li>
<li>（12）errorHandler：当出现错误时把堆栈跟踪信息返回给客户端。在开发时使用，不要在生产环境中使用</li>
<li>（13）static：把制定目录中的文件发给http客户端，跟connect的挂在功能配合得很好<br>返回./public目录下的静态资源文件：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.use(connect.static(‘public’));</div></pre></td></tr></table></figure>

<p>默认请求/js/test.js，会去.public/js/test.js去查找。<br>使用带挂载的static</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.use(‘/app/files’, connect.static(‘public’));</div></pre></td></tr></table></figure>

<ul>
<li>（14）compress：用gzip压缩优化http响应</li>
<li>（15）directory：为http客户端提供目录清单服务，基于客户端的accept请求（普通文件，son或html）提供经过优化的结果</li>
</ul>
<h2 id="14、_Express中两种渲染视图方式">14、 Express中两种渲染视图方式</h2>
<ul>
<li>（1）在程序中使用app.render（）</li>
<li>（2）在请求或者响应层用res.render()</li>
</ul>
<h3 id="14-1_视图的查找设置">14.1 视图的查找设置</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.set(‘views’,__dirname+’/views’);</div></pre></td></tr></table></figure>

<h3 id="14-2_设置模板引擎">14.2 设置模板引擎</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">app.set(‘view engine’, ‘jade’);</div><div class="line">app.get(‘/‘, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">     <span class="comment">/**假定为.jade**/</span>    </div><div class="line">     res.render(‘index’);</div><div class="line">});</div><div class="line">app.get(‘/feed’, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">     <span class="comment">/**因为扩展名为.ejs,所以使用EJS**/</span></div><div class="line">     res.render(‘rss.ejs’);</div><div class="line">});</div></pre></td></tr></table></figure>

<h3 id="14-3_视图缓存">14.3 视图缓存</h3>
<p>默认会开启view cache，模板修改，需要重启生效。</p>
<h3 id="14-4_视图查找">14.4 视图查找</h3>
<p>如photos为复数，暗示是一个资源列表。<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/blognodejs_in_action_express_view_search.png" alt="express_search"></p>
<h2 id="15、单元测试与验收测试">15、单元测试与验收测试</h2>
<p>有两种形态：测试驱动（TDD）和行为驱动开发（BDD）</p>
<ul>
<li>单元测试有Node的assert，Mocha，node unit，Vows以及should.js框架</li>
<li>验收测试，Tobi和Soda框架。<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/nodejs_in_action_test_soda.png" alt="test-modules-summary"></li>
</ul>
<h3 id="15-1_nodeunit：">15.1 nodeunit：</h3>
<p>例子：创建一个目录，每个测试脚本都应该用测试组装exports对象，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">exports.testPony = <span class="function"><span class="keyword">function</span><span class="params">(test)</span></span>{</div><div class="line">     <span class="keyword">var</span> isPony = <span class="literal">true</span>;</div><div class="line">     test.ok(isPony, ’This is not a pony.’);</div><div class="line">     test.done();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>nodeunit会自动给传入它的对象中引入assert模块。<br>nodeunit提供test.epect验证断言执行数量是否符合预期。</p>
<h3 id="15-2_mocha">15.2 mocha</h3>
<p>只支持串行测试，默认2s的timeout，并行请用vows：<br>BDD风格：describe,it,before,after,beforeEach,afterEach.<br>TDD风格：suite，test，setup，teardown替换上述</p>
<p>执行mocha，会执行./test目录下的javascript文件。</p>
<ul>
<li><strong>BDD风格</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> memdb = <span class="built_in">require</span>(‘..’);</div><div class="line"><span class="keyword">var</span> assert = <span class="built_in">require</span>(‘assert’);</div><div class="line"></div><div class="line">describe(‘memdb’, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">     describe(‘.save(doc)’, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">         it(’should save the documment’, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">              <span class="keyword">var</span> pey = { name: ’Tobi’ );</div><div class="line">               memdb.save(pet);</div><div class="line">               <span class="keyword">var</span> ret = memdb.first({ name: ’Tobi’ });</div><div class="line">               assert(ret == pet);</div><div class="line">          }</div><div class="line">     )</div><div class="line">)</div></pre></td></tr></table></figure>

<ul>
<li><strong>TDD风格</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = {</div><div class="line">     ‘memdb’ : {</div><div class="line">          ‘.save(doc)’ : {</div><div class="line">               ’should save the <span class="built_in">document</span>’ : <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">               }</div><div class="line">           }</div><div class="line">       }</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li><strong>测试异步</strong><br>增加done（）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">describe(‘.save(doc)’, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">     it(’should save the <span class="built_in">document</span>’, <span class="function"><span class="keyword">function</span><span class="params">(done)</span></span>{</div><div class="line">         <span class="keyword">var</span> pey = { name: ’Tobi’};</div><div class="line">          memdb.save(pet, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">              <span class="keyword">var</span> ret = memdb.first({ name: ’Tobi’ });</div><div class="line">               assert(ret == pet);</div><div class="line">               done();</div><div class="line">          }</div><div class="line">     }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="15-3_vows">15.3 vows</h3>
<p>支持并行测试</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> vows = <span class="built_in">require</span>(‘vows’);</div><div class="line"><span class="keyword">var</span> assert = <span class="built_in">require</span>(‘assert’);</div><div class="line"><span class="keyword">var</span> Todo = <span class="built_in">require</span>(‘./todo’);</div><div class="line"></div><div class="line">vows.describe(’Todo’).addBatch({</div><div class="line">     ‘when adding an item’:{</div><div class="line">          topic: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">               <span class="keyword">var</span> todo = <span class="keyword">new</span> Todo();</div><div class="line">               todo.add(‘Feed my cat’);</div><div class="line">               <span class="keyword">return</span> todo;</div><div class="line">          }</div><div class="line">     },</div><div class="line">     ‘it should exit <span class="keyword">in</span> my todos’: <span class="function"><span class="keyword">function</span><span class="params">(er, todo)</span></span>{</div><div class="line">         assert.equal(todo.getCount(), <span class="number">1</span>);</div><div class="line">     }</div><div class="line">}).run();</div></pre></td></tr></table></figure>

<p>如果你想把这段代码放到测试文件夹下，放在可以由Vows测试运行期运行，<br>run.()改成export(module);<br>然后<br>vows test/*</p>
<h3 id="15-4_should-js">15.4 should.js</h3>
<p>断言库，它有一个Object .prototype属性：可以写表达能力很强的断言。</p>
<h3 id="15-5_Tobi和Soda">15.5 Tobi和Soda</h3>
<p>Tobi模拟浏览器测试，可以结合should.js<br>Soda远程控制真实的浏览器：<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/blognodejs_in_action_test_soda.png" alt="test_tobi"></p>
<h2 id="16、使用EJS过滤器处理模板数据">16、使用EJS过滤器处理模板数据</h2>
<p><strong>格式</strong></p>
<p>&lt;%=:用在转义的EJS输出上的过滤器<br>&lt;%-:用在非转义的EJS输出上的过滤器</p>
<p>例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var ejs = require(‘ejs’);</div><div class="line">var template = ‘&lt;%=: movies | sort | first %&gt;’;</div><div class="line">var context = {‘movies’: [</div><div class="line">     ‘Bambi’,</div><div class="line">     ‘Babe: Pig in the city’,</div><div class="line">     ‘Enter the Void'</div><div class="line">]};</div></pre></td></tr></table></figure>

<p>看来上就是linux的管道符处理，</p>
<p><strong>各种常用处理</strong></p>
<ul>
<li>（1）处理选择：last，first，get:N</li>
<li>（2）处理大小写：capitalize把第一个字母变大写，还有upcase，downcase</li>
<li>（3）处理文本：把文本截成一定数量的单词truncate:20,替换replace:’A’,’B’,<br>排序sort，sort_by:’name’，其中sort返回的是对象，要返回属性的话：|get:’name’</li>
<li>（4）map：不用sort_by，再get。直接用map创建一个包含对象属性的数组，<br>map ’name’| sort|</li>
</ul>
<p>其他模板引擎：<br>Hotgan：实现mustache语法。<br>Jade：特点是空格的作用，缩进表示HTML的嵌入关系。</p>
<h2 id="17、fs-watchfile()与fs-watch()">17、fs.watchfile()与fs.watch()</h2>
<p>fs.watchfile()与fs.watch()是 Node.js中的两个监测文件API。</p>
<ul>
<li>比较老的是fs.watchFile,使用轮询的方式检查文件，不断的stat()，比较mtime时间戳.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(‘fs’);</div><div class="line">fs.watchFile(‘/<span class="keyword">var</span>/log/system.log’, <span class="function"><span class="keyword">function</span><span class="params">(curr, prev)</span></span>{</div><div class="line">     <span class="keyword">if</span>(cur.mtime.getTime() !== prev.mtime.getTime()){</div><div class="line">          <span class="built_in">console</span>.log(‘“System.log” has been modified’);</div><div class="line">     }</div><div class="line">});</div></pre></td></tr></table></figure>

<ul>
<li>新的api是fs.watch()，根据平台本地的文件修改通知API监测文件，性能更优，但是不如watchFile可靠。在OSX监测目录不会报告参数filename，其他见： 档<a href="http://nodejs.org/api/fs.html#fs_caveats" target="_blank" rel="external">http://nodejs.org/api/fs.html#fs_caveats</a></li>
</ul>
<h2 id="18、Process模块">18、Process模块</h2>
<ul>
<li>process.argv 存储了Node运行当前脚本时传入的参数</li>
<li>process.env 获取或设定环境变量</li>
<li>process不是eventEmitter实例，却可以发出exit和uncaughtException事件</li>
</ul>
<p><strong>注意点：</strong><br>其中exit是在事件循环（event loop）停止之后才激发的，所以你没有机会在exit事件启动任何异步任务。</p>
<h3 id="18-1_Process的信号处理">18.1 Process的信号处理</h3>
<p>UINX有信号的概念，是进程间通信（IPC）的基础形式，它是一组固定的名称，不能传递参数。</p>
<p><strong>信号举例如下</strong></p>
<ul>
<li>SIGUSR1：Node进入它内置的调试器</li>
<li>SIGWINCH：调试终端大小，由shell发送</li>
<li>SIGINT:ctrl+c，由shell发送，Node默认行为是杀死进程。如果你希望在杀掉服务器前，完成所有连接的处理，可以</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">process.on(’SIGINT’, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">     <span class="built_in">console</span>.log(‘Got Ctrl-C!’);</div><div class="line">     server.close();</div><div class="line">});</div></pre></td></tr></table></figure>

<ul>
<li>还有SIGUSR2和SIGKILL等等</li>
</ul>
<h2 id="19、子进程">19、子进程</h2>
<p>在NODE中创建子进程三种</p>
<ul>
<li>高层api，exec：在回调中创建命令并缓存结果的高层api。</li>
<li>底层api，spawn：将单例命令创建Child-Process对象中的底层API。</li>
<li>内置的特殊IPC通道fork：用内置的IPC通道创建额外Node进程的特殊方法。</li>
</ul>
<p><strong>三者比较</strong></p>
<ul>
<li><p>cp.exec()：只关心结果，不用从子进程的stdio流中访问数据（IRC协议模块有很多，irc，irc-js等等），结果需要转义，可以用execFile（）</p>
</li>
<li><p>cp.spawn()：返回一个可以交互的ChildProcess对象，允许你跟每个子进程的stdio流交互。（node-cgi范例模块）</p>
</li>
<li><p>cp.fork()：也返回一个ChildProcess对象，区别是这个API是用IPC通道添加的， 子进程现在有一个child.send(message) 函数，并且用fork() 调用的脚本能够监听process.on(‘message’) 事件。fork出来的子进程可以参与运算。</p>
</li>
</ul>
<h2 id="20、其他推荐的社区模块">20、其他推荐的社区模块</h2>
<ul>
<li>表单提交：foridable。</li>
<li>redis：hiredis，升级node时候，需要重新编译一下hiredis，npm rebuild hiredis。</li>
<li>mongodb：mongoose，使用时有个{safe：ture}选项表明你想让数据库操作在执行回调之前完成。</li>
</ul>
<hr>
<p>参考：<br>《Node.js 实战》：<a href="http://book.douban.com/subject/25870705/" target="_blank" rel="external">http://book.douban.com/subject/25870705/</a><br>《Node.js in action》：<a href="http://book.douban.com/subject/6805117/" target="_blank" rel="external">http://book.douban.com/subject/6805117/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>看完《Node.js 实战》，整理总结了觉得比较有价值的内容。
</code></pre><h2 id="1、require">1、require</h2>
<p>require是少有的同步i/o操作，请只在模块初始化时候使用require。</p>
<h2]]>
    </summary>
    
      <category term="nodejs" scheme="http://vernonzheng.com/tags/nodejs/"/>
    
      <category term="经验总结" scheme="http://vernonzheng.com/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
      <category term="nodejs" scheme="http://vernonzheng.com/categories/nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[整合Sentry和NodeJS实现分布式日志收集]]></title>
    <link href="http://vernonzheng.com/2014/12/26/%E6%95%B4%E5%90%88Sentry%E5%92%8CNodejs%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/"/>
    <id>http://vernonzheng.com/2014/12/26/整合Sentry和Nodejs实现分布式日志收集/</id>
    <published>2014-12-26T10:13:42.000Z</published>
    <updated>2015-01-14T09:52:00.000Z</updated>
    <content type="html"><![CDATA[<pre><code>内容包括如何利用raven-node模块，完成nodejs服务与开源日志框架Sentry的对接，实现分布式日志收集，附Http接口的性能测试，不涉及Sentry的使用。
</code></pre><h2 id="一、什么是Sentry？">一、什么是Sentry？</h2>
<p>一个基于Djongo的日志收集系统。具备收集日志（对于分布式环境下，日志分布在各台服务器上）、日志统计（统计次数最多的异常，往往这就是系统的隐患所在）、监控告警（出现异常或者异常积累到一定数量以短信或者邮件的形式告警）、以及以上功能的可视化界面。</p>
<p>目前我们部署公网sentry是6.4.4，<br><a href="http://sentry.funshion.com/dev-web-ads/hermes/" target="_blank" rel="external">http://sentry.funshion.com/dev-web-ads/hermes/</a><br>支持的raven-node是0.7.2<br><a href="https://github.com/getsentry/raven-node" target="_blank" rel="external">https://github.com/getsentry/raven-node</a></p>
<h2 id="二、NodeJS接入Sentry">二、NodeJS接入Sentry</h2>
<p>在package.json中增加dependencies：”raven”: “0.7.2”</p>
<p>调用方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> raven = <span class="built_in">require</span>(‘raven’);</div><div class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> raven.Client(‘http:<span class="comment">//32位:32位@sentryHost');</span></div></pre></td></tr></table></figure>

<h3 id="2-1_raven-node两种使用方式">2.1 raven-node两种使用方式</h3>
<ul>
<li>2.1.1 全局拦截与实现</li>
</ul>
<p>调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">client.patchGlobal();</div></pre></td></tr></table></figure>

<p>源码如下，拦截所有uncaughtException。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports.patchGlobal = <span class="function"><span class="keyword">function</span> <span class="title">patchGlobal</span><span class="params">(client, cb)</span> </span>{</div><div class="line">    <span class="comment">// handle when the first argument is the callback, with no client specified</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> client === <span class="string">'function'</span>) {</div><div class="line">        cb = client;</div><div class="line">        client = <span class="keyword">new</span> Client();</div><div class="line">    <span class="comment">// first argument is a string DSN</span></div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> client === <span class="string">'string'</span>) {</div><div class="line">        client = <span class="keyword">new</span> Client(client);</div><div class="line">    }</div><div class="line">    <span class="comment">// at the end, if we still don't have a Client, let's make one!</span></div><div class="line">    !(client <span class="keyword">instanceof</span> Client) && (client = <span class="keyword">new</span> Client());</div><div class="line"></div><div class="line">    process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span><span class="params">(err)</span> </span>{</div><div class="line">        <span class="keyword">if</span>(cb) {  <span class="comment">// bind event listeners only if a callback was supplied</span></div><div class="line">            client.once(<span class="string">'logged'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">                cb(<span class="literal">true</span>, err);</div><div class="line">            });</div><div class="line">            client.once(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">                cb(<span class="literal">false</span>, err);</div><div class="line">            });</div><div class="line">        }</div><div class="line">        client.captureError(err, <span class="function"><span class="keyword">function</span><span class="params">(result)</span> </span>{</div><div class="line">            node_util.log(<span class="string">'uncaughtException: '</span>+client.getIdent(result));</div><div class="line">        });</div><div class="line">    });</div><div class="line">};</div></pre></td></tr></table></figure>

<p>测试下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> raven = <span class="built_in">require</span>(<span class="string">"raven"</span>)</div><div class="line"></div><div class="line">  <span class="keyword">var</span> testRaven = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">var</span> client = <span class="keyword">new</span> raven.Client(<span class="string">'http://a374661ff0374e488...略'</span>);</div><div class="line">    client.patchGlobal();</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"test throw error"</span>);</div><div class="line">    }<span class="keyword">catch</span>(err){</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"i'm caught error and throw myself again!"</span>)</div><div class="line">    }</div><div class="line">    <span class="comment">//client.captureError('test captureMessage');</span></div><div class="line">  }</div></pre></td></tr></table></figure>

<p>在sentry上显示如下：<br>会显示function名，Error message，错误出现次数等<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/sentry-test-item" alt="setry-test-item"><br>点进详情，看到程序调用栈：<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/sentry-aggregation" alt="sentry-aggregation"></p>
<ul>
<li>2.1.2 手动调用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// record a simple message</span></div><div class="line">client.captureMessage(<span class="string">'hello world!'</span>)</div><div class="line"><span class="comment">// capture an exception</span></div><div class="line">client.captureError(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Uh oh!!'</span>));</div></pre></td></tr></table></figure>

<h3 id="2-2_raven-node推荐使用方式">2.2 raven-node推荐使用方式</h3>
<p>统一使用第二种:<br>（1）对于uncaughtException使用下图方式输出到sentry：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span><span class="params">(err)</span> </span>{</div><div class="line">    ravenClient.captureError(err)</div><div class="line">    <span class="comment">//console.log("uncaughtException:" + err.stack);</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  });</div></pre></td></tr></table></figure>

<p>（2）对于catchException或者业务错误，重写log的实现，完成可配置哪个log类型输出到sentry。</p>
<h3 id="2-3_raven-node容灾考虑">2.3 raven-node容灾考虑</h3>
<p>看完怎么导入使用后，如果把它丢到生产环境，我想到的，还需要考虑的问题有：</p>
<p>（1）日志发送应该是纯异步的，不影响业务。<br>（2）发日志是调用tcp还是udp还是http接口。<br>（3）超时重发机制。<br>（4）sentry挂了怎么处理。<br>（5）sentry忙不过来怎么处理。<br>等等。</p>
<ul>
<li>2.3.1 raven-node支持的协议</li>
</ul>
<p>要回答这些问题，看下sentry的transport.js。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports.http = <span class="keyword">new</span> HTTPTransport();</div><div class="line"><span class="built_in">module</span>.exports.https = <span class="keyword">new</span> HTTPSTransport();</div><div class="line"><span class="built_in">module</span>.exports.udp = <span class="keyword">new</span> UDPTransport();</div><div class="line"><span class="built_in">module</span>.exports.Transport = Transport;</div></pre></td></tr></table></figure>

<p>支持三种方式，根据SENTRY创建项目的设置来实现，体现在SENTRY_DNS的host里。<br>因为我们都是对内网服务器日志的监控，一般使用http。</p>
<ul>
<li>2.3.2 raven-node中http协议实现-send函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">HTTPTransport.prototype.send = <span class="function"><span class="keyword">function</span><span class="params">(client, message, headers, ident)</span> </span>{</div><div class="line">    <span class="keyword">var</span> options = {</div><div class="line">        hostname: client.dsn.host,</div><div class="line">        path: client.dsn.path + <span class="string">'api/store/'</span>,</div><div class="line">        headers: headers,</div><div class="line">        method: <span class="string">'POST'</span>,</div><div class="line">        port: client.dsn.port || <span class="keyword">this</span>.defaultPort</div><div class="line">    }, req = <span class="keyword">this</span>.transport.request(options, <span class="function"><span class="keyword">function</span><span class="params">(res)</span></span>{</div><div class="line">        res.setEncoding(<span class="string">'utf8'</span>);</div><div class="line">        <span class="keyword">if</span>(res.statusCode &gt;= <span class="number">200</span> && res.statusCode &lt; <span class="number">300</span>) {</div><div class="line">            client.emit(<span class="string">'logged'</span>, ident);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">var</span> reason = res.headers[<span class="string">'x-sentry-error'</span>];</div><div class="line">            <span class="keyword">var</span> e = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'HTTP Error ('</span> + res.statusCode + <span class="string">'): '</span> + reason);</div><div class="line">            e.response = res;</div><div class="line">            e.statusCode = res.statusCode;</div><div class="line">            e.reason = reason;</div><div class="line">            e.sendMessage = message;</div><div class="line">            e.requestHeaders = headers;</div><div class="line">            e.ident = ident;</div><div class="line">            client.emit(<span class="string">'error'</span>, e);</div><div class="line">        }</div><div class="line">        <span class="comment">// force the socket to drain</span></div><div class="line">        <span class="keyword">var</span> noop = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{};</div><div class="line">        res.on(<span class="string">'data'</span>, noop);</div><div class="line">        res.on(<span class="string">'end'</span>, noop);</div><div class="line">    });</div><div class="line">    req.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>{</div><div class="line">        client.emit(<span class="string">'error'</span>, e);</div><div class="line">    });</div><div class="line">    req.end(message);</div><div class="line">};</div></pre></td></tr></table></figure>

<p>代码很简短，post msg到{SENTRY_DSN}.host/dsn.path/api/store/，而且<br>（1）没有失败重试<br>（2）发送失败（resp状态码不是200或者req调用的error），发送事件到client.emit(‘error’)，再看下client对error事件的处理：none。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>{});  <span class="comment">// noop</span></div></pre></td></tr></table></figure>

<h2 id="三、小结与优化">三、小结与优化</h2>
<h3 id="3-1_疑问解答">3.1 疑问解答</h3>
<p>回答下前面对sentry和raven-node的疑问：</p>
<ul>
<li>（1）日志发送应该是纯异步的，不影响业务。<br>  raven-node send日志后是异步回调，但是调用发送日志api是同步的。<br>（因为nodejs是单进程单线程，io异步基本已满足需求，如需优化，可以考虑对整个log模块独立进程，增加重试，发送流量控制等等，但是进程间内存拷贝开销会很大，nodejs的优劣还是很明显的，具体看应用场景）。</li>
<li>（2）发日志是调用tcp还是udp还是http接口。<br>  内网服务日志监控推荐http/udp。</li>
<li>（3）超时重发机制。<br>  无retry机制</li>
<li>（4）sentry挂了怎么处理。</li>
<li>（5）sentry忙不过来怎么处理。<br>  （sentry接受到的请求不是实时处理，接受请求通过队列实现。性能测试可参考：<br><a href="http://blog.csdn.net/largetalk/article/details/8640854）" target="_blank" rel="external">http://blog.csdn.net/largetalk/article/details/8640854）</a><br>  sentry挂了或者忙不过来，client会接收到error，但是不会输出任何异常。</li>
<li>（6）raven-node 连接是否会复用，大量日志需要输出的时候，io和句柄占用都会影响到业务处理，是否需要过载保护？<br>参考3.2</li>
</ul>
<h3 id="3-2_优化与使用建议">3.2 优化与使用建议</h3>
<p>针对上面的rave-node可能存在的问题，给出以下优化建议</p>
<h4 id="3-2-1_规范哪些日志需要输出到sentry">3.2.1 规范哪些日志需要输出到sentry</h4>
<ul>
<li>新增monitor logger类型，专用于输出到sentry</li>
<li>必须error级别以上输出到sentry</li>
<li>error包括uncaughtException，业务异常，外部依赖服务异常，内部异常。（也可以增加服务正常启动的信息给sentry）</li>
</ul>
<h4 id="3-2-2_raven-node优化">3.2.2 raven-node优化</h4>
<p>上面提到的潜在问题总结为</p>
<ul>
<li>日志过多导致内存，句柄等资源占用过多的情况。</li>
<li>sentry异常，发送日志堆积，与日志过多情况相似。</li>
<li>目前与sentry交互的异常日志没有输出（有优点也有缺点）。</li>
</ul>
<p><strong>建议</strong></p>
<p>针对上面前两个问题，对raven-node封装或者扩展，支持固定大小的预发送队列。对外部依赖服务的异常进行隔离。</p>
<p>针对第三个问题，异常分为初始化和正常交互过程中两种情况</p>
<p>可以修改raven-node的client的prototype，支持异常输出日志。</p>
<p>或者<strong>常规解决方法</strong>：</p>
<p>正常交互过程中的异常：可以检测预发送队列的内容进行处理（如超过一定时间/次数，队列内容没有变更视为timeout异常），输出error日志。</p>
<p>初始化异常：因为封装raven-node后，client是复用的，仅当第一次初始化后，进行check，发送一个message：xxx服务启动。</p>
<h2 id="四、性能测试">四、性能测试</h2>
<p>因sentry公网只开了Http的接口，对公网测试的Http接口性能测试如下：</p>
<p><strong>环境：</strong><br>    本机(Mac os x 10.11)，双核四线程，node 0.8，raven-node 0.7.2</p>
<p><strong>tps监测方式：</strong>统计raven-node client：response中end事件的输出时间</p>
<p><strong>测试数据：</strong></p>
<p>4个cluster<br>4000条300byte消息，<br>560ms发送完毕<br>4000条消息，总耗时约5.3s<br>tps大概765/s</p>
<p>1个cluster<br>4000条300byte消息，<br>900ms发送完毕<br>4000条消息，总耗时约11s<br>tps大概365/s</p>
<p>测试是否对项目有连接数的限制：<br>200个cluster<br>20条300byte消息<br>sentry的web管理界面卡顿，raven-node client返回正常</p>
<p><strong>后续追加了不同cluster的性能表现：</strong></p>
<p>总消息数为4000条，每条300byte<br>cluster个数-tps<br>4-765<br>8-1256<br>12-1430<br>16-1752<br>20-1690<br>32-1320<br>注：多个cluster未做类似Barrier的实现（即cluster发起请求非同一起点）会有误差。</p>
<p><strong>结论：</strong><br>    sentry内部利用redis实现任务队列，测试机的tps在1800左右，预估还有较大提升，受限于测试机。如果使用http，极端情况下对client有压力，如果使用udp接口，问题不大，不影响client。另外，sentry连接数没有限制，连接管理表现一般。</p>
<hr>
<p>参考：<br>Raven-node github：<a href="https://github.com/getsentry/raven-node" target="_blank" rel="external">https://github.com/getsentry/raven-node</a><br>Getsentry官网：<a href="https://www.getsentry.com/docs/" target="_blank" rel="external">https://www.getsentry.com/docs/</a><br>使用开源软件sentry来收集日志：<a href="http://luxuryzh.iteye.com/blog/1980364" target="_blank" rel="external">http://luxuryzh.iteye.com/blog/1980364</a><br>关于Sentry：<a href="http://blog.csdn.net/largetalk/article/details/8640854" target="_blank" rel="external">http://blog.csdn.net/largetalk/article/details/8640854</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>内容包括如何利用raven-node模块，完成nodejs服务与开源日志框架Sentry的对接，实现分布式日志收集，附Http接口的性能测试，不涉及Sentry的使用。
</code></pre><h2 id="一、什么是Sentry？">一、什么是Sent]]>
    </summary>
    
      <category term="nodejs" scheme="http://vernonzheng.com/tags/nodejs/"/>
    
      <category term="sentry" scheme="http://vernonzheng.com/tags/sentry/"/>
    
      <category term="监控" scheme="http://vernonzheng.com/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="性能测试" scheme="http://vernonzheng.com/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
      <category term="nodejs" scheme="http://vernonzheng.com/categories/nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Coffeescript极简教程]]></title>
    <link href="http://vernonzheng.com/2014/12/20/Coffeescript%E6%9E%81%E7%AE%80%E6%95%99%E7%A8%8B/"/>
    <id>http://vernonzheng.com/2014/12/20/Coffeescript极简教程/</id>
    <published>2014-12-20T14:17:30.000Z</published>
    <updated>2014-12-28T10:38:17.000Z</updated>
    <content type="html"><![CDATA[<pre><code>配合没耐心的nodejs教程，写给希望快速上手的coffeescript使用者。
</code></pre><h2 id="一、一些简写和约定：">一、一些简写和约定：</h2>
<p>coffeescript和python类似，空格，缩写都是有意义的。<br>换行替换分号，缩进替换花括号，空格替换括号，<br>但是数组的’[]’不能省略。</p>
<h2 id="二、全局变量：">二、全局变量：</h2>
<p>CoffeeScript剔除了全局变量，避免js中全局变量的误用。（CoffeeScript使用一个匿名函数把所有脚本都包裹起来，将其限定在局部作用域中，并且在为所有的变量赋值前自动添加var）</p>
<p>当然也有需要用全局变量的时候，直接给全局对象windoow赋值即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">exports = this</div><div class="line">exports.tempVal = “tempVal”</div></pre></td></tr></table></figure>

<p>这里在顶级作用域中使用，this相当于全局变量</p>
<h2 id="三、函数">三、函数</h2>
<h3 id="3-1_函数的标准写法">3.1 函数的标准写法</h3>
<p>-&gt; 替代了function(){}<br>如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sum = (nums...) -&gt; </div><div class="line">	result = <span class="number">0</span></div><div class="line">	nums.forEach(n) -&gt; result += n</div><div class="line">	result</div></pre></td></tr></table></figure>

<p>（nums）为传入的参数槽（splats），…表示不定参数，同时自动返回result<br>调用输出结果 alert sum() 或者 alert sum a,b,c ,其中空格表示括号，但是易混淆或者无参调用的时候，请带上括号。</p>
<p><strong><em>多重赋值：</em></strong></p>
<p>btw，因为讲到…不定参数，就提下多重赋值与…的结合：<br>多重赋值就是将一个数组的值逐个赋给后面的一系列变量。<br>如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">myArray = [<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D”] </span></div><div class="line">[start, middle..., end] = myArray </div><div class="line">console.log "start is <span class="comment">#{start}” </span></div><div class="line">console.log <span class="string">"middle is #{middle}” </span></div><div class="line">console.log "end is <span class="comment">#{end}”</span></div></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">start is A </div><div class="line">middle is B,C </div><div class="line">end is D</div></pre></td></tr></table></figure>

<p>顺便提下，数组是支持range的用法的，[1…10]</p>
<h3 id="3-2函数上下文：">3.2函数上下文：</h3>
<p>js的上下文变化会很频繁，尤其在回调函数内，coffeescript提供=&gt;或者self(this)的方式，以下为=&gt;的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">this.clickHandler = -&gt; alert “clicked”</div><div class="line">element.addEventListener “click”, (e) =&gt;</div><div class="line">	his.clickHandler(e)</div></pre></td></tr></table></figure>

<h2 id="四、集合遍历">四、集合遍历</h2>
<h3 id="4-1_for循环：">4.1 for循环：</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myLetters = [“a”,”b”,”c”,”d”]</div><div class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> myLetters</div><div class="line">console.log letter.toUpperCase()</div></pre></td></tr></table></figure>

<p>for中增加when条件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> num，i <span class="keyword">in</span> a when num &lt; <span class="number">5</span></div><div class="line">console.log “第<span class="comment">#{i}个数为#{num}"</span></div></pre></td></tr></table></figure>

<h3 id="4-2_列表推导式(Comprehension)">4.2 列表推导式(Comprehension)</h3>
<p>类似ruby的前缀表达式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myLetters = [“a”,”b”,”c”,”d”]</div><div class="line"></div><div class="line">console.log letter.toUpperCase() <span class="keyword">for</span> letter <span class="keyword">in</span> myLetters</div></pre></td></tr></table></figure>

<h3 id="4-3_对象枚举的方式">4.3 对象枚举的方式</h3>
<p>(这里in换成了of）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">person = </div><div class="line">firstName: “Mark”</div><div class="line">lastName: “Bates”</div><div class="line"></div><div class="line"><span class="keyword">for</span> key, value of person</div><div class="line">console.log “<span class="comment">#{key} is #{value}”</span></div></pre></td></tr></table></figure>

<p>对象属性的枚举还支持when关键字；如果需要过滤继承属性，还可以使用own关键字</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">myObject = </div><div class="line">name: “Mark”</div><div class="line"></div><div class="line">Object.prototype.dob = new Date(<span class="number">1976</span>, <span class="number">7</span>, <span class="number">24</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> own key, value of myObject</div><div class="line">console.log “<span class="comment">#{key}:#{value}”</span></div></pre></td></tr></table></figure>

<h3 id="4-4_while用法">4.4 while用法</h3>
<p>与js不同，while还可以返回结果数组</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">num = <span class="number">6</span></div><div class="line">minstrel = <span class="keyword">while</span> num -= <span class="number">1</span></div><div class="line">	num + “ Brave Sir Robin ran away”</div></pre></td></tr></table></figure>

<p>综合例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@updateAvatars = -&gt;</div><div class="line">name = $(‘.avatar[data-name]’),map -&gt; $(this).data(’name’)</div><div class="line">Utils.findAvatar(name) <span class="keyword">for</span> name <span class="keyword">in</span> $.unique(names)</div></pre></td></tr></table></figure>

<h2 id="五、别名与存在操作符">五、别名与存在操作符</h2>
<h3 id="5-1_别名：">5.1 别名：</h3>
<p>@ 表示this的别名，如@saviour = this.saviour<br>:: 表示prototype</p>
<h3 id="5-2_存在操作符？：">5.2 存在操作符？：</h3>
<p>coffeescript中，？只会在变量不存在或者undefined的时候返回假，<br>如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">praise <span class="keyword">if</span> brain?</div></pre></td></tr></table></figure>

<p>还可以用来替换||操作符：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">velocity = southern ？ <span class="number">40</span></div></pre></td></tr></table></figure>

<p>或者在访问对象时进行null检查，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">blacknight.getLegs()?.kick()</div></pre></td></tr></table></figure>

<p>判断属性是否存在外，你还也可以把？放到kick右边，判断函数是否存在，是否可以调用等</p>
<h2 id="六、类">六、类</h2>
<p>Coffeescript中类定义是组合模式（组合使用构造模式和原型模式），继承方式则用寄生组合模式。</p>
<h3 id="6-1_定义类">6.1 定义类</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Employee</div><div class="line"></div><div class="line">constructor: (name) -&gt;</div><div class="line">@name = name</div><div class="line">dob: (year = <span class="number">1976</span>, month =<span class="number">7</span>, day = <span class="number">24</span>) -&gt;</div><div class="line">new Date(year, month, day)</div><div class="line"></div><div class="line">emp1 = new Employee(“Mark”)</div><div class="line">console.log emp1.name</div><div class="line">console.og emp11.dob()</div></pre></td></tr></table></figure>

<h3 id="6-2_添加方法">6.2 添加方法</h3>
<p>方法是直接定义在原型上，显示为原型添加方法，很简单：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Array::size = -&gt; @length</div></pre></td></tr></table></figure>

<h3 id="6-3_构造函数简化">6.3 构造函数简化</h3>
<p>如果把参数赋值给同名属性，可以用@语法糖，将构造函数简化为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">constructor: (@name) -&gt;</div></pre></td></tr></table></figure>

<h3 id="6-4_实例变量的使用">6.4 实例变量的使用</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Animal</div><div class="line">	price: <span class="number">5</span></div><div class="line"></div><div class="line">	sell: =&gt;</div><div class="line">		alert “Give me <span class="comment">#{@price} shillings!”</span></div><div class="line"></div><div class="line">animal = new Animal</div><div class="line">$(“<span class="comment">#sell”).click(animal.sell)</span></div></pre></td></tr></table></figure>

<p>其中注意到=&gt;的使用，表示引用方法调用的上下文，输出5.</p>
<h3 id="6-5_静态变量的使用">6.5 静态变量的使用</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class Animal</div><div class="line">	@find: (name) -&gt;</div><div class="line"></div><div class="line">Animal.find(“Parrot”)</div></pre></td></tr></table></figure>

<p>其实就是在类属性上（this）设置变量值。</p>
<h3 id="6-6_继承">6.6 继承</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Animal</div><div class="line">	constructor: (@name) -&gt;</div><div class="line">class Parrot extends Animal</div><div class="line"></div><div class="line">Animal::rip = <span class="literal">true</span></div><div class="line"></div><div class="line">parrot = new Parrot(“Macaw”)</div><div class="line">alert(“This parrot is no more”) <span class="keyword">if</span> parrot.rip</div></pre></td></tr></table></figure>

<p>这里要注意的是，静态变量是直接拷贝给子类的，而不是像实例属性那样使用原型来继承。</p>
<h2 id="七、Mixins混入">七、Mixins混入</h2>
<p>举个例子：<br>module类有两个静态方法，@extend()和@include()，分别来实现对类的静态属性和实例属性的扩展。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">moduleKeywords = [‘exteded’, ‘included’]</div><div class="line"></div><div class="line">class Module</div><div class="line">	@extend: (obj) -&gt;</div><div class="line">		<span class="keyword">for</span> key, value of obj when key not <span class="keyword">in</span> moduleKeywords</div><div class="line">			@[key] = value</div><div class="line">			obj.extended?.apply(@)</div><div class="line">			this</div><div class="line"></div><div class="line">	@include: (obj) -&gt;</div><div class="line">		<span class="keyword">for</span> key, value of obj when key not <span class="keyword">in</span> moduleKeywords</div><div class="line">			<span class="comment"># Assign properties to the prototype</span></div><div class="line">			@::[key] = value</div><div class="line"></div><div class="line">		obj.included?.apply(@)</div><div class="line">		this</div></pre></td></tr></table></figure>

<p>然后是如何使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">classProperties = </div><div class="line">	find: (id) -&gt;</div><div class="line">	create: (attrs) -&gt;</div><div class="line"></div><div class="line">instanceProperties = </div><div class="line">	save: -&gt;</div><div class="line"></div><div class="line">class User extends Module</div><div class="line">	@extends classProperties</div><div class="line">	@include instanceProperties</div><div class="line">	</div><div class="line"><span class="comment"># Usage:</span></div><div class="line">user = User.find((<span class="number">1</span>)</div><div class="line"></div><div class="line">user = new User</div><div class="line">user.save()</div></pre></td></tr></table></figure>

<p>以上，我们为User类添加了静态属性find()和create()，还添加了实例属性save()。</p>
<p>再给一个例子，在扩展类后执行回调：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ORM = </div><div class="line">	find: (id) -&gt;</div><div class="line">	create: (attrs) -&gt;</div><div class="line">	extended: -&gt;</div><div class="line">		@include</div><div class="line">			save: -&gt;</div><div class="line"></div><div class="line">class User extends Module</div><div class="line">	@extends ORM</div></pre></td></tr></table></figure>

<p>基础讲完，接下来就可以围绕网络，文件，进程，异步等进行专项练习了，好运！</p>
<hr>
<p>参考：<br>《The Little Book on CoffeeScript》：<a href="http://book.douban.com/subject/10462179/" target="_blank" rel="external">http://book.douban.com/subject/10462179/</a><br>Learn X in Y minutes Where X=coffeescript：<a href="http://learnxinyminutes.com/docs/coffeescript/" target="_blank" rel="external">http://learnxinyminutes.com/docs/coffeescript/</a><br>CoffeeScript极简教程：<a href="http://chunfenglee.com/blog/2013/10/13/beginning-coffeescript/" target="_blank" rel="external">http://chunfenglee.com/blog/2013/10/13/beginning-coffeescript/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>配合没耐心的nodejs教程，写给希望快速上手的coffeescript使用者。
</code></pre><h2 id="一、一些简写和约定：">一、一些简写和约定：</h2>
<p>coffeescript和python类似，空格，缩写都是有意义的。<b]]>
    </summary>
    
      <category term="coffeescript" scheme="http://vernonzheng.com/tags/coffeescript/"/>
    
      <category term="基础" scheme="http://vernonzheng.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="coffeescript" scheme="http://vernonzheng.com/categories/coffeescript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[没耐心的NodeJS基础教程]]></title>
    <link href="http://vernonzheng.com/2014/12/17/%E6%B2%A1%E8%80%90%E5%BF%83%E7%9A%84NodeJS%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
    <id>http://vernonzheng.com/2014/12/17/没耐心的NodeJS基础教程/</id>
    <published>2014-12-17T15:21:00.000Z</published>
    <updated>2014-12-28T10:41:42.000Z</updated>
    <content type="html"><![CDATA[<pre><code>这是一篇没耐心的nodejs教程，写给希望迅速上手的学习者。基础篇介绍权限，模块，包，工程目录结构，<span class="built_in">npm</span>等，不涉及常用api和中间件等。
</code></pre><h2 id="一、权限问题">一、权限问题</h2>
<p>linux下，nodejs需要监听80或443端口提供HTTP（S）服务时需要root权限。<br>有两种方式：</p>
<ul>
<li>（1）（推荐）需要js提供root权限<blockquote>
<p>$ sudo node server.js</p>
</blockquote>
</li>
<li>（2）使用chmod+s命令让nodejs总是以root权限运行，不安全。<blockquote>
<p>$ sudo chown root /usr/local/bin/node<br>$ sudo chmod +s /usr/local/bin/node</p>
</blockquote>
</li>
</ul>
<h2 id="二、模块">二、模块</h2>
<p>一个文件为一个模块，一个文件路径为一个模块名。<br>编写模块时，有require，exports，module三个变量。</p>
<ul>
<li><strong>2.1 required</strong><br>导入某个模块<blockquote>
<p>var foo1 = required(‘./foo’);//.js后缀可以省略<br>var foo2 = required(“./foo.js”);</p>
</blockquote>
</li>
</ul>
<p>也可以加载或者导入一个json：</p>
<blockquote>
<p>var data = require(‘./data.json’);</p>
</blockquote>
<ul>
<li><p><strong>2.2 exports</strong><br>是当前模块的导出对象，用于导出模块共有方式和属性。</p>
<blockquote>
<p>exports.hello = function(){</p>
<pre><code>console.<span class="built_in">log</span>(‘Hello World!’);
</code></pre><p>};</p>
</blockquote>
</li>
<li><p><strong>2.3 module</strong><br>可以访问当前模块的一些信息，最多的用途就是替换当前模块的到处对象。</p>
<blockquote>
<p>module.export = function(){</p>
<pre><code> console.<span class="built_in">log</span>(‘Hello World!’);
</code></pre><p>};</p>
</blockquote>
</li>
</ul>
<h2 id="三、模块初始化">三、模块初始化</h2>
<p>NodeJS使用CMD模块系统，主模块作为程序入口点，所有模块在执行过程中只初始化一次。</p>
<p><strong>初始化一次</strong></p>
<p>一个模块中的JS代码仅在模块第一次被使用时执行一次，并在执行过程中初始化模块的导出对象。之后，缓存起来的导出对象被重复利用。</p>
<ul>
<li><p><strong>3.1 主模块</strong><br>通过命令行参数传递给NodeJS以启动程序的模块被称为主模块。主模块负责调度组成整个程序的其他模块完成工作。默认是路径下的main.js。</p>
</li>
<li><p><strong>3.2 二进制模块（不推荐）</strong><br>nodejs支持使用c/c++编写二进制模块。编译好的二进制模块除了文件扩展名是.node外，和JS块的使用方式相同。</p>
</li>
</ul>
<h2 id="四、模块路径解析规则">四、模块路径解析规则</h2>
<p>除了相对路径和绝对路径外，require函数还支持第三种形式的路径。</p>
<ul>
<li><p><strong>4.1 内置模块</strong></p>
</li>
<li><p><strong>4.2 node_modules目录</strong><br>专门存放模块的路径。比如某个模块的绝对路径是/home/user/hello.js, 在该模块中使用require(‘foo/bar’)方式加载模块，则NodeJS依次尝试使用以下路径。</p>
<blockquote>
<p>/home/user/node_modules/foo/bar<br>/home/node_modules/foo/bar<br>/node_moduels/foo/bar</p>
</blockquote>
</li>
<li><p><strong>4.3 NODE_PATH环境变量</strong><br>指定额外的模块搜索路径。因为是额外，所以最后搜索。<br>使用：设置NODE_PATH环境变量，linux用：分隔，windows使用；分隔。</p>
</li>
</ul>
<h2 id="五、包">五、包</h2>
<ul>
<li><p><strong>5.1 入口模块</strong><br>多个js模块，组成一个包。所有模块都是同一个路径里，且需要指定一个入口模块，入口模块的导出对象作为包的导出对象。<br>比如cat目录下有main.js,lib1.js,lib2.js。<br>main.js作为入口模块，require lib1.js,lib2.js。</p>
</li>
<li><p><strong>5.2 index.js</strong><br>当模块文件名为index.js,加载模块时就可以使用模块所在目录的路径代替模块文件路径，如可写成<br>var cat = require(‘/home/user/lib/cat’);<br>var cat = require(‘/home/user/lib/cat/index’);</p>
</li>
<li><p><strong>5.3 自定义入口模块和存放位置（package.json）</strong><br>如果你想自定义入口模块的文件名和存放位置，就需要在包目录下包含一个package.json文件，如</p>
<blockquote>
<p>{</p>
<pre><code>“name”: “cat”,
“main”: “./lib/main.js<span class="string">"</span>
</code></pre><p>}<br>如此一来，就可以用require(‘/home/user/lib/cat’)加载。</p>
</blockquote>
</li>
</ul>
<h2 id="六、命令行程序">六、命令行程序</h2>
<p>将固定node命令开头执行的方式，变成命令行的方式。<br>node xx.js [param] =&gt; xx [param]，<br>如$node /home/user/bin/node-echo.js Hello World<br>变成<br>$node-echo Hello World<br>简便很多</p>
<p>那么如何做到，只讲在linux下怎么做：</p>
<ul>
<li>(1)node-echo.js顶部增加<blockquote>
<p>#!/usr/bin/env node</p>
</blockquote>
</li>
<li>(2)然后增加执行权限，并再/usr/local/bin下创建软链接<blockquote>
<p>$ chmod +x /home/user/bin/node-echo.js<br>$ sudo ln -s /home/user/bin/node-echo.js /usr/local/bin/node-echo</p>
</blockquote>
</li>
</ul>
<h2 id="七、工程目录结构">七、工程目录结构</h2>
<blockquote>
<ul>
<li>/home/user/workspace/node-echo/<ul>
<li>bin/<br>  node-echo</li>
</ul>
<ul>
<li>doc/</li>
</ul>
<ul>
<li>lib/<br>  echo.js</li>
<li>node_modules/<ul>
<li>argv/</li>
</ul>
</li>
</ul>
<ul>
<li>tests/<br>package.json<br>README.md</li>
</ul>
</li>
</ul>
</blockquote>
<p>其中部分文件：</p>
<blockquote>
<p>/<em> bin/node-echo </em>/<br>var argv = require(‘argue’),<br>     echo = require(‘../ilb/echo’);<br>console.log(echo(argv.join(‘ ‘)));</p>
<p>/<em> lib/echo.js</em>/<br>module.exports = function(message){<br>    return message;<br>}</p>
<p>/<em> pacakge.json </em>/<br>{<br>    “name”:”node-echo”,<br>    “main”:”./lib/echo.js”<br>}</p>
</blockquote>
<h2 id="八、NPM:包管理工具">八、NPM:包管理工具</h2>
<p>（1）允许用户从NPM服务器下载别人编写的三方包到本地使用。<br>（2）允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。<br>（3）允许用户将自己编写的包或者命令行程序上传到NPM服务器供别人使用。</p>
<ul>
<li><strong>8.1 下载第三方包</strong></li>
</ul>
<p>一般这样使用别人的包(如argv)，<br>在项目目录下，npm install argv@1.1.1，那么argv包就会放到node_modules目录下，直接require(‘argv’)就可以使用了。</p>
<p>依赖的包比较多时，通过package.json字段做了扩展。<br>如：<br>{<br>    “name”: “node-echo”,<br>    “main”: “./lib/echo.js”,<br>    “denpendencies”:{<br>        “argv”: “0.0.2”<br>    }<br>}<br>然后在工程目录，npm install即可。btw，传递的依赖会被自动下载。</p>
<ul>
<li><strong>8.2 安装命令行工具</strong></li>
</ul>
<p>如上面例子的node-echo，只要node-echo自己配置好了对应的package.json字段，对于用户而言，这样安装：</p>
<blockquote>
<p>$ npm install node-echo -g<br>其中-g表示全局安装，node-echo会默认安装到以下位置，并且NPM会自动创建好Linux系统下需要的软链文件。</p>
<ul>
<li>/usr/local/<ul>
<li>lib/node_modules/<ul>
<li>node-echo/<br>…</li>
</ul>
</li>
<li>bin/<br>  node-echo<br>…</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><strong>8.3 发布代码</strong></li>
</ul>
<p>第一次发布npm，需要注册个号码。执行npm adduser，按提示操作。账号完成设置后，编辑需要发布的项目的package.json，加入npm必须字段。<br>如：</p>
<blockquote>
<p>{<br>   “name”: ”node-echo”，#包名，与NPM服务器保持唯一<br>   “version”： “1.0.0”，#当前版本号<br>   “dependencies”：{<br>       “argv”： “0.0.2”<br>   }，<br>   “main”： “./lib/echo.js”,<br>   “bin”: {<br>       “node-echo”: “./bin/node-echo”  #命令行程序名和主模块位置<br>   }<br>}<br>然后，在package.json所在目录下运行npm publish 发布代码。</p>
</blockquote>
<ul>
<li><strong>8.4 版本号</strong></li>
</ul>
<p>使用npm下载或者发布代码都要用到版本号。<br>语义版版本号分为X.Y.Z三位，<br> 分别为主版本号、（大变动，向下不兼容）<br> 次版本号（新增功能，向下兼容）、<br> 补丁版本号（修复bug）。</p>
<h2 id="九、最后npm比较有用的命令行：">九、最后npm比较有用的命令行：</h2>
<ul>
<li>在package.json目录，npm install . -g 可先在本地安装当前命令行程序，用于发布前本地测试。</li>
<li>npm update  <package>当前目录下node_modules子目录下对应模块更新到最新版本。</package></li>
<li>npm update <package> -g 把全局安装的对应命令行程序更新至最新版。</package></li>
<li>npm cache clear 清空NPM本地缓存，用于对于使用相同版本号发布新版本的人。</li>
<li>npm unpublish <package>@<version> 可以撤销自己发布过的某个版本代码。</version></package></li>
</ul>
<hr>
<p>参考：<br>七天学会NodeJS：<a href="http://nqdeng.github.io/7-days-nodejs/\#3.2.1" target="_blank" rel="external">http://nqdeng.github.io/7-days-nodejs/\#3.2.1</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>这是一篇没耐心的nodejs教程，写给希望迅速上手的学习者。基础篇介绍权限，模块，包，工程目录结构，<span class="built_in">npm</span>等，不涉及常用api和中间件等。
</code></pre><h2 id="一、权限问题">]]>
    </summary>
    
      <category term="nodejs" scheme="http://vernonzheng.com/tags/nodejs/"/>
    
      <category term="基础" scheme="http://vernonzheng.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="nodejs" scheme="http://vernonzheng.com/categories/nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《如何阅读一本书》感悟总结]]></title>
    <link href="http://vernonzheng.com/2014/12/15/%E3%80%8A%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E3%80%8B%E6%84%9F%E6%82%9F%E6%80%BB%E7%BB%93/"/>
    <id>http://vernonzheng.com/2014/12/15/《如何阅读一本书》感悟总结/</id>
    <published>2014-12-14T16:27:57.000Z</published>
    <updated>2014-12-28T10:42:01.000Z</updated>
    <content type="html"><![CDATA[<pre><code>阅读一本书，就是和作者交流的过程。与直接面对面交流不同，阅读这种“静默”交流方式，需要不同的经验和技巧。刚看完《如何阅读一本书》，感触比较多，总结一下。
</code></pre><p>读书太快或者太慢都会一无所获。要知道什么时候用什么速度阅读很重要。</p>
<p><strong>好的阅读是</strong></p>
<ul>
<li>（1）主动，包括主动的发现问题，思考问题，做一个自我要求的读者<br>（要去理解作者在说什么，为什么这么说，有道理吗，如果有道理怎么运用它等，最后善于做笔记）。</li>
<li>（2）技巧，根据不同的阅读层次和目的，技巧不同，后面讲到。</li>
</ul>
<p><strong>阅读的目的有两种</strong></p>
<p>一种是为获得咨询而读，一种是求得理解而读。<br>两种的技巧不同。<br>（为求得理解而读的一般发生在两种状况下：<br>一是一开始不对等的理解程度<br>二是阅读的人一定要把不对等的理解力克服到一定程度内。）</p>
<p><strong>阅读的层次</strong></p>
<ul>
<li>基础阅读</li>
<li>检视阅读：系统化略读。获得咨询或者消遣停留在这个层次。</li>
<li>分析阅读：特别是在追求理解。</li>
<li>主题阅读：又称比较阅读，根据主题，阅读很多本书，例举出书之间的相关之处，总结。</li>
</ul>
<p><strong>各层次阅读经验</strong></p>
<ul>
<li><p>检视阅读：<br>（1）头一次面对一本难读的时候，从头到尾先读一遍，碰到不懂的地方不要停下来查询或者思索。<br>（2）避免“逗留”和“倒退”的坏习惯。</p>
</li>
<li><p>分析阅读：<br>（1）根据顺序和关系，列出全书的重要部分，找出作者在问的问题，或作者想要解决的问题，诠释作者使用的关键字，与作者打成共识，找到论述，然后重构前因后果，明白哪些已解决，哪些未解决。<br>（2）应该为感到困扰的问题停留，而不是感兴趣的细节。</p>
</li>
<li><p>主题阅读：<br>略</p>
</li>
</ul>
<p><strong>各类型书的阅读经验</strong></p>
<ul>
<li><p>实用型书：<br>（1）“任何实用型书都不能解决该书的实际问题”，原文有点绕。。我理解为提出是思维，而非答案，最后做解决方案的还是自己。<br>（2）好的阅读者，读实用型书总能读出言外之意，即衍生出来的规则，他会进一步找出这些规则应该如何应用。<br>（3）评断一本实用型书，所有的事都与结果及目标有关，是否与结果达成共识，而非方法。</p>
</li>
<li><p>想象性文学：<br>（1）论述性文学传达的是知识，而想象性文学传达的是经验。</p>
</li>
<li><p>故事书：<br>（1）快，全心全意的读。</p>
</li>
<li><p>戏剧：<br>（1）你在读剧本时，不是在读一个已经完成的作品。<br>（2）悲剧的精髓在于时间，或者说缺乏时间。</p>
</li>
<li><p>历史类，计算机数学类，哲学类，社科类略。</p>
</li>
</ul>
<p>最后感慨下，多读书，多总结出更适合自己的方式。</p>
<hr>
<p>参考：<br>《如何阅读一本书》：<a href="http://book.douban.com/subject/1013208/" target="_blank" rel="external">http://book.douban.com/subject/1013208/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>阅读一本书，就是和作者交流的过程。与直接面对面交流不同，阅读这种“静默”交流方式，需要不同的经验和技巧。刚看完《如何阅读一本书》，感触比较多，总结一下。
</code></pre><p>读书太快或者太慢都会一无所获。要知道什么时候用什么速度阅读很重要。</p]]>
    </summary>
    
      <category term="阅读方法" scheme="http://vernonzheng.com/tags/%E9%98%85%E8%AF%BB%E6%96%B9%E6%B3%95/"/>
    
      <category term="读书笔记" scheme="http://vernonzheng.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="读书笔记" scheme="http://vernonzheng.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux常用命令小记]]></title>
    <link href="http://vernonzheng.com/2014/12/13/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/"/>
    <id>http://vernonzheng.com/2014/12/13/Linux常用命令小记/</id>
    <published>2014-12-13T07:13:47.000Z</published>
    <updated>2014-12-28T10:40:24.000Z</updated>
    <content type="html"><![CDATA[<pre><code>最近在翻《Linux命令行与<span class="keyword">shell</span>脚本编程大全》,整理了书中提到的常用的linux命令行。
</code></pre><h2 id="一、文件相关">一、文件相关</h2>
<ul>
<li><p><strong>链接文件</strong><br>cp -l test1 test4 创建硬链接（一个独立文件，引用了源文件，索引节点号是一样的，只适用同一个挂载点下的文件）<br>cp -s test1 test5 创建符号链接，软链接（一个独立文件，只存储源文件的信息，不存储源文件数据，索引节点显示为test5 -&gt; test1）<br>ln 链接文件（硬链接）<br>ln -s 链接文件（软链接）</p>
</li>
<li><p><strong>文件状态</strong><br>stat test10 查看文件统计信息，比ls更全<br>file test1 显示文件类型（3类，文本文件，可执行文件，数据文件）</p>
</li>
<li><p><strong>查看文件内容</strong><br>cat -n test1 查看整个文件，同时显示行号<br>more test1 查看整个文件，显示一页停下来，再向下翻页<br>less test1 more的升级版，不用全部加载文件<br>tail -n 100 -f 显示最后的100行，-f保持活动状态，有新内容就显示<br>head -n 100 -f 与tail类似，显示最开始的100行</p>
</li>
<li><p><strong>文件排序、过滤</strong><br>sort -n 排序文件数据行，-n表示把数字识别为数字，而不是字符，让它们按值排序<br>sort -t ‘:’ -k 3 -n /etc/passwd 其中-t表示指定字段的分隔符，-k指定排序的字段，最终完成按照用户ID进行数字排序<br>grep -e t -e f file1 过滤文件内容，筛选匹配行，其中-e表示多个匹配模式，满足其一就被筛选出来</p>
</li>
<li><p><strong>文件压缩、归档</strong><br>zip -r test.zip test 递归压缩目录<br>unzip test.zip 解压<br>tar -cvf test.tar test/ test2/ 创建含有test和test2目录的test.tar归档文件。<br>tar -tf test.tar 列出test.tar 内容，不解压<br>tar -xvf test.tar 解压<br>tar -zxvf test.tgz 解压gzip压缩过的tar文件</p>
</li>
</ul>
<h2 id="二、线程相关">二、线程相关</h2>
<ul>
<li><p><strong>监控性能</strong><br>top 实时监控进行，系统负载等</p>
</li>
<li><p><strong>线程消息</strong><br>kill -s 信号（线程传递信息，比如HUP（1）挂起，INT（2）终端，QUIT（3）结束运行，KILL（9）无条件终止）</p>
</li>
</ul>
<h2 id="三、账号相关">三、账号相关</h2>
<ul>
<li><strong>组与用户</strong><br>useradd -b default_home -g group sb<br>usermod 修改用户账户的字段，比如主要组以及附加组的所属关系<br>passwd username 修改密码<br>groupadd shared 创建shared新组（tail /etc/group查看结果）<br>usermod -G shared rich 增加shared组的成员，是-G，不是-g，-g会修改账户的默认组！<br>groupmod -n sharing shared 其中-n是修复已有组的组名 -g是修改GID<br>umask 777 —在/etc/profile 设置umask，即touch创建文件时候，默认给的权限<br>chmod o+r newfile (o表示权限设置跟其他用户一样，u表示权限设置为属主一样，g设置为属组一样，r读权限)<br>chown dan.shared newfile 改变文件的属主和属组</li>
</ul>
<h2 id="四、磁盘设备相关">四、磁盘设备相关</h2>
<ul>
<li><p><strong>设备</strong><br>mount -t vfat /dev/sdb1 media/disk 将u盘/dev/sdb1 挂载到/media/disk<br>mount /homr/rich/mnt 卸载</p>
</li>
<li><p><strong>磁盘</strong><br>df -h 显示设备的磁盘空间。<br>du -h 显示特定目录下磁盘使用情况。用来判断系统某个目录是否有超大文件的快速方式。</p>
</li>
</ul>
<hr>
<p>参考：<br>《Linux命令行与shell脚本编程大全》:<a href="http://book.douban.com/subject/11589828/" target="_blank" rel="external">http://book.douban.com/subject/11589828/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>最近在翻《Linux命令行与<span class="keyword">shell</span>脚本编程大全》,整理了书中提到的常用的linux命令行。
</code></pre><h2 id="一、文件相关">一、文件相关</h2>
<ul>
<li><p]]>
    </summary>
    
      <category term="linux" scheme="http://vernonzheng.com/tags/linux/"/>
    
      <category term="命令行" scheme="http://vernonzheng.com/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
      <category term="linux" scheme="http://vernonzheng.com/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java异常-《Robust Java 中文版》 笔记总结]]></title>
    <link href="http://vernonzheng.com/2014/12/10/Java%E5%BC%82%E5%B8%B8-%E3%80%8ARobust-Java-%E4%B8%AD%E6%96%87%E7%89%88%E3%80%8B%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/"/>
    <id>http://vernonzheng.com/2014/12/10/Java异常-《Robust-Java-中文版》笔记总结/</id>
    <published>2014-12-10T14:08:49.000Z</published>
    <updated>2015-01-21T06:33:23.000Z</updated>
    <content type="html"><![CDATA[<pre><code><span class="comment">Robust</span> <span class="comment">Java</span> <span class="comment">中文版</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">Java异常处理、测试与调试，这本书主要讲解了Java异常</span> <span class="comment">的原理及处理方法，系统地阐述了体系结构、设计、开发、测试和调试等主题，并讨论了如何构建健壮的系统。</span>
</code></pre><h2 id="一、异常基础">一、异常基础</h2>
<p>java异常的产生是代码处，异常会作为消息发送至应用程序的catch部分或者抛出。</p>
<p><strong>1.1 Throwable的内部关系</strong></p>
<p>异常的祖先是Throwable（可抛出），底下是Exception（异常）和Error（错误）<br>Exception异常：为“合理程序程序需要捕获的情况”，可预测，可恢复。<br>Error错误：合理应用程序不应试图捕获它，反常情况。</p>
<p><strong>1.2 可检测异常与非检测异常</strong></p>
<p><strong>区别</strong>：可检测异常经编译器验证，而非检测异常不需要。<br>主要的非检测异常：RuntimeException和Error。（对于RuntimeException，一般针对特定操作，请增加校验。）</p>
<p><strong>1.3 Trowable的属性</strong></p>
<p>Throwable 存储3个属性：</p>
<ul>
<li>message（消息）：String //描述性文本 读（只能在构造函数设置）</li>
<li>stack trace（栈跟踪）：StackTraceElement[] //引发异常的所有方法调用的记录 读-写</li>
<li>cause（原因）：Trowable //产生此异常的原因 读-写（只能设置一次） getCause和initCause获取和设置，或者构造函数设置</li>
</ul>
<p>除3个属性外，Throwable还包含toString和getLocalizedMessage 方法。<br>toString方法：覆盖Object类，返回异常名（对于非空消息字符串）。<br>getLocalizedMessge方法：返回消息字符串的值。</p>
<h2 id="二、异常的实践">二、异常的实践</h2>
<p><strong>2.1 处理还是声明异常</strong></p>
<p><strong>经验法则</strong>：尽可能去处理异常，如果没有能力处理就声明异常。<br>从本质上讲，仅当方法缺少自我处理异常的信息、上下文或资源时，才将异常信息传给调用者。</p>
<h2 id="三、异常高级特性">三、异常高级特性</h2>
<p><strong>3.1 链表异常</strong></p>
<p>就是异常允许设置两个异常之间的关联，称为链表异常。参考1.3里的cause属性。<br>设置方法有两种，作为构造函数参数传入，或者调用initCause(Throwable)方法设置，只能设置一次。</p>
<p>一般不常用，处理链表异常的方式可以参考如下：</p>
<blockquote>
<p>try{<br>    throublesomeObject.riskyMethod();<br>}catch(ChainedException exc){<br>    System.out.println(“We’re in trouble now!!!”);<br>    Throwable currentException = exc;<br>    do{<br>         System.out.println(currentException.toString());<br>         currentException = currentException.getCause();<br>    }while(currentException != null)<br>}</p>
</blockquote>
<p><strong>3.2 异常的本地化和国际化</strong></p>
<p>如果需要本地化异常相关文本，可在自定义异常中覆盖getLocalizedMessage(),以加载本地专用的异常信息。</p>
<p>java使用java.util和java.text包的类支持110n和i18n.java.util.resourceBundle和java.util.Locale是两个关键类。</p>
<p>实现步骤为：</p>
<ul>
<li>创建ResourceBundle子类来存储消息</li>
<li>为不同地区继承ResourceBundle类</li>
<li>创建覆盖getLocalizedMessage的自定义异常类并用ResourceBundle检索消息</li>
<li>具体大家自己查下吧，就不贴代码了。</li>
</ul>
<p><strong>3.3 不声明异常，声明异常，try-catch处理异常的性能比较</strong></p>
<p>有兴趣的可以自己写个测试类，javap -c -verbose一下。</p>
<p>可以看到：<br>声明异常和不声明的两个方法字节码相同，声明异常的抛出语句在类的方法查找表中声明。<br>而内部try-catch的方法，会增加一些如goto， astore等的字节码指令，以及一个与该方法相关的异常表（Exception table）。若产生异常，异常表控制代码路由。实际上行为与前两者类似。</p>
<p>那么这三者的性能比较会怎样？<strong>实际测试是区别不明显</strong>。</p>
<p>总结下<strong>最佳实践</strong>：<br>尽量避免抛出异常。<br>如果条件允许就处理异常。<br>如果条件不允许就声明异常。</p>
<h2 id="四、异常与多线程">四、异常与多线程</h2>
<p><strong>4.1 多线程与异常的关系</strong></p>
<p>看run方法签名，知道线程的异常都必须内部处理。<br>当run方法抛出非检测异常（RuntimeException或Error）时，负责该执行路径的Thread将终止，而其他线程无感知，理想情况下，多线程不抛出受检或非受检异常。</p>
<p><strong>关于dumpstack</strong>：</p>
<p>多线程程序中，每个线程都有自己的执行路径，也有自己的栈跟踪。要分析Thread的栈跟踪，调用Thread类的dumpStack方法，将其显示在标准错误流中（System.err)。<br>如果正常运行时执行该操作，显示Thread在其调用栈的当前位置。<br>如果产生异常，则显示标准异常栈跟踪。</p>
<p><strong>4.2 同步代码块中的异常</strong></p>
<p>比较正确的写法：除非保证不损坏同步块，决不抛出传到同步块意外的异常：</p>
<blockquote>
<p>try{<br>    synchronized(this){<br>    }<br>}catch(RuntimeException exc){</p>
<p>}</p>
</blockquote>
<h2 id="五、异常设计的最佳实践">五、异常设计的最佳实践</h2>
<ul>
<li>（1）在应用程序中，可根据潜在故障集来描述各个用例。可根据在运行程序中出现的可能性及严重程度，按层次定义这些故障。</li>
<li>（2）只解决对程序有重大影响且不可避免的问题和错误。</li>
<li>（3）方法只传递程序中需要广而告之的错误，或传递因为方法缺少上下文或资源而无法解决的错误。</li>
<li>（4）方法应根据使用者的角色和职责，以使用者可轻易理解的方式传递错误。</li>
<li>（5）方法仅在以下情况下抛出多个异常：<br>a.互相排斥（起因不同）<br>b.对使用者有不同作用<br>c.表示完全不同的故障</li>
<li>（6）在任何软件实体中（类、组件、系统、架构或API），异常都应称为实体合约（实体与外部的接口）的标准部分。</li>
</ul>
<h2 id="六、测试技术体系">六、测试技术体系</h2>
<p><strong>6.1 测试角色和职责</strong></p>
<ul>
<li>6.1.1 开发人员（TDD适合开发人员的单元测试，集成测试）<br>白盒：静态和动态测试，包括单元，集成，烟雾（smoke）和回归测试<br>体系结构：大多数测试形式，但有效性测试最好由用户来执行</li>
<li>6.1.2 测试人员<br>黑盒：大多数测试形式，特别是探索和基于风险的测试<br>系统结构：大多数测试形式</li>
<li>6.1.3 用户<br>黑盒：alpha，beta和用户满意度测试<br>体系结构：有效性测试</li>
</ul>
<h2 id="七、调试技术体系">七、调试技术体系</h2>
<p><strong>低级：code-resident技术</strong></p>
<ul>
<li>日志记录API</li>
<li>异常和错误</li>
<li>专用测试方法</li>
</ul>
<p><strong>中级：模式和架构技术</strong></p>
<ul>
<li>收集器（被动数据收集）</li>
<li>监控器（被动数据监控）</li>
<li>模仿器（主动被调用行为）</li>
<li>模拟器（主动调用行为）</li>
</ul>
<p><strong>高级：系统技术</strong></p>
<ul>
<li>体系结构测试方法和架构</li>
<li>基础结构收集方法</li>
<li>JPDA（java平台调试器体系结构）</li>
</ul>
<hr>
<p>参考：</p>
<ul>
<li>《Robust Java 中文版》:<a href="http://book.douban.com/subject/1681498/" target="_blank" rel="external">http://book.douban.com/subject/1681498/</a></li>
</ul>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code><span class="comment">Robust</span> <span class="comment">Java</span> <span class="comment">中文版</span><span class="literal">-</sp]]>
    </summary>
    
      <category term="读书笔记" scheme="http://vernonzheng.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://vernonzheng.com/tags/java/"/>
    
      <category term="java" scheme="http://vernonzheng.com/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux环境变量解疑]]></title>
    <link href="http://vernonzheng.com/2014/12/06/Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%A7%A3%E7%96%91/"/>
    <id>http://vernonzheng.com/2014/12/06/Linux环境变量解疑/</id>
    <published>2014-12-06T09:02:59.000Z</published>
    <updated>2014-12-28T10:40:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、什么是环境变量">一、什么是环境变量</h2>
<pre><code>bash <span class="keyword">shell</span>用一个称为环境变量的特性来存储有关<span class="keyword">shell</span>会话和工作环境的信息。
</code></pre><p>环境变量有两类：<strong>全局变量</strong>和<strong>局部变量</strong>。<br>局部变量可以在这个shell进程和子进程中起作用，另创建一个shell，就无效了。</p>
<p><strong>1.1 显示环境变量</strong></p>
<ul>
<li>显示全局变量：printenv</li>
<li>显示局部变量：set</li>
</ul>
<p><strong>1.2 设置环境变量</strong></p>
<ul>
<li>设置局部变量：通过等号来给环境变量赋值，如</li>
</ul>
<blockquote>
<p>$test=testing<br>$echo $test<br>testing<br>$</p>
</blockquote>
<ul>
<li>设置全局变量：通过将局部变量导出为全局变量的方式，如</li>
</ul>
<blockquote>
<p>$echo $test<br>testing a long string<br>$export test<br>$bash<br>$echo $test<br>testing a long string<br>$</p>
</blockquote>
<p><strong>1.3 删除环境变量</strong></p>
<ul>
<li>局部变量：unset test</li>
<li>全局变量：unset test 需要注意的是：如果你是在子进程中删除一个全局环境变量，它只对子进程失效。全局环境变量在父进程仍然有效。</li>
</ul>
<h2 id="二、系统环境变量">二、系统环境变量</h2>
<p>linux启动启动一个bash shell时，默认情况下bash在几个文件中查找命令。这些文件称为启动文件，<strong>根据bash shell启动方式的不同，查找文件不同</strong>。</p>
<p>bash shell有三种方式：</p>
<h3 id="2-1_登陆时当做默认登陆shell">2.1 登陆时当做默认登陆shell</h3>
<p>会依次查找一下路径：</p>
<ul>
<li>/etc/profile</li>
<li>$HOME/.bash_profile</li>
<li>$HOME/.bash_login</li>
<li>$HOME/.profile</li>
</ul>
<p><strong>/etc/profile</strong>文件是系统上默认的bash shell的主启动文件。每个用户登陆都会执行这个启动文件，另外3个启动文件是用户专有的，可根据用户定制。</p>
<h3 id="2-2_作为非登陆shell的交互式shell">2.2 作为非登陆shell的交互式shell</h3>
<p>如果你的bash shell不是登陆系统时启动的，称为交互式shell。</p>
<p>交互式shell不会去访问/etc/profile文件，而会去用户的HOME目录检查<strong>.bashrc</strong>是否存在。</p>
<p><strong>.bashrc文件的作用</strong>：<br>有两个作用：</p>
<ul>
<li>一是查看/etc目录下的公用bashrc文件</li>
<li>二是为用户提供一个定制自己的命令别名和私有脚本函数的地方。<br>（默认的文件会设置一些环境变量，但一般它没有执行export命令让它们称为全局的。）</li>
</ul>
<p>记住，交互式shell的启动文件只会在每次有新的交互式shell启动时才运行，因此任何子shell都会自动执行这个交互式shell的启动文件。</p>
<p>还能看出，/etc/bashrc文件也会执行位于/etc/profile.d 目录下的那些应用专属的启动文件。</p>
<h3 id="2-3_作为运行脚本的非交互shell">2.3 作为运行脚本的非交互shell</h3>
<p>系统执行shell脚本时用的就是这种shell。</p>
<p>当你每次在系统上运行脚本时需要运行特定的启动命令。为了处理这种情况，bash shell提供了BASH_ENV环境变量。</p>
<p>当shell启动一个非交互式shell进程时，它会检查这个环境变量来查看要执行的启动文件。如果有指定，shell会执行文件里的命令。<br>（在linux发行版里，默认情况下这个环境变量并未设置。）</p>
<hr>
<p>参考：</p>
<ul>
<li>《Linux命令行与shell脚本编程大全》:<a href="http://book.douban.com/subject/11589828/" target="_blank" rel="external">http://book.douban.com/subject/11589828/</a></li>
</ul>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一、什么是环境变量">一、什么是环境变量</h2>
<pre><code>bash <span class="keyword">shell</span>用一个称为环境变量的特性来存储有关<span class="keyword">shell</span>会话和工作]]>
    </summary>
    
      <category term="linux" scheme="http://vernonzheng.com/tags/linux/"/>
    
      <category term="环境变量" scheme="http://vernonzheng.com/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
      <category term="linux" scheme="http://vernonzheng.com/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://vernonzheng.com/2014/12/01/hello-world/"/>
    <id>http://vernonzheng.com/2014/12/01/hello-world/</id>
    <published>2014-12-01T07:13:47.000Z</published>
    <updated>2014-12-18T02:47:14.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">trobuleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2>
<h3 id="Create_a_new_post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io]]>
    </summary>
    
  </entry>
  
</feed>
