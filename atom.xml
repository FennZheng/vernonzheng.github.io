<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Vernon Zheng 郑雪峰]]></title>
  <subtitle><![CDATA[tech | life | thinking | note]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://vernonzheng.com/"/>
  <updated>2014-12-30T03:19:03.640Z</updated>
  <id>http://vernonzheng.com/</id>
  
  <author>
    <name><![CDATA[Vernon Zheng]]></name>
    <email><![CDATA[kevonzheng@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[2014年终小结与书单]]></title>
    <link href="http://vernonzheng.com/2014/12/28/2014%E5%B9%B4%E7%BB%88%E5%B0%8F%E7%BB%93%E4%B8%8E%E4%B9%A6%E5%8D%95/"/>
    <id>http://vernonzheng.com/2014/12/28/2014年终小结与书单/</id>
    <published>2014-12-28T08:36:23.000Z</published>
    <updated>2014-12-28T11:10:11.000Z</updated>
    <content type="html"><![CDATA[<pre><code>年初觉得可能发生的事情，大多数都发生了。
</code></pre><h2 id="一、2014小结">一、2014小结</h2>
<p>去了青岛，舟山，上海，路过香港，台湾12天环岛。（台湾之行，加大我对环球游梦的‘执念’）</p>
<p>11月份，根据地从杭州搬到了北京。（搬家是件痛苦的事情，特别是书都得处理掉，好处是杂乱的东西都可以丢了）</p>
<p>工作换了两家，经历了一些波折，11月连续两周的面试，第一次体会了面霸的感觉，这也是大北京的优势，公司多。离年初和同学戏称的30岁金钱目标，意外的跨了一大步，同时又觉得路程还很远，养成习惯和身体健康的重要性。</p>
<p>学习方面，英语没有任何质变。。唯一欣慰的是今年读了39本书。</p>
<p>附：<br>我的足迹：<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/2014_year_foot_print" alt="2014_foot_print"></p>
<h2 id="二、2015目标">二、2015目标</h2>
<p>既然是总结，就不得不写一些2015的目标。</p>
<ul>
<li>英语：为了环球游的‘执念’，蹩脚的英语得加把劲了，每天90分钟的听说练习，至少日常口语没问题，流利的聊天更好。</li>
<li>刷书，积累：技术类30本，其他类20本，英语原版书3本以上。</li>
<li>坚持锻炼：养成每天早上起床锻炼的习惯，《囚徒健身》。</li>
<li>旅行：精神和身体都得奔跑在路上。既然base在北京，周边几个省的旅游机会别浪费了。</li>
<li>职业：写的像招聘信息。。熟练掌握scala，nodejs，仔细阅读kafka，nignx源码，了解下大数据处理相关（spark，hadoop），分析问题能追到c实现，能写点基于unix的偏底层的网络程序，用scala写一些中间件。技能水平，从应用级别高级开发到类库框架级别的高级开发吧。</li>
</ul>
<h2 id="三、2014书单">三、2014书单</h2>
<p>我的2014书单，书封面就不贴了，可以参考我的豆瓣读书：<a href="http://book.douban.com/people/vernonzheng/" target="_blank" rel="external">http://book.douban.com/people/vernonzheng/</a></p>
<h3 id="3-1_IT技术类">3.1 IT技术类</h3>
<ul>
<li><p>《深入理解Java虚拟机：JVM高级特性与最佳实践》<br>周志明<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/深入理解Java虚拟机.jpg" alt="深入理解Java虚拟机"><br>5星，非常推荐。</p>
</li>
<li><p>《Java并发编程实践》<br>Brian Goetz、Tim Peierls、Joshua Bloch、Joseph Bowbeer、David Holmes、Doug Lea / 童云兰<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/Java并发编程实战.jpg" alt="Java并发编程实践"><br>5星，非常推荐，有点理论程度的。</p>
</li>
<li><p>《高性能MySQL》<br>Baron Schwartz、Peter Zaitsev、Vadim Tkachenko、Jeremy D.Zawodny、Arjen Lent、Derek J.Ballin / 王小东、李军、康建勋<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/高性能MySQL.jpg" alt="高性能MySQL"><br>5星，非常推荐，特别是4，5，6章的索引，查询优化等等讲的很透彻。</p>
</li>
<li><p>《领域特定语言》<br>Martin Fowler / ThoughtWorks中国<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/领域特定语言.jpg" alt="领域特定语言"><br>5星，Martin难得出那么厚的书，写的很好，只看了前几章理论部分，后面的实用性挺高。</p>
</li>
<li><p>《设计模式：可复用面向对象软件的基础》<br>GOF<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/设计模式 - 可复用面向对象软件的基础.jpg" alt="设计模式"><br>5星，不是很推荐，惜字如金，有点难度，以后还得翻。</p>
</li>
<li><p>《点石成金：访客至上的网页设计秘笈》<br>[美] 史蒂夫·克鲁克 / De Dream’<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/点石成金.jpg" alt="点石成金"><br>5星，推荐，英文名是Don’t make me think，特点是很薄，147页。</p>
</li>
<li><p>《大型网站系统与Java中间件开发实践》<br>曾宪杰<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/大型网站系统与Java中间件开发实践.jpg" alt="大型网站系统与Java中间件开发实践"><br>5星，没有特别高深的概念，能学会解决这类问题的思路，结合非常实际的案例在讲。</p>
</li>
<li><p>《人月神话》<br>弗雷德里克.布鲁克斯 / UMLChina翻译组、汪颖<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/人月神话.jpg" alt="人月神话"><br>4星，多少年前的书，却相当经典。</p>
</li>
<li><p>《MySQL技术内幕：SQL编程》<br>姜承尧<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/MySQL技术内幕 - SQL编程.jpg" alt="MySQL技术内幕：SQL编程"><br>4星，对于有一些数据库设计开发经验的人，有许多技巧性和细节性的建议和提高。</p>
</li>
<li><p>《测试驱动开发：实战与模式解析》<br>Kent Beck / 白云鹏<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/测试驱动开发.jpg" alt="测试驱动开发"><br>4星，翻译不太好，kent beck的书实在少，只能看个经典旧书了。</p>
</li>
<li><p>《The Little Book on CoffeeScript》<br>Alex MacCaw<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/The Little Book on CoffeeScript.jpg" alt="The Little Book on CoffeeScript"><br>4星，实用，简短，快速上手。</p>
</li>
<li><p>《Node.js实战》<br>[美] Mike Cantelon、[美] TJ Holowaychuk、[美] Nathan Rajlich<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/node.js 实战.jpg" alt="Node.js实战"><br>4星，有些翻译问题，适合做nodejs的前两本入门书。</p>
</li>
<li><p>《Spring实战》<br>沃尔斯 (Craig Walls) / 耿渊、张卫滨<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/Spring实战.jpg" alt="Spring实战"><br>4星，过一下基础。</p>
</li>
<li><p>《Maven实战》<br>许晓斌<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/Maven实战.jpg" alt="Maven实战"><br>4星，内容比较全，稍微有点拖沓。</p>
</li>
<li><p>《Robust Java中文版：Java异常处理、测试与调试》<br>史德汀<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/Robust Java 中文版 - Java异常处理、测试与调试.jpg" alt="Robust Java中文版"><br>3星，介绍了java异常的体系结构，设计，开发，测试，架构，比较基础和全面。</p>
</li>
<li><p>《Java 7 Concurrency Cookbook》<br>Fernandez Javier / Packt Publishing<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/Java 7 Concurrency Cookbook.jpg" alt="Java 7 Concurrency Cookbook"><br>3星，就当查漏补缺了。</p>
</li>
<li><p>《Netty权威指南》<br>李林峰<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/Netty权威指南.jpg" alt="Netty权威指南"><br>3星，作者没有用心写感觉。。</p>
</li>
</ul>
<h3 id="3-2_IT非技术类">3.2 IT非技术类</h3>
<ul>
<li><p>《重来》<br>[美] 贾森·弗里德、[丹] 戴维·海涅迈尔·汉森 / 李瑜偲<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/重来.jpg" alt="重来"><br>5星，推荐，设计商业，创业，软件设计，需求，技术等，触发思考的内容远超一个创业书的范围。</p>
</li>
<li><p>《黑客与画家》<br>[美] Paul Graham / 阮一峰<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/黑客与画家.jpg" alt="黑客与画家"><br>5星，硅谷创业之父Paul Graham文集，黑客精神，创业，lisp等。</p>
</li>
<li><p>《暗时间》<br>刘未鹏<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/暗时间.jpg" alt="暗时间"><br>5星，知识密度相当大</p>
</li>
<li><p>《MacTalk 人生元编程》<br>池建强<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/MacTalk 人生元编程.jpg" alt="MacTalk 人生元编程"><br>3星，如果你喜欢编程的乐趣和mac相关内容，可以翻一翻。</p>
</li>
<li><p>《软件架构师的12项修炼》<br>Dave Hendricksen / 张菲<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/软件架构师的12项修炼.jpg" alt="软件架构师的12项修炼"><br>2星，讲的太泛了，没啥实用性</p>
</li>
</ul>
<h3 id="3-3_其他杂类">3.3 其他杂类</h3>
<ul>
<li><p>《人间词话》<br>王国维<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/人间词话.jpg" alt="人间词话"><br>5星，有一半是对古人词的赏析，之外对于境界的理解部分收获很多。</p>
</li>
<li><p>《正见：佛陀的证悟》<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/正见.jpg" alt="正见"><br>宗萨蒋扬钦哲仁波切 / 姚仁喜<br>5星，有兴趣的人可以看看，讲佛家四见地的。因为书中“佛陀看一个人，是看到他的圆熟和衰朽同时在发生。”这句话，去看了这本书。</p>
</li>
<li><p>《囚徒健身》<br>保罗·威德<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/囚徒健身.jpg" alt="囚徒健身"><br>5星，简单，实用。</p>
</li>
<li><p>《少有人走过的路：心智成熟的旅程》<br>[美] M·斯科特·派克 / 于海生<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/少有人走的路 - 心智成熟的旅程.jpg" alt="少有人走过的路：心智成熟的旅程"><br>5星，推荐前半部分</p>
</li>
<li><p>《撒哈拉的故事》<br>三毛<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/撒哈拉的故事.jpg" alt="撒哈拉的故事"><br>5星，echo作品里最喜欢的一本。她的文字和独特壮阔的生活方式，有一种特别的魅力，无论是孤独还是爱的追寻，真实＆真挚的让人感动。</p>
</li>
<li><p>《穷游锦囊：骑行台湾》<br>穷游网<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/穷游锦囊：骑行台湾.jpg" alt="穷游锦囊"><br>5星，穷游系列的书都很不错。台湾环岛攻略就靠这个系列。</p>
</li>
<li><p>《如何阅读一本书》<br>[美] 莫提默·J. 艾德勒、查尔斯·范多伦 / 郝明义、朱衣<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/如何阅读一本书.jpg" alt="如何阅读一本书"><br>4星，推荐，多读书，多总结适合自己的方式。</p>
</li>
<li><p>《女人的性爱动机》<br>【美】辛迪•梅斯顿、【美】戴维•巴斯 / 海兰、插画师：顾爷<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/女人的性爱动机.jpg" alt="女人的性爱动机"><br>4星，生理和心理角度看待问题，前几章不错。</p>
</li>
<li><p>《我所理解的生活》<br>韩寒<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/我所理解的生活.jpg" alt="我所理解的生活"><br>4星，多年没读韩寒，变化挺大。</p>
</li>
<li><p>《天才在左，疯子在右》<br>高铭<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/天才在左 疯子在右.jpg" alt="天才在左，疯子在右"><br>4星，国内第一本精神病人访谈手记，你可以把它当做故事书，很有趣。</p>
</li>
<li><p>《慢慢来，一切都来得及》<br>meiya<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/慢慢来.一切都来得及.jpg" alt="慢慢来，一切都来得及"><br>4星，被打动的一本书，讲述奋斗路上作者的生命体验。</p>
</li>
<li><p>《魔鬼约会学》<br>魔鬼咨询师<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/魔鬼约会学.jpg" alt="魔鬼约会学"><br>4星，男女思考行为的差距，还有一些活泼的例子。</p>
</li>
<li><p>《5分钟和陌生人成为朋友-101个瞬间化解尴尬的沟通技巧-II : 101个瞬间化解尴尬的沟通技巧》<br>唐·加博尔 / 何云<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/5分钟和陌生人成为朋友-101个瞬间化解尴尬的沟通技巧-II - 101个瞬间化解尴尬的沟通技巧.jpg" alt="5分钟和陌生人成为朋友"><br>3星，例子比较实用，先有心，后有术。</p>
</li>
<li><p>《二十五岁的世界：我在25座城市，遇见的25个人》<br>(西)马克•塞雷纳 / 吴娴敏<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/二十五岁的世界.jpg" alt="二十五岁的世界"><br>3星，印度，菲利宾，津巴布韦到日本寺庙。。有许多细节被震撼到。</p>
</li>
<li><p>《我是个算命先生》<br>易之<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/我是个算命先生.jpg" alt="我是个算命先生"><br>3星，amazon上卖的很火，但是和盗墓笔记比差太多，是纯小说。</p>
</li>
<li><p>《潜伏职场心理学》<br>张超<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/职场潜伏心理学.jpg" alt="潜伏职场心理学"><br>3星，茶语饭后翻一番，还是有收获的。</p>
</li>
<li><p>《软件架构师的12项修炼》<br>Dave Hendricksen / 张菲<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/软件架构师的12项修炼.jpg" alt="软件架构师的12项修炼"><br>2星，讲的太泛了，没啥实用性</p>
</li>
</ul>
<p>完。</p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>年初觉得可能发生的事情，大多数都发生了。
</code></pre><h2 id="一、2014小结">一、2014小结</h2>
<p>去了青岛，舟山，上海，路过香港，台湾12天环岛。（台湾之行，加大我对环球游梦的‘执念’）</p>
<p>11月份，根据地]]>
    </summary>
    
      <category term="日记" scheme="http://vernonzheng.com/tags/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="书单" scheme="http://vernonzheng.com/tags/%E4%B9%A6%E5%8D%95/"/>
    
      <category term="日记" scheme="http://vernonzheng.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NodeJS实战经验总结]]></title>
    <link href="http://vernonzheng.com/2014/12/28/NodeJS%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <id>http://vernonzheng.com/2014/12/28/NodeJS实战经验总结/</id>
    <published>2014-12-28T05:07:57.000Z</published>
    <updated>2014-12-29T01:17:18.000Z</updated>
    <content type="html"><![CDATA[<pre><code>看完《Node.js 实战》，整理总结了觉得比较有价值的内容。
</code></pre><h2 id="1、require">1、require</h2>
<p>require是少有的同步i/o操作，请只在模块初始化时候使用require。</p>
<h2 id="2、exports与module-exports的区别">2、exports与module.exports的区别</h2>
<p>最终程序里导出的都是module.exports。<br>而exports只是对module.exports的一个<strong>全局引用</strong>，如exports.myFunc为module.exports.myFunc的简写。<br>为了不破坏exports对module.exports的引用，不能设置exports。<br>如果破坏了，修复方式：<br>module.exports = exports = Currency;</p>
<h2 id="3、模块缓存与猴子补丁：">3、模块缓存与猴子补丁：</h2>
<p>Node 能把模块作为对象缓存起来。<br>如果程序中的两个文件引入了相同的模块，第一个文件会把模块返回的数据存到程序的内存中，这样第二个文件就不用再去访问和计算模块的源文件了。<br>实际上在第二个引入是有机会修改缓存数据的。这种方式称为“猴子补丁”（monkey patching ）：让一个模块可以改变另一个模块的行为，开发人员可以不用创建它的新版本。</p>
<h2 id="4、Node两种常用的响应逻辑组织方式">4、Node两种常用的响应逻辑组织方式</h2>
<p><strong>一次性为回调函数，绑定的为事件</strong>（继承event emitter事件发射器，emit发射消息）</p>
<p>这里给个event emitter的例子：</p>
<p>扩展文件监视器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**Watcher构造器**/</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Watch</span><span class="params">(watchDir, processDir)</span></span>{</div><div class="line">	<span class="keyword">this</span>.watchDir = watchDir;</div><div class="line">	<span class="keyword">this</span>.processedDir = processDir;</div><div class="line">}</div><div class="line"><span class="comment">/**继承eventEmitter行为**/</span></div><div class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(‘events’);</div><div class="line">util = reuqire(‘util’);</div><div class="line">util = util.inherits(Watcher, event.EventEmitter);</div><div class="line"></div><div class="line"><span class="comment">/**相当于Watcher.prototype = new events.EventEmitter();**/</span></div><div class="line"></div><div class="line"><span class="comment">/**再增加两个功能**/</span></div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(‘fs’)</div><div class="line">, watchDir = ‘./watch’</div><div class="line">, processedDir = ‘./done’</div><div class="line"></div><div class="line">Watcher.prototype.watch = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">	<span class="keyword">var</span> watcher = <span class="keyword">this</span>;</div><div class="line">	fs.readdir(<span class="keyword">this</span>.watchDir, <span class="function"><span class="keyword">function</span><span class="params">(err, files)</span></span>{</div><div class="line">		<span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</div><div class="line">		<span class="keyword">for</span>( <span class="keyword">var</span> index <span class="keyword">in</span> files){</div><div class="line">			watcher.emit(‘process’, files[index]);</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div><div class="line">Watcher.prototype.start = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">	<span class="keyword">var</span> watcher = <span class="keyword">this</span>;</div><div class="line">	fs.watchFile(watchDir, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">		watcher.watch();</div><div class="line">	});</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="5、减少if/else引起的回调嵌套">5、减少if/else引起的回调嵌套</h2>
<p>有两种方式，可以结合到一起用：</p>
<ul>
<li>（1）嵌套间引入中间函数，通过函数调用拆分嵌套</li>
<li>（2）尽早从函数中返回</li>
</ul>
<h2 id="6、Node的异步回调惯例">6、Node的异步回调惯例</h2>
<p>Node大多数内置模块使用回调会带两个参数，一个是err或者er，一个是存放结果。</p>
<h2 id="7、进程退出会等待事件异步完成">7、进程退出会等待事件异步完成</h2>
<p>Node的事件轮询会跟踪还没有完成的异步逻辑，只要有未完成的异步逻辑，Node进程就不会退出。事件轮询会跟踪所有数据库连接，知道它们关闭，以防止Node退出。</p>
<h2 id="8、在Node中使用闭包保留全局变量示例">8、在Node中使用闭包保留全局变量示例</h2>
<p>示例，用闭包私有化color值：<br>这里有一个asyncFunction函数，对它的调用被封装到一个匿名函数里，参数为color。<br>这样你就可以马上执行这个匿名函数，把当前的 color 的值传给它。而color 变成了匿名函数内部的本地变量，当 匿名函数外面的color 值发生变化时，本地版的color 不会受影响。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunction</span><span class="params">(callback)</span></span>{</div><div class="line">     setTimeout(callback, <span class="number">200</span>);</div><div class="line">}</div><div class="line"><span class="keyword">var</span> color = ‘blue’;</div><div class="line">(<span class="function"><span class="keyword">function</span><span class="params">(color)</span></span>{</div><div class="line">     asyncFunction(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">         <span class="built_in">console</span>.log(’The color is ‘ + color);</div><div class="line">     })(color);</div><div class="line">color = ‘green’;</div></pre></td></tr></table></figure>

<h2 id="9、Node的content-length与chunk">9、Node的content-length与chunk</h2>
<p>Node默认是chunk方式传输（块编码）。当设置content-length时，会隐含禁用Node的块编码。设置content-length传输，数据更少，提升性能。</p>
<p><strong>注意</strong>：<br>content-length是字节长度，不是字符长度，一般用Buffer.byteLength(body)</p>
<h2 id="10、__dirname">10、__dirname</h2>
<p>__dirname表示文件所在目录的路径，在开发时，这个目录和当前工作目录（CWD）是同个目录，但是生产环境可能是从另外一个目录运行。</p>
<h2 id="11、中间件设计惯例">11、中间件设计惯例</h2>
<p>中间件一般有三个参数：请求，响应，回调函数next<br>为了提供可配置能力，中间件遵循一个惯例：用函数返回另一个函数（闭包）</p>
<p>可配置中间件的<strong>基本结构</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setup</span><span class="params">(options)</span></span>{</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(req,res,next)</span></span>{</div><div class="line">	<span class="comment">//中间件逻辑</span></div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.use(setup({some:’options’}))</div></pre></td></tr></table></figure>

<h2 id="12、错误处理中间件">12、错误处理中间件</h2>
<p>错误处理中间件与普通中间三个参数不同，多了第一个参数err，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">errorHandler</span><span class="params">()</span></span>{</div><div class="line">	<span class="keyword">var</span> env = process.env.NODE_ENV || ‘development’;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(err, req, res, next)</span></span>{</div><div class="line">		res.statusCode = <span class="number">500</span>;</div><div class="line">		<span class="keyword">switch</span>(env){</div><div class="line">		<span class="keyword">case</span> ‘development’:</div><div class="line">			res.setHeader(‘content-type’, ‘application/json’);</div><div class="line">			res.end(<span class="built_in">JSON</span>.stringify(err));</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			res.end(’Server error’);</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>当Connect遇到错误，它会跳过后续的中间件，只调用错误处理中间件。</strong></p>
<p>在使用connect时，错误处理有三种方式：</p>
<ul>
<li>（1）使用Connect 默认的错误处理器；</li>
<li>（2）自己处理程序错误；</li>
<li>（3）使用多个错误处理中间件组件。</li>
</ul>
<p>第三种给个示例：<br>多个错误处理器的实现：<br>api挂载在/api上：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> api = connect()</div><div class="line">	.use(users)</div><div class="line">	.use(pets)</div><div class="line">	.use(errorHandler);</div><div class="line"></div><div class="line"><span class="keyword">var</span> app = connec()</div><div class="line">	.use(hello)</div><div class="line">	.use(<span class="string">'/api'</span>, api)</div><div class="line">	.use(errorPage)</div><div class="line">	.listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure>

<p><img src="http://7te9ul.com1.z0.glb.clouddn.com/nodejs_in_action_duplicate_error_handle.png" alt="connect_dumplicate_error"><br>其中errorHandler处理来自api的所有错误，error处理来自app的所有错误。</p>
<h2 id="13、connect中间件">13、connect中间件</h2>
<p>包括：</p>
<ul>
<li>（1）cookieParser：为后续中间件提供req.cookies和req.signedCookies，<br>设置cookie这样用：res.setHeader(’Set-Cookie’,’’)</li>
<li>（2）bodyParser：为后续中间件提供req.body和req.files</li>
<li>（3）limit：基于给定字节长度限制请求主体的大小。必须用在bodyParser中间件之前，防止攻击。<br>更灵活的使用：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">app.use(type(‘application/x-www-form-urlencoded’, connect.limit(‘<span class="number">64</span>kb’))</div><div class="line">app.use(type(‘appication/json’, connect.limit(‘<span class="number">32</span>kb’)))</div></pre></td></tr></table></figure>

<ul>
<li>（4）query：为后续中间件提供req.query</li>
<li>（5）logger：将http请求的信息输出到stdout或日志文件之类的流中</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.user(connect.logger(‘dev’))</div></pre></td></tr></table></figure>

<p>输出有颜色区分的日志，便于开发调试<br><strong>两种输出日志频率</strong><br>immediate，表示一收到请求，就写日志。<br>buffer，以毫秒为单位，指定缓冲区刷新的时间间隔。</p>
<ul>
<li>（6）favicon：响应/favicon.ico http请求。通常放在中间件logger前面，这样它就不会出现在你的日志中了</li>
<li>（7）methodOverride：可以替不能使用正确请求方法的浏览器仿造req.method,依赖于bodyParser</li>
<li>（8）vhost：根据制定的主机名（如nodejs.org)使用给定的中间件和http服务器实例<br>可以做反向代理，缺点：一个网站崩溃，他的所有网站都会崩溃，一个都在同一个进程</li>
<li>（9）session：为用户设置一个http回话，并提供一个可以跨域请求的持久化req.session对象，依赖于cookieParser</li>
<li>（10）basicAuth：为程序提供http基础认证</li>
<li>（11）csrf：防止http表单中的跨站请求仿造攻击，依赖于session</li>
<li>（12）errorHandler：当出现错误时把堆栈跟踪信息返回给客户端。在开发时使用，不要在生产环境中使用</li>
<li>（13）static：把制定目录中的文件发给http客户端，跟connect的挂在功能配合得很好<br>返回./public目录下的静态资源文件：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.use(connect.static(‘public’));</div></pre></td></tr></table></figure>

<p>默认请求/js/test.js，会去.public/js/test.js去查找。<br>使用带挂载的static</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.use(‘/app/files’, connect.static(‘public’));</div></pre></td></tr></table></figure>

<ul>
<li>（14）compress：用gzip压缩优化http响应</li>
<li>（15）directory：为http客户端提供目录清单服务，基于客户端的accept请求（普通文件，son或html）提供经过优化的结果</li>
</ul>
<h2 id="14、_Express中两种渲染视图方式">14、 Express中两种渲染视图方式</h2>
<ul>
<li>（1）在程序中使用app.render（）</li>
<li>（2）在请求或者响应层用res.render()</li>
</ul>
<h3 id="14-1_视图的查找设置">14.1 视图的查找设置</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.set(‘views’,__dirname+’/views’);</div></pre></td></tr></table></figure>

<h3 id="14-2_设置模板引擎">14.2 设置模板引擎</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">app.set(‘view engine’, ‘jade’);</div><div class="line">app.get(‘/‘, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">     <span class="comment">/**假定为.jade**/</span>    </div><div class="line">     res.render(‘index’);</div><div class="line">});</div><div class="line">app.get(‘/feed’, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">     <span class="comment">/**因为扩展名为.ejs,所以使用EJS**/</span></div><div class="line">     res.render(‘rss.ejs’);</div><div class="line">});</div></pre></td></tr></table></figure>

<h3 id="14-3_视图缓存">14.3 视图缓存</h3>
<p>默认会开启view cache，模板修改，需要重启生效。</p>
<h3 id="14-4_视图查找">14.4 视图查找</h3>
<p>如photos为复数，暗示是一个资源列表。<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/blognodejs_in_action_express_view_search.png" alt="express_search"></p>
<h2 id="15、单元测试与验收测试">15、单元测试与验收测试</h2>
<p>有两种形态：测试驱动（TDD）和行为驱动开发（BDD）</p>
<ul>
<li>单元测试有Node的assert，Mocha，node unit，Vows以及should.js框架</li>
<li>验收测试，Tobi和Soda框架。<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/nodejs_in_action_test_soda.png" alt="test-modules-summary"></li>
</ul>
<h3 id="15-1_nodeunit：">15.1 nodeunit：</h3>
<p>例子：创建一个目录，每个测试脚本都应该用测试组装exports对象，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">exports.testPony = <span class="function"><span class="keyword">function</span><span class="params">(test)</span></span>{</div><div class="line">     <span class="keyword">var</span> isPony = <span class="literal">true</span>;</div><div class="line">     test.ok(isPony, ’This is not a pony.’);</div><div class="line">     test.done();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>nodeunit会自动给传入它的对象中引入assert模块。<br>nodeunit提供test.epect验证断言执行数量是否符合预期。</p>
<h3 id="15-2_mocha">15.2 mocha</h3>
<p>只支持串行测试，默认2s的timeout，并行请用vows：<br>BDD风格：describe,it,before,after,beforeEach,afterEach.<br>TDD风格：suite，test，setup，teardown替换上述</p>
<p>执行mocha，会执行./test目录下的javascript文件。</p>
<ul>
<li><strong>BDD风格</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> memdb = <span class="built_in">require</span>(‘..’);</div><div class="line"><span class="keyword">var</span> assert = <span class="built_in">require</span>(‘assert’);</div><div class="line"></div><div class="line">describe(‘memdb’, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">     describe(‘.save(doc)’, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">         it(’should save the documment’, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">              <span class="keyword">var</span> pey = { name: ’Tobi’ );</div><div class="line">               memdb.save(pet);</div><div class="line">               <span class="keyword">var</span> ret = memdb.first({ name: ’Tobi’ });</div><div class="line">               assert(ret == pet);</div><div class="line">          }</div><div class="line">     )</div><div class="line">)</div></pre></td></tr></table></figure>

<ul>
<li><strong>TDD风格</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = {</div><div class="line">     ‘memdb’ : {</div><div class="line">          ‘.save(doc)’ : {</div><div class="line">               ’should save the <span class="built_in">document</span>’ : <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">               }</div><div class="line">           }</div><div class="line">       }</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li><strong>测试异步</strong><br>增加done（）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">describe(‘.save(doc)’, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">     it(’should save the <span class="built_in">document</span>’, <span class="function"><span class="keyword">function</span><span class="params">(done)</span></span>{</div><div class="line">         <span class="keyword">var</span> pey = { name: ’Tobi’};</div><div class="line">          memdb.save(pet, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">              <span class="keyword">var</span> ret = memdb.first({ name: ’Tobi’ });</div><div class="line">               assert(ret == pet);</div><div class="line">               done();</div><div class="line">          }</div><div class="line">     }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="15-3_vows">15.3 vows</h3>
<p>支持并行测试</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> vows = <span class="built_in">require</span>(‘vows’);</div><div class="line"><span class="keyword">var</span> assert = <span class="built_in">require</span>(‘assert’);</div><div class="line"><span class="keyword">var</span> Todo = <span class="built_in">require</span>(‘./todo’);</div><div class="line"></div><div class="line">vows.describe(’Todo’).addBatch({</div><div class="line">     ‘when adding an item’:{</div><div class="line">          topic: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">               <span class="keyword">var</span> todo = <span class="keyword">new</span> Todo();</div><div class="line">               todo.add(‘Feed my cat’);</div><div class="line">               <span class="keyword">return</span> todo;</div><div class="line">          }</div><div class="line">     },</div><div class="line">     ‘it should exit <span class="keyword">in</span> my todos’: <span class="function"><span class="keyword">function</span><span class="params">(er, todo)</span></span>{</div><div class="line">         assert.equal(todo.getCount(), <span class="number">1</span>);</div><div class="line">     }</div><div class="line">}).run();</div></pre></td></tr></table></figure>

<p>如果你想把这段代码放到测试文件夹下，放在可以由Vows测试运行期运行，<br>run.()改成export(module);<br>然后<br>vows test/*</p>
<h3 id="15-4_should-js">15.4 should.js</h3>
<p>断言库，它有一个Object .prototype属性：可以写表达能力很强的断言。</p>
<h3 id="15-5_Tobi和Soda">15.5 Tobi和Soda</h3>
<p>Tobi模拟浏览器测试，可以结合should.js<br>Soda远程控制真实的浏览器：<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/blognodejs_in_action_test_soda.png" alt="test_tobi"></p>
<h2 id="16、使用EJS过滤器处理模板数据">16、使用EJS过滤器处理模板数据</h2>
<p><strong>格式</strong></p>
<p>&lt;%=:用在转义的EJS输出上的过滤器<br>&lt;%-:用在非转义的EJS输出上的过滤器</p>
<p>例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var ejs = require(‘ejs’);</div><div class="line">var template = ‘&lt;%=: movies | sort | first %&gt;’;</div><div class="line">var context = {‘movies’: [</div><div class="line">     ‘Bambi’,</div><div class="line">     ‘Babe: Pig in the city’,</div><div class="line">     ‘Enter the Void'</div><div class="line">]};</div></pre></td></tr></table></figure>

<p>看来上就是linux的管道符处理，</p>
<p><strong>各种常用处理</strong></p>
<ul>
<li>（1）处理选择：last，first，get:N</li>
<li>（2）处理大小写：capitalize把第一个字母变大写，还有upcase，downcase</li>
<li>（3）处理文本：把文本截成一定数量的单词truncate:20,替换replace:’A’,’B’,<br>排序sort，sort_by:’name’，其中sort返回的是对象，要返回属性的话：|get:’name’</li>
<li>（4）map：不用sort_by，再get。直接用map创建一个包含对象属性的数组，<br>map ’name’| sort|</li>
</ul>
<p>其他模板引擎：<br>Hotgan：实现mustache语法。<br>Jade：特点是空格的作用，缩进表示HTML的嵌入关系。</p>
<h2 id="17、fs-watchfile()与fs-watch()">17、fs.watchfile()与fs.watch()</h2>
<p>fs.watchfile()与fs.watch()是 Node.js中的两个监测文件API。</p>
<ul>
<li>比较老的是fs.watchFile,使用轮询的方式检查文件，不断的stat()，比较mtime时间戳.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(‘fs’);</div><div class="line">fs.watchFile(‘/<span class="keyword">var</span>/log/system.log’, <span class="function"><span class="keyword">function</span><span class="params">(curr, prev)</span></span>{</div><div class="line">     <span class="keyword">if</span>(cur.mtime.getTime() !== prev.mtime.getTime()){</div><div class="line">          <span class="built_in">console</span>.log(‘“System.log” has been modified’);</div><div class="line">     }</div><div class="line">});</div></pre></td></tr></table></figure>

<ul>
<li>新的api是fs.watch()，根据平台本地的文件修改通知API监测文件，性能更优，但是不如watchFile可靠。在OSX监测目录不会报告参数filename，其他见： 档<a href="http://nodejs.org/api/fs.html#fs_caveats" target="_blank" rel="external">http://nodejs.org/api/fs.html#fs_caveats</a></li>
</ul>
<h2 id="18、Process模块">18、Process模块</h2>
<ul>
<li>process.argv 存储了Node运行当前脚本时传入的参数</li>
<li>process.env 获取或设定环境变量</li>
<li>process不是eventEmitter实例，却可以发出exit和uncaughtException事件</li>
</ul>
<p><strong>注意点：</strong><br>其中exit是在事件循环（event loop）停止之后才激发的，所以你没有机会在exit事件启动任何异步任务。</p>
<h3 id="18-1_Process的信号处理">18.1 Process的信号处理</h3>
<p>UINX有信号的概念，是进程间通信（IPC）的基础形式，它是一组固定的名称，不能传递参数。</p>
<p><strong>信号举例如下</strong></p>
<ul>
<li>SIGUSR1：Node进入它内置的调试器</li>
<li>SIGWINCH：调试终端大小，由shell发送</li>
<li>SIGINT:ctrl+c，由shell发送，Node默认行为是杀死进程。如果你希望在杀掉服务器前，完成所有连接的处理，可以</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">process.on(’SIGINT’, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">     <span class="built_in">console</span>.log(‘Got Ctrl-C!’);</div><div class="line">     server.close();</div><div class="line">});</div></pre></td></tr></table></figure>

<ul>
<li>还有SIGUSR2和SIGKILL等等</li>
</ul>
<h2 id="19、子进程">19、子进程</h2>
<p>在NODE中创建子进程三种</p>
<ul>
<li>高层api，exec：在回调中创建命令并缓存结果的高层api。</li>
<li>底层api，spawn：将单例命令创建Child-Process对象中的底层API。</li>
<li>内置的特殊IPC通道fork：用内置的IPC通道创建额外Node进程的特殊方法。</li>
</ul>
<p><strong>三者比较</strong></p>
<ul>
<li><p>cp.exec()：只关心结果，不用从子进程的stdio流中访问数据（IRC协议模块有很多，irc，irc-js等等），结果需要转义，可以用execFile（）</p>
</li>
<li><p>cp.spawn()：返回一个可以交互的ChildProcess对象，允许你跟每个子进程的stdio流交互。（node-cgi范例模块）</p>
</li>
<li><p>cp.fork()：也返回一个ChildProcess对象，区别是这个API是用IPC通道添加的， 子进程现在有一个child.send(message) 函数，并且用fork() 调用的脚本能够监听process.on(‘message’) 事件。fork出来的子进程可以参与运算。</p>
</li>
</ul>
<h2 id="20、其他推荐的社区模块">20、其他推荐的社区模块</h2>
<ul>
<li>表单提交：foridable。</li>
<li>redis：hiredis，升级node时候，需要重新编译一下hiredis，npm rebuild hiredis。</li>
<li>mongodb：mongoose，使用时有个{safe：ture}选项表明你想让数据库操作在执行回调之前完成。</li>
</ul>
<hr>
<p>参考：<br>《Node.js 实战》：<a href="http://book.douban.com/subject/25870705/" target="_blank" rel="external">http://book.douban.com/subject/25870705/</a><br>《Node.js in action》：<a href="http://book.douban.com/subject/6805117/" target="_blank" rel="external">http://book.douban.com/subject/6805117/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>看完《Node.js 实战》，整理总结了觉得比较有价值的内容。
</code></pre><h2 id="1、require">1、require</h2>
<p>require是少有的同步i/o操作，请只在模块初始化时候使用require。</p>
<h2]]>
    </summary>
    
      <category term="nodejs" scheme="http://vernonzheng.com/tags/nodejs/"/>
    
      <category term="经验总结" scheme="http://vernonzheng.com/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
      <category term="nodejs" scheme="http://vernonzheng.com/categories/nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[整合Sentry和NodeJS实现分布式日志收集]]></title>
    <link href="http://vernonzheng.com/2014/12/26/%E6%95%B4%E5%90%88Sentry%E5%92%8CNodejs%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/"/>
    <id>http://vernonzheng.com/2014/12/26/整合Sentry和Nodejs实现分布式日志收集/</id>
    <published>2014-12-26T10:13:42.000Z</published>
    <updated>2014-12-30T03:18:54.000Z</updated>
    <content type="html"><![CDATA[<pre><code>内容包括如何利用raven-node模块，完成nodejs服务与开源日志框架Sentry的对接，实现分布式日志收集，不涉及Sentry的使用。
</code></pre><h2 id="一、什么是Sentry？">一、什么是Sentry？</h2>
<p>一个基于Djongo的日志收集系统。具备收集日志（对于分布式环境下，日志分布在各台服务器上）、日志统计（统计次数最多的异常，往往这就是系统的隐患所在）、监控告警（出现异常或者异常积累到一定数量以短信或者邮件的形式告警）、以及以上功能的可视化界面。</p>
<p>目前我们部署公网sentry是6.4.4，<br><a href="http://sentry.funshion.com/dev-web-ads/hermes/" target="_blank" rel="external">http://sentry.funshion.com/dev-web-ads/hermes/</a><br>支持的raven-node是0.7.2<br><a href="https://github.com/getsentry/raven-node" target="_blank" rel="external">https://github.com/getsentry/raven-node</a></p>
<h2 id="二、NodeJS接入Sentry">二、NodeJS接入Sentry</h2>
<p>在package.json中增加dependencies：”raven”: “0.7.2”</p>
<p>调用方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> raven = <span class="built_in">require</span>(‘raven’);</div><div class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> raven.Client(‘http:<span class="comment">//32位:32位@sentryHost');</span></div></pre></td></tr></table></figure>

<h3 id="2-1_raven-node两种使用方式">2.1 raven-node两种使用方式</h3>
<ul>
<li>2.1.1 全局拦截与实现</li>
</ul>
<p>调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">client.patchGlobal();</div></pre></td></tr></table></figure>

<p>源码如下，拦截所有uncaughtException。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports.patchGlobal = <span class="function"><span class="keyword">function</span> <span class="title">patchGlobal</span><span class="params">(client, cb)</span> </span>{</div><div class="line">    <span class="comment">// handle when the first argument is the callback, with no client specified</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> client === <span class="string">'function'</span>) {</div><div class="line">        cb = client;</div><div class="line">        client = <span class="keyword">new</span> Client();</div><div class="line">    <span class="comment">// first argument is a string DSN</span></div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> client === <span class="string">'string'</span>) {</div><div class="line">        client = <span class="keyword">new</span> Client(client);</div><div class="line">    }</div><div class="line">    <span class="comment">// at the end, if we still don't have a Client, let's make one!</span></div><div class="line">    !(client <span class="keyword">instanceof</span> Client) && (client = <span class="keyword">new</span> Client());</div><div class="line"></div><div class="line">    process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span><span class="params">(err)</span> </span>{</div><div class="line">        <span class="keyword">if</span>(cb) {  <span class="comment">// bind event listeners only if a callback was supplied</span></div><div class="line">            client.once(<span class="string">'logged'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">                cb(<span class="literal">true</span>, err);</div><div class="line">            });</div><div class="line">            client.once(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">                cb(<span class="literal">false</span>, err);</div><div class="line">            });</div><div class="line">        }</div><div class="line">        client.captureError(err, <span class="function"><span class="keyword">function</span><span class="params">(result)</span> </span>{</div><div class="line">            node_util.log(<span class="string">'uncaughtException: '</span>+client.getIdent(result));</div><div class="line">        });</div><div class="line">    });</div><div class="line">};</div></pre></td></tr></table></figure>

<p>测试下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> raven = <span class="built_in">require</span>(<span class="string">"raven"</span>)</div><div class="line"></div><div class="line">  <span class="keyword">var</span> testRaven = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">var</span> client = <span class="keyword">new</span> raven.Client(<span class="string">'http://a374661ff0374e488...略'</span>);</div><div class="line">    client.patchGlobal();</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"test throw error"</span>);</div><div class="line">    }<span class="keyword">catch</span>(err){</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"i'm caught error and throw myself again!"</span>)</div><div class="line">    }</div><div class="line">    <span class="comment">//client.captureError('test captureMessage');</span></div><div class="line">  }</div></pre></td></tr></table></figure>

<p>在sentry上显示如下：<br>会显示function名，Error message，错误出现次数等<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/sentry-test-item" alt="setry-test-item"><br>点进详情，看到程序调用栈：<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/sentry-aggregation" alt="sentry-aggregation"></p>
<ul>
<li>2.1.2 手动调用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// record a simple message</span></div><div class="line">client.captureMessage(<span class="string">'hello world!'</span>)</div><div class="line"><span class="comment">// capture an exception</span></div><div class="line">client.captureError(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Uh oh!!'</span>));</div></pre></td></tr></table></figure>

<h3 id="2-2_raven-node推荐使用方式">2.2 raven-node推荐使用方式</h3>
<p>统一使用第二种:<br>（1）对于uncaughtException使用下图方式输出到sentry：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span><span class="params">(err)</span> </span>{</div><div class="line">    ravenClient.captureError(err)</div><div class="line">    <span class="comment">//console.log("uncaughtException:" + err.stack);</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  });</div></pre></td></tr></table></figure>

<p>（2）对于catchException或者业务错误，重写log的实现，完成可配置哪个log类型输出到sentry。</p>
<h3 id="2-3_raven-node容灾考虑">2.3 raven-node容灾考虑</h3>
<p>看完怎么导入使用后，如果把它丢到生产环境，我想到的，还需要考虑的问题有：</p>
<p>（1）日志发送应该是纯异步的，不影响业务。<br>（2）发日志是调用tcp还是udp还是http接口。<br>（3）超时重发机制。<br>（4）sentry挂了怎么处理。<br>（5）sentry忙不过来怎么处理。<br>等等。</p>
<ul>
<li>2.3.1 raven-node支持的协议</li>
</ul>
<p>要回答这些问题，看下sentry的transport.js。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports.http = <span class="keyword">new</span> HTTPTransport();</div><div class="line"><span class="built_in">module</span>.exports.https = <span class="keyword">new</span> HTTPSTransport();</div><div class="line"><span class="built_in">module</span>.exports.udp = <span class="keyword">new</span> UDPTransport();</div><div class="line"><span class="built_in">module</span>.exports.Transport = Transport;</div></pre></td></tr></table></figure>

<p>支持三种方式，根据SENTRY创建项目的设置来实现，体现在SENTRY_DNS的host里。<br>因为我们都是对内网服务器日志的监控，一般使用http。</p>
<ul>
<li>2.3.2 raven-node中http协议实现-send函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">HTTPTransport.prototype.send = <span class="function"><span class="keyword">function</span><span class="params">(client, message, headers, ident)</span> </span>{</div><div class="line">    <span class="keyword">var</span> options = {</div><div class="line">        hostname: client.dsn.host,</div><div class="line">        path: client.dsn.path + <span class="string">'api/store/'</span>,</div><div class="line">        headers: headers,</div><div class="line">        method: <span class="string">'POST'</span>,</div><div class="line">        port: client.dsn.port || <span class="keyword">this</span>.defaultPort</div><div class="line">    }, req = <span class="keyword">this</span>.transport.request(options, <span class="function"><span class="keyword">function</span><span class="params">(res)</span></span>{</div><div class="line">        res.setEncoding(<span class="string">'utf8'</span>);</div><div class="line">        <span class="keyword">if</span>(res.statusCode &gt;= <span class="number">200</span> && res.statusCode &lt; <span class="number">300</span>) {</div><div class="line">            client.emit(<span class="string">'logged'</span>, ident);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">var</span> reason = res.headers[<span class="string">'x-sentry-error'</span>];</div><div class="line">            <span class="keyword">var</span> e = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'HTTP Error ('</span> + res.statusCode + <span class="string">'): '</span> + reason);</div><div class="line">            e.response = res;</div><div class="line">            e.statusCode = res.statusCode;</div><div class="line">            e.reason = reason;</div><div class="line">            e.sendMessage = message;</div><div class="line">            e.requestHeaders = headers;</div><div class="line">            e.ident = ident;</div><div class="line">            client.emit(<span class="string">'error'</span>, e);</div><div class="line">        }</div><div class="line">        <span class="comment">// force the socket to drain</span></div><div class="line">        <span class="keyword">var</span> noop = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{};</div><div class="line">        res.on(<span class="string">'data'</span>, noop);</div><div class="line">        res.on(<span class="string">'end'</span>, noop);</div><div class="line">    });</div><div class="line">    req.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>{</div><div class="line">        client.emit(<span class="string">'error'</span>, e);</div><div class="line">    });</div><div class="line">    req.end(message);</div><div class="line">};</div></pre></td></tr></table></figure>

<p>代码很简短，post msg到{SENTRY_DSN}.host/dsn.path/api/store/，而且<br>（1）没有失败重试<br>（2）发送失败（resp状态码不是200或者req调用的error），发送事件到client.emit(‘error’)，再看下client对error事件的处理：none。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>{});  <span class="comment">// noop</span></div></pre></td></tr></table></figure>

<h2 id="三、小结与优化">三、小结与优化</h2>
<h3 id="3-1_疑问解答">3.1 疑问解答</h3>
<p>回答下前面对sentry和raven-node的疑问：</p>
<ul>
<li>（1）日志发送应该是纯异步的，不影响业务。<br>  raven-node send日志后是异步回调，但是调用发送日志api是同步的。<br>（因为nodejs是单进程单线程，io异步基本已满足需求，如需优化，可以考虑对整个log模块独立进程，增加重试，发送流量控制等等，但是进程间内存拷贝开销会很大，nodejs的优劣还是很明显的，具体看应用场景）。</li>
<li>（2）发日志是调用tcp还是udp还是http接口。<br>  内网服务日志监控推荐http。</li>
<li>（3）超时重发机制。<br>  无retry机制</li>
<li>（4）sentry挂了怎么处理。</li>
<li>（5）sentry忙不过来怎么处理。<br>  （sentry接受到的请求不是实时处理，接受请求通过队列实现。性能测试可参考：<br><a href="http://blog.csdn.net/largetalk/article/details/8640854）" target="_blank" rel="external">http://blog.csdn.net/largetalk/article/details/8640854）</a><br>  sentry挂了或者忙不过来，client会接收到error，但是不会输出任何异常。</li>
<li>（6）raven-node 连接是否会复用，大量日志需要输出的时候，io和句柄占用都会影响到业务处理，是否需要过载保护？<br>参考3.2</li>
</ul>
<h3 id="3-2_优化与使用建议">3.2 优化与使用建议</h3>
<p>针对上面的rave-node可能存在的问题，给出以下优化建议</p>
<h4 id="3-2-1_规范哪些日志需要输出到sentry">3.2.1 规范哪些日志需要输出到sentry</h4>
<ul>
<li>新增monitor logger类型，专用于输出到sentry</li>
<li>必须error级别以上输出到sentry</li>
<li>error包括uncaughtException，业务异常，外部依赖服务异常，内部异常。（也可以增加服务正常启动的信息给sentry）</li>
</ul>
<h4 id="3-2-2_raven-node优化">3.2.2 raven-node优化</h4>
<p>上面提到的潜在问题总结为</p>
<ul>
<li>日志过多导致内存，句柄等资源占用过多的情况。</li>
<li>sentry异常，发送日志堆积，与日志过多情况相似。</li>
<li>目前与sentry交互的异常日志没有输出（有优点也有缺点）。</li>
</ul>
<p><strong>建议</strong></p>
<p>针对上面前两个问题，对raven-node封装或者扩展，支持固定大小的预发送队列。对外部依赖服务的异常进行隔离。</p>
<p>针对第三个问题，异常分为初始化和正常交互过程中两种情况</p>
<p>可以修改raven-node的client的prototype，支持异常输出日志。</p>
<p>或者<strong>常规解决方法</strong>：</p>
<p>正常交互过程中的异常：可以检测预发送队列的内容进行处理（如超过一定时间/次数，队列内容没有变更视为timeout异常），输出error日志。</p>
<p>初始化异常：因为client是复用的，仅当第一次初始化后，进行recheck，发送一个message：xxx服务启动。</p>
<hr>
<p>参考：<br>Raven-node github：<a href="https://github.com/getsentry/raven-node" target="_blank" rel="external">https://github.com/getsentry/raven-node</a><br>Getsentry官网：<a href="https://www.getsentry.com/docs/" target="_blank" rel="external">https://www.getsentry.com/docs/</a><br>使用开源软件sentry来收集日志：<a href="http://luxuryzh.iteye.com/blog/1980364" target="_blank" rel="external">http://luxuryzh.iteye.com/blog/1980364</a><br>关于Sentry：<a href="http://blog.csdn.net/largetalk/article/details/8640854" target="_blank" rel="external">http://blog.csdn.net/largetalk/article/details/8640854</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>内容包括如何利用raven-node模块，完成nodejs服务与开源日志框架Sentry的对接，实现分布式日志收集，不涉及Sentry的使用。
</code></pre><h2 id="一、什么是Sentry？">一、什么是Sentry？</h2>
<p>一]]>
    </summary>
    
      <category term="nodejs" scheme="http://vernonzheng.com/tags/nodejs/"/>
    
      <category term="sentry" scheme="http://vernonzheng.com/tags/sentry/"/>
    
      <category term="监控" scheme="http://vernonzheng.com/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="nodejs" scheme="http://vernonzheng.com/categories/nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Coffeescript极简教程]]></title>
    <link href="http://vernonzheng.com/2014/12/20/Coffeescript%E6%9E%81%E7%AE%80%E6%95%99%E7%A8%8B/"/>
    <id>http://vernonzheng.com/2014/12/20/Coffeescript极简教程/</id>
    <published>2014-12-20T14:17:30.000Z</published>
    <updated>2014-12-28T10:38:17.000Z</updated>
    <content type="html"><![CDATA[<pre><code>配合没耐心的nodejs教程，写给希望快速上手的coffeescript使用者。
</code></pre><h2 id="一、一些简写和约定：">一、一些简写和约定：</h2>
<p>coffeescript和python类似，空格，缩写都是有意义的。<br>换行替换分号，缩进替换花括号，空格替换括号，<br>但是数组的’[]’不能省略。</p>
<h2 id="二、全局变量：">二、全局变量：</h2>
<p>CoffeeScript剔除了全局变量，避免js中全局变量的误用。（CoffeeScript使用一个匿名函数把所有脚本都包裹起来，将其限定在局部作用域中，并且在为所有的变量赋值前自动添加var）</p>
<p>当然也有需要用全局变量的时候，直接给全局对象windoow赋值即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">exports = this</div><div class="line">exports.tempVal = “tempVal”</div></pre></td></tr></table></figure>

<p>这里在顶级作用域中使用，this相当于全局变量</p>
<h2 id="三、函数">三、函数</h2>
<h3 id="3-1_函数的标准写法">3.1 函数的标准写法</h3>
<p>-&gt; 替代了function(){}<br>如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sum = (nums...) -&gt; </div><div class="line">	result = <span class="number">0</span></div><div class="line">	nums.forEach(n) -&gt; result += n</div><div class="line">	result</div></pre></td></tr></table></figure>

<p>（nums）为传入的参数槽（splats），…表示不定参数，同时自动返回result<br>调用输出结果 alert sum() 或者 alert sum a,b,c ,其中空格表示括号，但是易混淆或者无参调用的时候，请带上括号。</p>
<p><strong><em>多重赋值：</em></strong></p>
<p>btw，因为讲到…不定参数，就提下多重赋值与…的结合：<br>多重赋值就是将一个数组的值逐个赋给后面的一系列变量。<br>如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">myArray = [<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D”] </span></div><div class="line">[start, middle..., end] = myArray </div><div class="line">console.log "start is <span class="comment">#{start}” </span></div><div class="line">console.log <span class="string">"middle is #{middle}” </span></div><div class="line">console.log "end is <span class="comment">#{end}”</span></div></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">start is A </div><div class="line">middle is B,C </div><div class="line">end is D</div></pre></td></tr></table></figure>

<p>顺便提下，数组是支持range的用法的，[1…10]</p>
<h3 id="3-2函数上下文：">3.2函数上下文：</h3>
<p>js的上下文变化会很频繁，尤其在回调函数内，coffeescript提供=&gt;或者self(this)的方式，以下为=&gt;的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">this.clickHandler = -&gt; alert “clicked”</div><div class="line">element.addEventListener “click”, (e) =&gt;</div><div class="line">	his.clickHandler(e)</div></pre></td></tr></table></figure>

<h2 id="四、集合遍历">四、集合遍历</h2>
<h3 id="4-1_for循环：">4.1 for循环：</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myLetters = [“a”,”b”,”c”,”d”]</div><div class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> myLetters</div><div class="line">console.log letter.toUpperCase()</div></pre></td></tr></table></figure>

<p>for中增加when条件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> num，i <span class="keyword">in</span> a when num &lt; <span class="number">5</span></div><div class="line">console.log “第<span class="comment">#{i}个数为#{num}"</span></div></pre></td></tr></table></figure>

<h3 id="4-2_列表推导式(Comprehension)">4.2 列表推导式(Comprehension)</h3>
<p>类似ruby的前缀表达式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myLetters = [“a”,”b”,”c”,”d”]</div><div class="line"></div><div class="line">console.log letter.toUpperCase() <span class="keyword">for</span> letter <span class="keyword">in</span> myLetters</div></pre></td></tr></table></figure>

<h3 id="4-3_对象枚举的方式">4.3 对象枚举的方式</h3>
<p>(这里in换成了of）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">person = </div><div class="line">firstName: “Mark”</div><div class="line">lastName: “Bates”</div><div class="line"></div><div class="line"><span class="keyword">for</span> key, value of person</div><div class="line">console.log “<span class="comment">#{key} is #{value}”</span></div></pre></td></tr></table></figure>

<p>对象属性的枚举还支持when关键字；如果需要过滤继承属性，还可以使用own关键字</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">myObject = </div><div class="line">name: “Mark”</div><div class="line"></div><div class="line">Object.prototype.dob = new Date(<span class="number">1976</span>, <span class="number">7</span>, <span class="number">24</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> own key, value of myObject</div><div class="line">console.log “<span class="comment">#{key}:#{value}”</span></div></pre></td></tr></table></figure>

<h3 id="4-4_while用法">4.4 while用法</h3>
<p>与js不同，while还可以返回结果数组</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">num = <span class="number">6</span></div><div class="line">minstrel = <span class="keyword">while</span> num -= <span class="number">1</span></div><div class="line">	num + “ Brave Sir Robin ran away”</div></pre></td></tr></table></figure>

<p>综合例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@updateAvatars = -&gt;</div><div class="line">name = $(‘.avatar[data-name]’),map -&gt; $(this).data(’name’)</div><div class="line">Utils.findAvatar(name) <span class="keyword">for</span> name <span class="keyword">in</span> $.unique(names)</div></pre></td></tr></table></figure>

<h2 id="五、别名与存在操作符">五、别名与存在操作符</h2>
<h3 id="5-1_别名：">5.1 别名：</h3>
<p>@ 表示this的别名，如@saviour = this.saviour<br>:: 表示prototype</p>
<h3 id="5-2_存在操作符？：">5.2 存在操作符？：</h3>
<p>coffeescript中，？只会在变量不存在或者undefined的时候返回假，<br>如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">praise <span class="keyword">if</span> brain?</div></pre></td></tr></table></figure>

<p>还可以用来替换||操作符：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">velocity = southern ？ <span class="number">40</span></div></pre></td></tr></table></figure>

<p>或者在访问对象时进行null检查，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">blacknight.getLegs()?.kick()</div></pre></td></tr></table></figure>

<p>判断属性是否存在外，你还也可以把？放到kick右边，判断函数是否存在，是否可以调用等</p>
<h2 id="六、类">六、类</h2>
<p>Coffeescript中类定义是组合模式（组合使用构造模式和原型模式），继承方式则用寄生组合模式。</p>
<h3 id="6-1_定义类">6.1 定义类</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Employee</div><div class="line"></div><div class="line">constructor: (name) -&gt;</div><div class="line">@name = name</div><div class="line">dob: (year = <span class="number">1976</span>, month =<span class="number">7</span>, day = <span class="number">24</span>) -&gt;</div><div class="line">new Date(year, month, day)</div><div class="line"></div><div class="line">emp1 = new Employee(“Mark”)</div><div class="line">console.log emp1.name</div><div class="line">console.og emp11.dob()</div></pre></td></tr></table></figure>

<h3 id="6-2_添加方法">6.2 添加方法</h3>
<p>方法是直接定义在原型上，显示为原型添加方法，很简单：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Array::size = -&gt; @length</div></pre></td></tr></table></figure>

<h3 id="6-3_构造函数简化">6.3 构造函数简化</h3>
<p>如果把参数赋值给同名属性，可以用@语法糖，将构造函数简化为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">constructor: (@name) -&gt;</div></pre></td></tr></table></figure>

<h3 id="6-4_实例变量的使用">6.4 实例变量的使用</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Animal</div><div class="line">	price: <span class="number">5</span></div><div class="line"></div><div class="line">	sell: =&gt;</div><div class="line">		alert “Give me <span class="comment">#{@price} shillings!”</span></div><div class="line"></div><div class="line">animal = new Animal</div><div class="line">$(“<span class="comment">#sell”).click(animal.sell)</span></div></pre></td></tr></table></figure>

<p>其中注意到=&gt;的使用，表示引用方法调用的上下文，输出5.</p>
<h3 id="6-5_静态变量的使用">6.5 静态变量的使用</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class Animal</div><div class="line">	@find: (name) -&gt;</div><div class="line"></div><div class="line">Animal.find(“Parrot”)</div></pre></td></tr></table></figure>

<p>其实就是在类属性上（this）设置变量值。</p>
<h3 id="6-6_继承">6.6 继承</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Animal</div><div class="line">	constructor: (@name) -&gt;</div><div class="line">class Parrot extends Animal</div><div class="line"></div><div class="line">Animal::rip = <span class="literal">true</span></div><div class="line"></div><div class="line">parrot = new Parrot(“Macaw”)</div><div class="line">alert(“This parrot is no more”) <span class="keyword">if</span> parrot.rip</div></pre></td></tr></table></figure>

<p>这里要注意的是，静态变量是直接拷贝给子类的，而不是像实例属性那样使用原型来继承。</p>
<h2 id="七、Mixins混入">七、Mixins混入</h2>
<p>举个例子：<br>module类有两个静态方法，@extend()和@include()，分别来实现对类的静态属性和实例属性的扩展。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">moduleKeywords = [‘exteded’, ‘included’]</div><div class="line"></div><div class="line">class Module</div><div class="line">	@extend: (obj) -&gt;</div><div class="line">		<span class="keyword">for</span> key, value of obj when key not <span class="keyword">in</span> moduleKeywords</div><div class="line">			@[key] = value</div><div class="line">			obj.extended?.apply(@)</div><div class="line">			this</div><div class="line"></div><div class="line">	@include: (obj) -&gt;</div><div class="line">		<span class="keyword">for</span> key, value of obj when key not <span class="keyword">in</span> moduleKeywords</div><div class="line">			<span class="comment"># Assign properties to the prototype</span></div><div class="line">			@::[key] = value</div><div class="line"></div><div class="line">		obj.included?.apply(@)</div><div class="line">		this</div></pre></td></tr></table></figure>

<p>然后是如何使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">classProperties = </div><div class="line">	find: (id) -&gt;</div><div class="line">	create: (attrs) -&gt;</div><div class="line"></div><div class="line">instanceProperties = </div><div class="line">	save: -&gt;</div><div class="line"></div><div class="line">class User extends Module</div><div class="line">	@extends classProperties</div><div class="line">	@include instanceProperties</div><div class="line">	</div><div class="line"><span class="comment"># Usage:</span></div><div class="line">user = User.find((<span class="number">1</span>)</div><div class="line"></div><div class="line">user = new User</div><div class="line">user.save()</div></pre></td></tr></table></figure>

<p>以上，我们为User类添加了静态属性find()和create()，还添加了实例属性save()。</p>
<p>再给一个例子，在扩展类后执行回调：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ORM = </div><div class="line">	find: (id) -&gt;</div><div class="line">	create: (attrs) -&gt;</div><div class="line">	extended: -&gt;</div><div class="line">		@include</div><div class="line">			save: -&gt;</div><div class="line"></div><div class="line">class User extends Module</div><div class="line">	@extends ORM</div></pre></td></tr></table></figure>

<p>基础讲完，接下来就可以围绕网络，文件，进程，异步等进行专项练习了，好运！</p>
<hr>
<p>参考：<br>《The Little Book on CoffeeScript》：<a href="http://book.douban.com/subject/10462179/" target="_blank" rel="external">http://book.douban.com/subject/10462179/</a><br>Learn X in Y minutes Where X=coffeescript：<a href="http://learnxinyminutes.com/docs/coffeescript/" target="_blank" rel="external">http://learnxinyminutes.com/docs/coffeescript/</a><br>CoffeeScript极简教程：<a href="http://chunfenglee.com/blog/2013/10/13/beginning-coffeescript/" target="_blank" rel="external">http://chunfenglee.com/blog/2013/10/13/beginning-coffeescript/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>配合没耐心的nodejs教程，写给希望快速上手的coffeescript使用者。
</code></pre><h2 id="一、一些简写和约定：">一、一些简写和约定：</h2>
<p>coffeescript和python类似，空格，缩写都是有意义的。<b]]>
    </summary>
    
      <category term="coffeescript" scheme="http://vernonzheng.com/tags/coffeescript/"/>
    
      <category term="基础" scheme="http://vernonzheng.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="coffeescript" scheme="http://vernonzheng.com/categories/coffeescript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[没耐心的NodeJS基础教程]]></title>
    <link href="http://vernonzheng.com/2014/12/17/%E6%B2%A1%E8%80%90%E5%BF%83%E7%9A%84NodeJS%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
    <id>http://vernonzheng.com/2014/12/17/没耐心的NodeJS基础教程/</id>
    <published>2014-12-17T15:21:00.000Z</published>
    <updated>2014-12-28T10:41:42.000Z</updated>
    <content type="html"><![CDATA[<pre><code>这是一篇没耐心的nodejs教程，写给希望迅速上手的学习者。基础篇介绍权限，模块，包，工程目录结构，<span class="built_in">npm</span>等，不涉及常用api和中间件等。
</code></pre><h2 id="一、权限问题">一、权限问题</h2>
<p>linux下，nodejs需要监听80或443端口提供HTTP（S）服务时需要root权限。<br>有两种方式：</p>
<ul>
<li>（1）（推荐）需要js提供root权限<blockquote>
<p>$ sudo node server.js</p>
</blockquote>
</li>
<li>（2）使用chmod+s命令让nodejs总是以root权限运行，不安全。<blockquote>
<p>$ sudo chown root /usr/local/bin/node<br>$ sudo chmod +s /usr/local/bin/node</p>
</blockquote>
</li>
</ul>
<h2 id="二、模块">二、模块</h2>
<p>一个文件为一个模块，一个文件路径为一个模块名。<br>编写模块时，有require，exports，module三个变量。</p>
<ul>
<li><strong>2.1 required</strong><br>导入某个模块<blockquote>
<p>var foo1 = required(‘./foo’);//.js后缀可以省略<br>var foo2 = required(“./foo.js”);</p>
</blockquote>
</li>
</ul>
<p>也可以加载或者导入一个json：</p>
<blockquote>
<p>var data = require(‘./data.json’);</p>
</blockquote>
<ul>
<li><p><strong>2.2 exports</strong><br>是当前模块的导出对象，用于导出模块共有方式和属性。</p>
<blockquote>
<p>exports.hello = function(){</p>
<pre><code>console.<span class="built_in">log</span>(‘Hello World!’);
</code></pre><p>};</p>
</blockquote>
</li>
<li><p><strong>2.3 module</strong><br>可以访问当前模块的一些信息，最多的用途就是替换当前模块的到处对象。</p>
<blockquote>
<p>module.export = function(){</p>
<pre><code> console.<span class="built_in">log</span>(‘Hello World!’);
</code></pre><p>};</p>
</blockquote>
</li>
</ul>
<h2 id="三、模块初始化">三、模块初始化</h2>
<p>NodeJS使用CMD模块系统，主模块作为程序入口点，所有模块在执行过程中只初始化一次。</p>
<p><strong>初始化一次</strong></p>
<p>一个模块中的JS代码仅在模块第一次被使用时执行一次，并在执行过程中初始化模块的导出对象。之后，缓存起来的导出对象被重复利用。</p>
<ul>
<li><p><strong>3.1 主模块</strong><br>通过命令行参数传递给NodeJS以启动程序的模块被称为主模块。主模块负责调度组成整个程序的其他模块完成工作。默认是路径下的main.js。</p>
</li>
<li><p><strong>3.2 二进制模块（不推荐）</strong><br>nodejs支持使用c/c++编写二进制模块。编译好的二进制模块除了文件扩展名是.node外，和JS块的使用方式相同。</p>
</li>
</ul>
<h2 id="四、模块路径解析规则">四、模块路径解析规则</h2>
<p>除了相对路径和绝对路径外，require函数还支持第三种形式的路径。</p>
<ul>
<li><p><strong>4.1 内置模块</strong></p>
</li>
<li><p><strong>4.2 node_modules目录</strong><br>专门存放模块的路径。比如某个模块的绝对路径是/home/user/hello.js, 在该模块中使用require(‘foo/bar’)方式加载模块，则NodeJS依次尝试使用以下路径。</p>
<blockquote>
<p>/home/user/node_modules/foo/bar<br>/home/node_modules/foo/bar<br>/node_moduels/foo/bar</p>
</blockquote>
</li>
<li><p><strong>4.3 NODE_PATH环境变量</strong><br>指定额外的模块搜索路径。因为是额外，所以最后搜索。<br>使用：设置NODE_PATH环境变量，linux用：分隔，windows使用；分隔。</p>
</li>
</ul>
<h2 id="五、包">五、包</h2>
<ul>
<li><p><strong>5.1 入口模块</strong><br>多个js模块，组成一个包。所有模块都是同一个路径里，且需要指定一个入口模块，入口模块的导出对象作为包的导出对象。<br>比如cat目录下有main.js,lib1.js,lib2.js。<br>main.js作为入口模块，require lib1.js,lib2.js。</p>
</li>
<li><p><strong>5.2 index.js</strong><br>当模块文件名为index.js,加载模块时就可以使用模块所在目录的路径代替模块文件路径，如可写成<br>var cat = require(‘/home/user/lib/cat’);<br>var cat = require(‘/home/user/lib/cat/index’);</p>
</li>
<li><p><strong>5.3 自定义入口模块和存放位置（package.json）</strong><br>如果你想自定义入口模块的文件名和存放位置，就需要在包目录下包含一个package.json文件，如</p>
<blockquote>
<p>{</p>
<pre><code>“name”: “cat”,
“main”: “./lib/main.js<span class="string">"</span>
</code></pre><p>}<br>如此一来，就可以用require(‘/home/user/lib/cat’)加载。</p>
</blockquote>
</li>
</ul>
<h2 id="六、命令行程序">六、命令行程序</h2>
<p>将固定node命令开头执行的方式，变成命令行的方式。<br>node xx.js [param] =&gt; xx [param]，<br>如$node /home/user/bin/node-echo.js Hello World<br>变成<br>$node-echo Hello World<br>简便很多</p>
<p>那么如何做到，只讲在linux下怎么做：</p>
<ul>
<li>(1)node-echo.js顶部增加<blockquote>
<p>#!/usr/bin/env node</p>
</blockquote>
</li>
<li>(2)然后增加执行权限，并再/usr/local/bin下创建软链接<blockquote>
<p>$ chmod +x /home/user/bin/node-echo.js<br>$ sudo ln -s /home/user/bin/node-echo.js /usr/local/bin/node-echo</p>
</blockquote>
</li>
</ul>
<h2 id="七、工程目录结构">七、工程目录结构</h2>
<blockquote>
<ul>
<li>/home/user/workspace/node-echo/<ul>
<li>bin/<br>  node-echo</li>
</ul>
<ul>
<li>doc/</li>
</ul>
<ul>
<li>lib/<br>  echo.js</li>
<li>node_modules/<ul>
<li>argv/</li>
</ul>
</li>
</ul>
<ul>
<li>tests/<br>package.json<br>README.md</li>
</ul>
</li>
</ul>
</blockquote>
<p>其中部分文件：</p>
<blockquote>
<p>/<em> bin/node-echo </em>/<br>var argv = require(‘argue’),<br>     echo = require(‘../ilb/echo’);<br>console.log(echo(argv.join(‘ ‘)));</p>
<p>/<em> lib/echo.js</em>/<br>module.exports = function(message){<br>    return message;<br>}</p>
<p>/<em> pacakge.json </em>/<br>{<br>    “name”:”node-echo”,<br>    “main”:”./lib/echo.js”<br>}</p>
</blockquote>
<h2 id="八、NPM:包管理工具">八、NPM:包管理工具</h2>
<p>（1）允许用户从NPM服务器下载别人编写的三方包到本地使用。<br>（2）允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。<br>（3）允许用户将自己编写的包或者命令行程序上传到NPM服务器供别人使用。</p>
<ul>
<li><strong>8.1 下载第三方包</strong></li>
</ul>
<p>一般这样使用别人的包(如argv)，<br>在项目目录下，npm install argv@1.1.1，那么argv包就会放到node_modules目录下，直接require(‘argv’)就可以使用了。</p>
<p>依赖的包比较多时，通过package.json字段做了扩展。<br>如：<br>{<br>    “name”: “node-echo”,<br>    “main”: “./lib/echo.js”,<br>    “denpendencies”:{<br>        “argv”: “0.0.2”<br>    }<br>}<br>然后在工程目录，npm install即可。btw，传递的依赖会被自动下载。</p>
<ul>
<li><strong>8.2 安装命令行工具</strong></li>
</ul>
<p>如上面例子的node-echo，只要node-echo自己配置好了对应的package.json字段，对于用户而言，这样安装：</p>
<blockquote>
<p>$ npm install node-echo -g<br>其中-g表示全局安装，node-echo会默认安装到以下位置，并且NPM会自动创建好Linux系统下需要的软链文件。</p>
<ul>
<li>/usr/local/<ul>
<li>lib/node_modules/<ul>
<li>node-echo/<br>…</li>
</ul>
</li>
<li>bin/<br>  node-echo<br>…</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><strong>8.3 发布代码</strong></li>
</ul>
<p>第一次发布npm，需要注册个号码。执行npm adduser，按提示操作。账号完成设置后，编辑需要发布的项目的package.json，加入npm必须字段。<br>如：</p>
<blockquote>
<p>{<br>   “name”: ”node-echo”，#包名，与NPM服务器保持唯一<br>   “version”： “1.0.0”，#当前版本号<br>   “dependencies”：{<br>       “argv”： “0.0.2”<br>   }，<br>   “main”： “./lib/echo.js”,<br>   “bin”: {<br>       “node-echo”: “./bin/node-echo”  #命令行程序名和主模块位置<br>   }<br>}<br>然后，在package.json所在目录下运行npm publish 发布代码。</p>
</blockquote>
<ul>
<li><strong>8.4 版本号</strong></li>
</ul>
<p>使用npm下载或者发布代码都要用到版本号。<br>语义版版本号分为X.Y.Z三位，<br> 分别为主版本号、（大变动，向下不兼容）<br> 次版本号（新增功能，向下兼容）、<br> 补丁版本号（修复bug）。</p>
<h2 id="九、最后npm比较有用的命令行：">九、最后npm比较有用的命令行：</h2>
<ul>
<li>在package.json目录，npm install . -g 可先在本地安装当前命令行程序，用于发布前本地测试。</li>
<li>npm update  <package>当前目录下node_modules子目录下对应模块更新到最新版本。</package></li>
<li>npm update <package> -g 把全局安装的对应命令行程序更新至最新版。</package></li>
<li>npm cache clear 清空NPM本地缓存，用于对于使用相同版本号发布新版本的人。</li>
<li>npm unpublish <package>@<version> 可以撤销自己发布过的某个版本代码。</version></package></li>
</ul>
<hr>
<p>参考：<br>七天学会NodeJS：<a href="http://nqdeng.github.io/7-days-nodejs/\#3.2.1" target="_blank" rel="external">http://nqdeng.github.io/7-days-nodejs/\#3.2.1</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>这是一篇没耐心的nodejs教程，写给希望迅速上手的学习者。基础篇介绍权限，模块，包，工程目录结构，<span class="built_in">npm</span>等，不涉及常用api和中间件等。
</code></pre><h2 id="一、权限问题">]]>
    </summary>
    
      <category term="nodejs" scheme="http://vernonzheng.com/tags/nodejs/"/>
    
      <category term="基础" scheme="http://vernonzheng.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="nodejs" scheme="http://vernonzheng.com/categories/nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《如何阅读一本书》感悟总结]]></title>
    <link href="http://vernonzheng.com/2014/12/15/%E3%80%8A%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E3%80%8B%E6%84%9F%E6%82%9F%E6%80%BB%E7%BB%93/"/>
    <id>http://vernonzheng.com/2014/12/15/《如何阅读一本书》感悟总结/</id>
    <published>2014-12-14T16:27:57.000Z</published>
    <updated>2014-12-28T10:42:01.000Z</updated>
    <content type="html"><![CDATA[<pre><code>阅读一本书，就是和作者交流的过程。与直接面对面交流不同，阅读这种“静默”交流方式，需要不同的经验和技巧。刚看完《如何阅读一本书》，感触比较多，总结一下。
</code></pre><p>读书太快或者太慢都会一无所获。要知道什么时候用什么速度阅读很重要。</p>
<p><strong>好的阅读是</strong></p>
<ul>
<li>（1）主动，包括主动的发现问题，思考问题，做一个自我要求的读者<br>（要去理解作者在说什么，为什么这么说，有道理吗，如果有道理怎么运用它等，最后善于做笔记）。</li>
<li>（2）技巧，根据不同的阅读层次和目的，技巧不同，后面讲到。</li>
</ul>
<p><strong>阅读的目的有两种</strong></p>
<p>一种是为获得咨询而读，一种是求得理解而读。<br>两种的技巧不同。<br>（为求得理解而读的一般发生在两种状况下：<br>一是一开始不对等的理解程度<br>二是阅读的人一定要把不对等的理解力克服到一定程度内。）</p>
<p><strong>阅读的层次</strong></p>
<ul>
<li>基础阅读</li>
<li>检视阅读：系统化略读。获得咨询或者消遣停留在这个层次。</li>
<li>分析阅读：特别是在追求理解。</li>
<li>主题阅读：又称比较阅读，根据主题，阅读很多本书，例举出书之间的相关之处，总结。</li>
</ul>
<p><strong>各层次阅读经验</strong></p>
<ul>
<li><p>检视阅读：<br>（1）头一次面对一本难读的时候，从头到尾先读一遍，碰到不懂的地方不要停下来查询或者思索。<br>（2）避免“逗留”和“倒退”的坏习惯。</p>
</li>
<li><p>分析阅读：<br>（1）根据顺序和关系，列出全书的重要部分，找出作者在问的问题，或作者想要解决的问题，诠释作者使用的关键字，与作者打成共识，找到论述，然后重构前因后果，明白哪些已解决，哪些未解决。<br>（2）应该为感到困扰的问题停留，而不是感兴趣的细节。</p>
</li>
<li><p>主题阅读：<br>略</p>
</li>
</ul>
<p><strong>各类型书的阅读经验</strong></p>
<ul>
<li><p>实用型书：<br>（1）“任何实用型书都不能解决该书的实际问题”，原文有点绕。。我理解为提出是思维，而非答案，最后做解决方案的还是自己。<br>（2）好的阅读者，读实用型书总能读出言外之意，即衍生出来的规则，他会进一步找出这些规则应该如何应用。<br>（3）评断一本实用型书，所有的事都与结果及目标有关，是否与结果达成共识，而非方法。</p>
</li>
<li><p>想象性文学：<br>（1）论述性文学传达的是知识，而想象性文学传达的是经验。</p>
</li>
<li><p>故事书：<br>（1）快，全心全意的读。</p>
</li>
<li><p>戏剧：<br>（1）你在读剧本时，不是在读一个已经完成的作品。<br>（2）悲剧的精髓在于时间，或者说缺乏时间。</p>
</li>
<li><p>历史类，计算机数学类，哲学类，社科类略。</p>
</li>
</ul>
<p>最后感慨下，多读书，多总结出更适合自己的方式。</p>
<hr>
<p>参考：<br>《如何阅读一本书》：<a href="http://book.douban.com/subject/1013208/" target="_blank" rel="external">http://book.douban.com/subject/1013208/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>阅读一本书，就是和作者交流的过程。与直接面对面交流不同，阅读这种“静默”交流方式，需要不同的经验和技巧。刚看完《如何阅读一本书》，感触比较多，总结一下。
</code></pre><p>读书太快或者太慢都会一无所获。要知道什么时候用什么速度阅读很重要。</p]]>
    </summary>
    
      <category term="阅读方法" scheme="http://vernonzheng.com/tags/%E9%98%85%E8%AF%BB%E6%96%B9%E6%B3%95/"/>
    
      <category term="读书笔记" scheme="http://vernonzheng.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="读书笔记" scheme="http://vernonzheng.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux常用命令小记]]></title>
    <link href="http://vernonzheng.com/2014/12/13/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/"/>
    <id>http://vernonzheng.com/2014/12/13/Linux常用命令小记/</id>
    <published>2014-12-13T07:13:47.000Z</published>
    <updated>2014-12-28T10:40:24.000Z</updated>
    <content type="html"><![CDATA[<pre><code>最近在翻《Linux命令行与<span class="keyword">shell</span>脚本编程大全》,整理了书中提到的常用的linux命令行。
</code></pre><h2 id="一、文件相关">一、文件相关</h2>
<ul>
<li><p><strong>链接文件</strong><br>cp -l test1 test4 创建硬链接（一个独立文件，引用了源文件，索引节点号是一样的，只适用同一个挂载点下的文件）<br>cp -s test1 test5 创建符号链接，软链接（一个独立文件，只存储源文件的信息，不存储源文件数据，索引节点显示为test5 -&gt; test1）<br>ln 链接文件（硬链接）<br>ln -s 链接文件（软链接）</p>
</li>
<li><p><strong>文件状态</strong><br>stat test10 查看文件统计信息，比ls更全<br>file test1 显示文件类型（3类，文本文件，可执行文件，数据文件）</p>
</li>
<li><p><strong>查看文件内容</strong><br>cat -n test1 查看整个文件，同时显示行号<br>more test1 查看整个文件，显示一页停下来，再向下翻页<br>less test1 more的升级版，不用全部加载文件<br>tail -n 100 -f 显示最后的100行，-f保持活动状态，有新内容就显示<br>head -n 100 -f 与tail类似，显示最开始的100行</p>
</li>
<li><p><strong>文件排序、过滤</strong><br>sort -n 排序文件数据行，-n表示把数字识别为数字，而不是字符，让它们按值排序<br>sort -t ‘:’ -k 3 -n /etc/passwd 其中-t表示指定字段的分隔符，-k指定排序的字段，最终完成按照用户ID进行数字排序<br>grep -e t -e f file1 过滤文件内容，筛选匹配行，其中-e表示多个匹配模式，满足其一就被筛选出来</p>
</li>
<li><p><strong>文件压缩、归档</strong><br>zip -r test.zip test 递归压缩目录<br>unzip test.zip 解压<br>tar -cvf test.tar test/ test2/ 创建含有test和test2目录的test.tar归档文件。<br>tar -tf test.tar 列出test.tar 内容，不解压<br>tar -xvf test.tar 解压<br>tar -zxvf test.tgz 解压gzip压缩过的tar文件</p>
</li>
</ul>
<h2 id="二、线程相关">二、线程相关</h2>
<ul>
<li><p><strong>监控性能</strong><br>top 实时监控进行，系统负载等</p>
</li>
<li><p><strong>线程消息</strong><br>kill -s 信号（线程传递信息，比如HUP（1）挂起，INT（2）终端，QUIT（3）结束运行，KILL（9）无条件终止）</p>
</li>
</ul>
<h2 id="三、账号相关">三、账号相关</h2>
<ul>
<li><strong>组与用户</strong><br>useradd -b default_home -g group sb<br>usermod 修改用户账户的字段，比如主要组以及附加组的所属关系<br>passwd username 修改密码<br>groupadd shared 创建shared新组（tail /etc/group查看结果）<br>usermod -G shared rich 增加shared组的成员，是-G，不是-g，-g会修改账户的默认组！<br>groupmod -n sharing shared 其中-n是修复已有组的组名 -g是修改GID<br>umask 777 —在/etc/profile 设置umask，即touch创建文件时候，默认给的权限<br>chmod o+r newfile (o表示权限设置跟其他用户一样，u表示权限设置为属主一样，g设置为属组一样，r读权限)<br>chown dan.shared newfile 改变文件的属主和属组</li>
</ul>
<h2 id="四、磁盘设备相关">四、磁盘设备相关</h2>
<ul>
<li><p><strong>设备</strong><br>mount -t vfat /dev/sdb1 media/disk 将u盘/dev/sdb1 挂载到/media/disk<br>mount /homr/rich/mnt 卸载</p>
</li>
<li><p><strong>磁盘</strong><br>df -h 显示设备的磁盘空间。<br>du -h 显示特定目录下磁盘使用情况。用来判断系统某个目录是否有超大文件的快速方式。</p>
</li>
</ul>
<hr>
<p>参考：<br>《Linux命令行与shell脚本编程大全》:<a href="http://book.douban.com/subject/11589828/" target="_blank" rel="external">http://book.douban.com/subject/11589828/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>最近在翻《Linux命令行与<span class="keyword">shell</span>脚本编程大全》,整理了书中提到的常用的linux命令行。
</code></pre><h2 id="一、文件相关">一、文件相关</h2>
<ul>
<li><p]]>
    </summary>
    
      <category term="linux" scheme="http://vernonzheng.com/tags/linux/"/>
    
      <category term="命令行" scheme="http://vernonzheng.com/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
      <category term="linux" scheme="http://vernonzheng.com/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Robust Java 中文版》 笔记总结]]></title>
    <link href="http://vernonzheng.com/2014/12/10/%E3%80%8ARobust-Java-%E4%B8%AD%E6%96%87%E7%89%88%E3%80%8B%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/"/>
    <id>http://vernonzheng.com/2014/12/10/《Robust-Java-中文版》笔记总结/</id>
    <published>2014-12-10T14:08:49.000Z</published>
    <updated>2014-12-28T10:41:15.000Z</updated>
    <content type="html"><![CDATA[<pre><code><span class="comment">Robust</span> <span class="comment">Java</span> <span class="comment">中文版</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">Java异常处理、测试与调试，这本书主要讲解了Java异常</span> <span class="comment">的原理及处理方法，系统地阐述了体系结构、设计、开发、测试和调试等主题，并讨论了如何构建健壮的系统。</span>
</code></pre><h2 id="一、异常基础">一、异常基础</h2>
<p>java异常的产生是代码处，异常会作为消息发送至应用程序的catch部分或者抛出。</p>
<p><strong>1.1 Throwable的内部关系</strong></p>
<p>异常的祖先是Throwable（可抛出），底下是Exception（异常）和Error（错误）<br>Exception异常：为“合理程序程序需要捕获的情况”，可预测，可恢复。<br>Error错误：合理应用程序不应试图捕获它，反常情况。</p>
<p><strong>1.2 可检测异常与非检测异常</strong></p>
<p><strong>区别</strong>：可检测异常经编译器验证，而非检测异常不需要。<br>主要的非检测异常：RuntimeException和Error。（对于RuntimeException，一般针对特定操作，请增加校验。）</p>
<p><strong>1.3 Trowable的属性</strong></p>
<p>Throwable 存储3个属性：</p>
<ul>
<li>message（消息）：String //描述性文本 读（只能在构造函数设置）</li>
<li>stack trace（栈跟踪）：StackTraceElement[] //引发异常的所有方法调用的记录 读-写</li>
<li>cause（原因）：Trowable //产生此异常的原因 读-写（只能设置一次） getCause和initCause获取和设置，或者构造函数设置</li>
</ul>
<p>除3个属性外，Throwable还包含toString和getLocalizedMessage 方法。<br>toString方法：覆盖Object类，返回异常名（对于非空消息字符串）。<br>getLocalizedMessge方法：返回消息字符串的值。</p>
<h2 id="二、异常的实践">二、异常的实践</h2>
<p><strong>2.1 处理还是声明异常</strong></p>
<p><strong>经验法则</strong>：尽可能去处理异常，如果没有能力处理就声明异常。<br>从本质上讲，仅当方法缺少自我处理异常的信息、上下文或资源时，才将异常信息传给调用者。</p>
<h2 id="三、异常高级特性">三、异常高级特性</h2>
<p><strong>3.1 链表异常</strong></p>
<p>就是异常允许设置两个异常之间的关联，称为链表异常。参考1.3里的cause属性。<br>设置方法有两种，作为构造函数参数传入，或者调用initCause(Throwable)方法设置，只能设置一次。</p>
<p>一般不常用，处理链表异常的方式可以参考如下：</p>
<blockquote>
<p>try{<br>    throublesomeObject.riskyMethod();<br>}catch(ChainedException exc){<br>    System.out.println(“We’re in trouble now!!!”);<br>    Throwable currentException = exc;<br>    do{<br>         System.out.println(currentException.toString());<br>         currentException = currentException.getCause();<br>    }while(currentException != null)<br>}</p>
</blockquote>
<p><strong>3.2 异常的本地化和国际化</strong></p>
<p>如果需要本地化异常相关文本，可在自定义异常中覆盖getLocalizedMessage(),以加载本地专用的异常信息。</p>
<p>java使用java.util和java.text包的类支持110n和i18n.java.util.resourceBundle和java.util.Locale是两个关键类。</p>
<p>实现步骤为：</p>
<ul>
<li>创建ResourceBundle子类来存储消息</li>
<li>为不同地区继承ResourceBundle类</li>
<li>创建覆盖getLocalizedMessage的自定义异常类并用ResourceBundle检索消息</li>
<li>具体大家自己查下吧，就不贴代码了。</li>
</ul>
<p><strong>3.3 不声明异常，声明异常，try-catch处理异常的性能比较</strong></p>
<p>有兴趣的可以自己写个测试类，javap -c -verbose一下。</p>
<p>可以看到：<br>声明异常和不声明的两个方法字节码相同，声明异常的抛出语句在类的方法查找表中声明。<br>而内部try-catch的方法，会增加一些如goto， astore等的字节码指令，以及一个与该方法相关的异常表（Exception table）。若产生异常，异常表控制代码路由。实际上行为与前两者类似。</p>
<p>那么这三者的性能比较会怎样？<strong>实际测试是区别不明显</strong>。</p>
<p>总结下<strong>最佳实践</strong>：<br>尽量避免抛出异常。<br>如果条件允许就处理异常。<br>如果条件不允许就声明异常。</p>
<h2 id="四、异常与多线程">四、异常与多线程</h2>
<p><strong>4.1 多线程与异常的关系</strong></p>
<p>看run方法签名，知道线程的异常都必须内部处理。<br>当run方法抛出非检测异常（RuntimeException或Error）时，负责该执行路径的Thread将终止，而其他线程无感知，理想情况下，多线程不抛出受检或非受检异常。</p>
<p><strong>关于dumpstack</strong>：</p>
<p>多线程程序中，每个线程都有自己的执行路径，也有自己的栈跟踪。要分析Thread的栈跟踪，调用Thread类的dumpStack方法，将其显示在标准错误流中（System.err)。<br>如果正常运行时执行该操作，显示Thread在其调用栈的当前位置。<br>如果产生异常，则显示标准异常栈跟踪。</p>
<p><strong>4.2 同步代码块中的异常</strong></p>
<p>比较正确的写法：除非保证不损坏同步块，决不抛出传到同步块意外的异常：</p>
<blockquote>
<p>try{<br>    synchronized(this){<br>    }<br>}catch(RuntimeException exc){</p>
<p>}</p>
</blockquote>
<h2 id="五、异常设计的最佳实践">五、异常设计的最佳实践</h2>
<ul>
<li>（1）在应用程序中，可根据潜在故障集来描述各个用例。可根据在运行程序中出现的可能性及严重程度，按层次定义这些故障。</li>
<li>（2）只解决对程序有重大影响且不可避免的问题和错误。</li>
<li>（3）方法只传递程序中需要广而告之的错误，或传递因为方法缺少上下文或资源而无法解决的错误。</li>
<li>（4）方法应根据使用者的角色和职责，以使用者可轻易理解的方式传递错误。</li>
<li>（5）方法仅在以下情况下抛出多个异常：<br>a.互相排斥（起因不同）<br>b.对使用者有不同作用<br>c.表示完全不同的故障</li>
<li>（6）在任何软件实体中（类、组件、系统、架构或API），异常都应称为实体合约（实体与外部的接口）的标准部分。</li>
</ul>
<h2 id="六、测试技术体系">六、测试技术体系</h2>
<p><strong>6.1 测试角色和职责</strong></p>
<ul>
<li>6.1.1 开发人员（TDD适合开发人员的单元测试，集成测试）<br>白盒：静态和动态测试，包括单元，集成，烟雾（smoke）和回归测试<br>体系结构：大多数测试形式，但有效性测试最好由用户来执行</li>
<li>6.1.2 测试人员<br>黑盒：大多数测试形式，特别是探索和基于风险的测试<br>系统结构：大多数测试形式</li>
<li>6.1.3 用户<br>黑盒：alpha，beta和用户满意度测试<br>体系结构：有效性测试</li>
</ul>
<h2 id="七、调试技术体系">七、调试技术体系</h2>
<p><strong>低级：code-resident技术</strong></p>
<ul>
<li>日志记录API</li>
<li>异常和错误</li>
<li>专用测试方法</li>
</ul>
<p><strong>中级：模式和架构技术</strong></p>
<ul>
<li>收集器（被动数据收集）</li>
<li>监控器（被动数据监控）</li>
<li>模仿器（主动被调用行为）</li>
<li>模拟器（主动调用行为）</li>
</ul>
<p><strong>高级：系统技术</strong></p>
<ul>
<li>体系结构测试方法和架构</li>
<li>基础结构收集方法</li>
<li>JPDA（java平台调试器体系结构）</li>
</ul>
<hr>
<p>参考：</p>
<ul>
<li>《Robust Java 中文版》:<a href="http://book.douban.com/subject/1681498/" target="_blank" rel="external">http://book.douban.com/subject/1681498/</a></li>
</ul>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code><span class="comment">Robust</span> <span class="comment">Java</span> <span class="comment">中文版</span><span class="literal">-</sp]]>
    </summary>
    
      <category term="读书笔记" scheme="http://vernonzheng.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="http://vernonzheng.com/tags/java/"/>
    
      <category term="读书笔记" scheme="http://vernonzheng.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux环境变量解疑]]></title>
    <link href="http://vernonzheng.com/2014/12/06/Linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%A7%A3%E7%96%91/"/>
    <id>http://vernonzheng.com/2014/12/06/Linux环境变量解疑/</id>
    <published>2014-12-06T09:02:59.000Z</published>
    <updated>2014-12-28T10:40:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、什么是环境变量">一、什么是环境变量</h2>
<pre><code>bash <span class="keyword">shell</span>用一个称为环境变量的特性来存储有关<span class="keyword">shell</span>会话和工作环境的信息。
</code></pre><p>环境变量有两类：<strong>全局变量</strong>和<strong>局部变量</strong>。<br>局部变量可以在这个shell进程和子进程中起作用，另创建一个shell，就无效了。</p>
<p><strong>1.1 显示环境变量</strong></p>
<ul>
<li>显示全局变量：printenv</li>
<li>显示局部变量：set</li>
</ul>
<p><strong>1.2 设置环境变量</strong></p>
<ul>
<li>设置局部变量：通过等号来给环境变量赋值，如</li>
</ul>
<blockquote>
<p>$test=testing<br>$echo $test<br>testing<br>$</p>
</blockquote>
<ul>
<li>设置全局变量：通过将局部变量导出为全局变量的方式，如</li>
</ul>
<blockquote>
<p>$echo $test<br>testing a long string<br>$export test<br>$bash<br>$echo $test<br>testing a long string<br>$</p>
</blockquote>
<p><strong>1.3 删除环境变量</strong></p>
<ul>
<li>局部变量：unset test</li>
<li>全局变量：unset test 需要注意的是：如果你是在子进程中删除一个全局环境变量，它只对子进程失效。全局环境变量在父进程仍然有效。</li>
</ul>
<h2 id="二、系统环境变量">二、系统环境变量</h2>
<p>linux启动启动一个bash shell时，默认情况下bash在几个文件中查找命令。这些文件称为启动文件，<strong>根据bash shell启动方式的不同，查找文件不同</strong>。</p>
<p>bash shell有三种方式：</p>
<h3 id="2-1_登陆时当做默认登陆shell">2.1 登陆时当做默认登陆shell</h3>
<p>会依次查找一下路径：</p>
<ul>
<li>/etc/profile</li>
<li>$HOME/.bash_profile</li>
<li>$HOME/.bash_login</li>
<li>$HOME/.profile</li>
</ul>
<p><strong>/etc/profile</strong>文件是系统上默认的bash shell的主启动文件。每个用户登陆都会执行这个启动文件，另外3个启动文件是用户专有的，可根据用户定制。</p>
<h3 id="2-2_作为非登陆shell的交互式shell">2.2 作为非登陆shell的交互式shell</h3>
<p>如果你的bash shell不是登陆系统时启动的，称为交互式shell。</p>
<p>交互式shell不会去访问/etc/profile文件，而会去用户的HOME目录检查<strong>.bashrc</strong>是否存在。</p>
<p><strong>.bashrc文件的作用</strong>：<br>有两个作用：</p>
<ul>
<li>一是查看/etc目录下的公用bashrc文件</li>
<li>二是为用户提供一个定制自己的命令别名和私有脚本函数的地方。<br>（默认的文件会设置一些环境变量，但一般它没有执行export命令让它们称为全局的。）</li>
</ul>
<p>记住，交互式shell的启动文件只会在每次有新的交互式shell启动时才运行，因此任何子shell都会自动执行这个交互式shell的启动文件。</p>
<p>还能看出，/etc/bashrc文件也会执行位于/etc/profile.d 目录下的那些应用专属的启动文件。</p>
<h3 id="2-3_作为运行脚本的非交互shell">2.3 作为运行脚本的非交互shell</h3>
<p>系统执行shell脚本时用的就是这种shell。</p>
<p>当你每次在系统上运行脚本时需要运行特定的启动命令。为了处理这种情况，bash shell提供了BASH_ENV环境变量。</p>
<p>当shell启动一个非交互式shell进程时，它会检查这个环境变量来查看要执行的启动文件。如果有指定，shell会执行文件里的命令。<br>（在linux发行版里，默认情况下这个环境变量并未设置。）</p>
<hr>
<p>参考：</p>
<ul>
<li>《Linux命令行与shell脚本编程大全》:<a href="http://book.douban.com/subject/11589828/" target="_blank" rel="external">http://book.douban.com/subject/11589828/</a></li>
</ul>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一、什么是环境变量">一、什么是环境变量</h2>
<pre><code>bash <span class="keyword">shell</span>用一个称为环境变量的特性来存储有关<span class="keyword">shell</span>会话和工作]]>
    </summary>
    
      <category term="linux" scheme="http://vernonzheng.com/tags/linux/"/>
    
      <category term="环境变量" scheme="http://vernonzheng.com/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
      <category term="linux" scheme="http://vernonzheng.com/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://vernonzheng.com/2014/12/01/hello-world/"/>
    <id>http://vernonzheng.com/2014/12/01/hello-world/</id>
    <published>2014-12-01T07:13:47.000Z</published>
    <updated>2014-12-18T02:47:14.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">trobuleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2>
<h3 id="Create_a_new_post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io]]>
    </summary>
    
  </entry>
  
</feed>
