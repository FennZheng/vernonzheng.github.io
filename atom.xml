<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Vernon Zheng 郑雪峰]]></title>
  <subtitle><![CDATA[tech | life | thinking | note]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://vernonzheng.com/"/>
  <updated>2015-02-08T06:56:14.506Z</updated>
  <id>http://vernonzheng.com/</id>
  
  <author>
    <name><![CDATA[Vernon Zheng]]></name>
    <email><![CDATA[kevonzheng@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[《快学scala》第十四章习题解答]]></title>
    <link href="http://vernonzheng.com/2015/02/08/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94/"/>
    <id>http://vernonzheng.com/2015/02/08/《快学scala》第十四章习题解答/</id>
    <published>2015-02-08T05:15:42.000Z</published>
    <updated>2015-02-08T06:56:07.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第十四章_模式匹配和样例类">第十四章 模式匹配和样例类</h2>
<p><strong>14.1</strong><br>JDK发行包有一个src.zip文件包含了JDK的大多数源代码。解压并搜索样例标签(用正则表达式case [^:]+:)。然后查找以//开头并包含[Ff]alls?thr的注释，捕获类似// Falls through或// just fall thru这样的注释。假定JDK的程序员们遵守Java编码习惯，在该写注释的地方写下了这些注释，有多少百分比的样例是会掉入到下一个分支的？</p>
<p>略</p>
<p><strong>14.2</strong><br>利用模式匹配，编写一个swap函数，接受一个整数的对偶，返回对偶的两个组成部件互换位置的新对偶</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> swap[S,T](tup: (S,T))={</div><div class="line">  tup <span class="keyword">match</span>{</div><div class="line">    <span class="keyword">case</span> (a,b) =&gt; (b,a)</div><div class="line">  }</div><div class="line">}</div><div class="line">println(swap[String,Int]((<span class="string">"1"</span>,<span class="number">2</span>)))</div></pre></td></tr></table></figure>

<p><strong>14.3</strong><br>利用模式匹配，编写一个swap函数，交换数组中的前两个元素的位置，前提条件是数组长度至少为2</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> swap(array:Array[Any])={</div><div class="line">  array <span class="keyword">match</span>{</div><div class="line">    <span class="keyword">case</span> Array(first,second,rest @_*)=&gt; Array(second,first)++rest</div><div class="line">    <span class="keyword">case</span> _ =&gt; array</div><div class="line">  }</div><div class="line">}</div><div class="line">println(swap(Array(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>)).mkString)</div></pre></td></tr></table></figure>

<p><strong>14.4</strong><br>添加一个样例类Multiple，作为Item的子类。举例来说，Multiple(10,Article(“Blackwell Toster”,29.95))描述的是10个烤面包机。当然了，你应该可以在第二个参数的位置接受任何Item，无论是Bundle还是另一个Multiple。扩展price函数以应对新的样例。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Multiple</span><span class="params">(num : Int,item : Item)</span> <span class="keyword">extends</span> <span class="title">Item</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Article</span><span class="params">(description : String , price : Double)</span> <span class="keyword">extends</span> <span class="title">Item</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Bundle</span><span class="params">(description : String , discount : Double , item : Item*)</span> <span class="keyword">extends</span> <span class="title">Item</span></span></div><div class="line"></div><div class="line"><span class="keyword">def</span> price(it : Item) : Double = it <span class="keyword">match</span> {</div><div class="line">  <span class="keyword">case</span> Article(_,p) =&gt; p</div><div class="line">  <span class="keyword">case</span> Bundle(_,disc,its @ _*) =&gt; its.map(price _).sum - disc</div><div class="line">  <span class="keyword">case</span> Multiple(n,it) =&gt; n * price(it)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">val</span> p = price(Multiple(<span class="number">10</span>,Article(<span class="string">"Blackwell Toster"</span>,<span class="number">29.95</span>)))</div><div class="line">println(p)</div></pre></td></tr></table></figure>

<p><strong>14.5</strong><br>我们可以用列表制作只在叶子节点存放值的树。举例来说，列表((3 8) 2 (5))描述的是如下这样一棵树:<br>      *<br>    / | \</p>
<ul>
<li>2  *<br>/  \    |<br>3   8    5<br>不过，有些列表元素是数字，而另一些是列表。在Scala中，你不能拥有异构的列表，因此你必须使用List[Any]。编写一个leafSum函数，计算所有叶子节点中的元素之和，用模式匹配来区分数字和列表。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> leafSum(list:List[Any]):Int={</div><div class="line">  <span class="keyword">var</span> total = <span class="number">0</span></div><div class="line">  list.foreach {</div><div class="line">    lst =&gt;</div><div class="line">      lst <span class="keyword">match</span> {</div><div class="line">        <span class="keyword">case</span> l: List[Any] =&gt; total += leafSum(l)</div><div class="line">        <span class="keyword">case</span> i: Int =&gt; total += i</div><div class="line">      }</div><div class="line">  }</div><div class="line">  total</div><div class="line">}</div><div class="line"><span class="keyword">val</span> l: List[Any] = List(List(<span class="number">3</span>, <span class="number">8</span>), <span class="number">2</span>, List(<span class="number">5</span>))</div><div class="line"></div><div class="line">println(leafSum(l))</div></pre></td></tr></table></figure>

<p><strong>14.6</strong><br>制作这样的树更好的做法是使用样例类。我们不妨从二叉树开始。<br>sealed abstract class BinaryTree<br>case class Leaf(value : Int) extends BinaryTree<br>case class Node(left : BinaryTree,right : BinaryTree) extends BinaryTree<br>编写一个函数计算所有叶子节点中的元素之和。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Leaf</span><span class="params">(value : Int)</span> <span class="keyword">extends</span> <span class="title">BinaryTree</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Node</span><span class="params">(left: BinaryTree, right:BinaryTree)</span> <span class="keyword">extends</span> <span class="title">BinaryTree</span></span></div><div class="line"></div><div class="line"><span class="keyword">def</span> leafSum(tree:BinaryTree):Int={</div><div class="line">  tree <span class="keyword">match</span> {</div><div class="line">    <span class="keyword">case</span> Node(a,b) =&gt; leafSum(a) + leafSum(b)</div><div class="line">    <span class="keyword">case</span> Leaf(v) =&gt; v</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">val</span> r = Node(Leaf(<span class="number">3</span>),Node(Leaf(<span class="number">3</span>),Leaf(<span class="number">9</span>)))</div><div class="line"></div><div class="line">println(leafSum(r))</div></pre></td></tr></table></figure>

<p><strong>13.7</strong><br>扩展前一个练习中的树，使得每个节点可以有任意多的后代，并重新实现leafSum函数。第五题中的树应该能够通过下述代码表示：<br>Node(Node(Leaf(3),Leaf(8)),Leaf(2),Node(Leaf(5)))</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Leaf</span><span class="params">(value: Int)</span> <span class="keyword">extends</span> <span class="title">BinaryTree</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Node</span><span class="params">(tr: BinaryTree*)</span> <span class="keyword">extends</span> <span class="title">BinaryTree</span></span></div><div class="line"></div><div class="line"><span class="keyword">def</span> leafSum(tree:BinaryTree):Int={</div><div class="line">  tree <span class="keyword">match</span> {</div><div class="line">    <span class="keyword">case</span> Node(r @_*) =&gt; r.map(leafSum).sum</div><div class="line">    <span class="keyword">case</span> Leaf(v) =&gt; v</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">val</span> r = Node(Node(Leaf(<span class="number">3</span>), Leaf(<span class="number">8</span>)), Leaf(<span class="number">2</span>), Node(Leaf(<span class="number">5</span>)))</div><div class="line"></div><div class="line">println(leafSum(r))</div></pre></td></tr></table></figure>

<p><strong>13.8</strong><br>扩展前一个练习中的树，使得每个非叶子节点除了后代之外，能够存放一个操作符。然后编写一个eval函数来计算它的值。举例来说：<br>      +<br>    / | \</p>
<ul>
<li>2  -<br>/  \    |<br>3   8    5<br>上面这棵树的值为(3 * 8) + 2 + (-5) = 21</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Leaf</span><span class="params">(value: Int)</span> <span class="keyword">extends</span> <span class="title">BinaryTree</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Node</span><span class="params">(op: Char, leafs: BinaryTree*)</span> <span class="keyword">extends</span> <span class="title">BinaryTree</span></span></div><div class="line"></div><div class="line"><span class="keyword">def</span> eval(tree:BinaryTree):Int= {</div><div class="line">  tree <span class="keyword">match</span> {</div><div class="line">    <span class="keyword">case</span> Node(op, leafs@_*) =&gt; op <span class="keyword">match</span> {</div><div class="line">      <span class="keyword">case</span> '+' =&gt; leafs.map(eval _).sum</div><div class="line">      <span class="keyword">case</span> '-' =&gt; -leafs.map(eval _).sum</div><div class="line">      <span class="keyword">case</span> '*' =&gt; leafs.map(eval _).product</div><div class="line">    }</div><div class="line">    <span class="keyword">case</span> Leaf(x) =&gt; x</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line">  <span class="keyword">val</span> x = Node('+', Node('*', Leaf(<span class="number">3</span>), Leaf(<span class="number">8</span>)), Leaf(<span class="number">2</span>),  Node('-', Leaf(<span class="number">5</span>)))</div><div class="line"></div><div class="line">  println(x)</div><div class="line">  println(eval(x))</div></pre></td></tr></table></figure>

<p><strong>14.9</strong><br>编写一个函数，计算List[Option[Int]]中所有非None值之和。不得使用match语句。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> sum(lst: List[Option[Int]]) = lst.map(_.getOrElse(<span class="number">0</span>)).sum</div><div class="line"></div><div class="line"><span class="keyword">val</span> x = List(Some(<span class="number">1</span>), None, Some(<span class="number">2</span>), None, Some(<span class="number">3</span>))</div><div class="line"></div><div class="line">println(sum(x))</div></pre></td></tr></table></figure>

<p><strong>14.10</strong><br>编写一个函数，将两个类型为Double=&gt;Option[Double]的函数组合在一起，产生另一个同样类型的函数。如果其中一个函数返回None，则组合函数也应返回None。例如：<br>def f(x : Double) = if ( x &gt;= 0) Some(sqrt(x)) else None<br>def g(x : Double) = if ( x != 1) Some( 1 / ( x - 1)) else None<br>val h = compose(f,g)<br>h(2)将得到Some(1)，而h(1)和h(0)将得到None</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> compose(f:Double=&gt;Option[Double],g:Double=&gt;Option[Double])={</div><div class="line">  (x : Double) =&gt;</div><div class="line">    <span class="keyword">if</span> (f(x) == None || g(x) == None) None</div><div class="line">    <span class="keyword">else</span> g(x)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">import</span> scala.math.sqrt</div><div class="line"></div><div class="line"><span class="keyword">def</span> f(x : Double) = <span class="keyword">if</span> ( x &gt;= <span class="number">0</span>) Some(sqrt(x)) <span class="keyword">else</span> None</div><div class="line"><span class="keyword">def</span> g(x : Double) = <span class="keyword">if</span> ( x != <span class="number">1</span>) Some( <span class="number">1</span> / ( x - <span class="number">1</span>)) <span class="keyword">else</span> None</div><div class="line"><span class="keyword">val</span> h = compose(f,g)</div><div class="line"></div><div class="line">println(h(<span class="number">2</span>))</div></pre></td></tr></table></figure>

<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第十三章习题解答]]></title>
    <link href="http://vernonzheng.com/2015/02/07/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94/"/>
    <id>http://vernonzheng.com/2015/02/07/《快学scala》第十三章习题解答/</id>
    <published>2015-02-07T07:36:42.000Z</published>
    <updated>2015-02-07T16:29:04.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第十三章_集合">第十三章 集合</h2>
<p><strong>13.1</strong><br>编写一个函数，给定字符串，产出一个包含所有字符的下标的映射。举例来说：indexes(“Mississippi”)应返回一个映射，让’M’对应集{0}，’i’对应集{1,4,7,10}，依此类推。使用字符到可变集的映射。另外，你如何保证集是经过排序的？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> mapStrIndex(str:String)={</div><div class="line">  <span class="keyword">var</span> indexMap = <span class="keyword">new</span> HashMap[Char,SortedSet[Int]]()</div><div class="line">  <span class="keyword">var</span> i = <span class="number">0</span></div><div class="line">  str.toCharArray.foreach {</div><div class="line">    c =&gt;</div><div class="line">      indexMap.get(c) <span class="keyword">match</span> {</div><div class="line">        <span class="keyword">case</span> Some(result) =&gt; indexMap(c) = result + i</div><div class="line">        <span class="keyword">case</span> None =&gt; indexMap += (c -&gt; SortedSet {</div><div class="line">          i</div><div class="line">        })</div><div class="line">      }</div><div class="line">      i += <span class="number">1</span></div><div class="line">  }</div><div class="line">  indexMap</div><div class="line"></div><div class="line">}</div><div class="line">println(mapStrIndex(<span class="string">"Mississippi"</span>))</div></pre></td></tr></table></figure>

<p><strong>13.2</strong><br>重复前一个练习，这次用字符到列表的不可变映射。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">mport scala.collection.mutable.{ListBuffer, HashMap}</div><div class="line"><span class="keyword">def</span> mapStrIndex(str:String)={</div><div class="line">  <span class="keyword">var</span> indexMap = <span class="keyword">new</span> HashMap[Char,ListBuffer[Int]]()</div><div class="line">  <span class="keyword">var</span> i = <span class="number">0</span></div><div class="line">  str.toCharArray.foreach {</div><div class="line">    c =&gt;</div><div class="line">      indexMap.get(c) <span class="keyword">match</span> {</div><div class="line">        <span class="keyword">case</span> Some(result) =&gt; result += i</div><div class="line">        <span class="keyword">case</span> None =&gt; indexMap += (c -&gt; ListBuffer {</div><div class="line">          i</div><div class="line">        })</div><div class="line">      }</div><div class="line">      i += <span class="number">1</span></div><div class="line">  }</div><div class="line">  indexMap</div><div class="line"></div><div class="line">}</div><div class="line">println(mapStrIndex(<span class="string">"Mississippi"</span>))</div></pre></td></tr></table></figure>

<p><strong>13.3</strong><br>编写一个函数，从一个整型链表中去除所有的零值。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> removeZero(list:List[Int]):List[Int]={</div><div class="line">  list.filter(_!=<span class="number">0</span>)</div><div class="line">}</div><div class="line">println(removeZero(List(<span class="number">3</span>,<span class="number">25</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>)))</div></pre></td></tr></table></figure>

<p><strong>13.4</strong><br>编写一个函数，接受一个字符串的集合，以及一个从字符串到整数值的映射。返回整型的集合，其值为能和集合中某个字符串相对应的映射的值。举例来说，给定Array(“Tom”,”Fred”,”Harry”)和Map(“Tom”-&gt;3,”Dick”-&gt;4,”Harry”-&gt;5)，返回Array(3,5)。提示：用flatMap将get返回的Option值组合在一起</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> filterMap(array:Array[String],map:Map[String,Int]):Array[Int]={</div><div class="line">  array.flatMap(map.get(_))</div><div class="line">}</div><div class="line">println(filterMap(Array(<span class="string">"Tom"</span>,<span class="string">"Fred"</span>,<span class="string">"Harry"</span>),Map(<span class="string">"Tom"</span>-&gt;<span class="number">3</span>,<span class="string">"Dick"</span>-&gt;<span class="number">4</span>,<span class="string">"Harry"</span>-&gt;<span class="number">5</span>)).mkString(<span class="string">","</span>))</div></pre></td></tr></table></figure>

<p><strong>13.5</strong><br>实现一个函数，作用与mkString相同，使用reduceLeft。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> collection.mutable</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">MktString</span></span>{</div><div class="line">  <span class="keyword">this</span>:mutable.Iterable[String]=&gt;</div><div class="line">  <span class="keyword">def</span> mktString(split:String=<span class="string">""</span>) = <span class="keyword">if</span>( <span class="keyword">this</span> != Nil) <span class="keyword">this</span>.reduceLeft(_ + split + _)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> mutable.HashSet[String] <span class="keyword">with</span> MktString</div><div class="line">test += <span class="string">"1"</span></div><div class="line">test += <span class="string">"2"</span></div><div class="line">test += <span class="string">"3"</span></div><div class="line">println(test.mktString(<span class="string">","</span>))</div></pre></td></tr></table></figure>

<p><strong>13.6</strong><br>给定整型列表lst,(lst :\ List<a href="">Int</a>)(<em> :: </em> )得到什么?(List<a href="">Int</a> /: lst)(<em> :+ </em>)又得到什么？如何修改它们中的一个，以对原列表进行反向排序？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> lst = List(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</div><div class="line">println((lst :\ List[Int]())(_ :: _))</div><div class="line">println((List[Int]() /: lst)(_ :+ _))</div><div class="line">println((List[Int]() /: lst)((a,b) =&gt; b :: a))</div></pre></td></tr></table></figure>

<p><strong>13.7</strong><br>在13.11节中，表达式(prices zip quantities) map { p =&gt; p.<em>1 * p._2}有些不够优雅。我们不能用(prices zip quantities) map { </em> <em> <em>}，因为 </em> </em> _ 是一个带两个参数的函数，而我们需要的是一个带单个类型为元组的参数的函数，Function对象的tupled方法可以将带两个参数的函数改为以元俎为参数的函数。将tupled应用于乘法函数，以使我们可以用它来映射由对偶组成的列表。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> prices = List(<span class="number">5.0</span>,<span class="number">20.0</span>,<span class="number">9.95</span>)</div><div class="line"><span class="keyword">val</span> quantities = List(<span class="number">10</span>,<span class="number">2</span>,<span class="number">1</span>)</div><div class="line">println((prices zip quantities) map { Function.tupled(_ * _) })</div></pre></td></tr></table></figure>

<p><strong>13.8</strong><br>编写一个函数。将Double数组转换成二维数组。传入列数作为参数。举例来说，Array(1,2,3,4,5,6)和三列，返回Array(Array(1,2,3),Array(4,5,6))。用grouped方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> divArr(arr:Array[Double],i:Int)={</div><div class="line">  arr.grouped(i).toArray</div><div class="line">}</div><div class="line"><span class="keyword">val</span> arr = Array(<span class="number">1.0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</div><div class="line">divArr(arr,<span class="number">3</span>).foreach(a =&gt; println(a.mkString(<span class="string">","</span>)))</div></pre></td></tr></table></figure>

<p><strong>13.9</strong><br>Harry Hacker写了一个从命令行接受一系列文件名的程序。对每个文件名，他都启动一个新的线程来读取文件内容并更新一个字母出现频率映射，声明为：<br>val frequencies = new scala.collection.multable.HashMap[Char,Int] with scala.collection.mutable.SynchronizedMap[Char,Int]<br>当读到字母c时，他调用<br>frequencies(c) = frequencies.getOrElse(c,0) + 1<br>为什么这样做得不到正确答案？如果他用如下方式实现呢：<br>import scala.collection.JavaConversions.asScalaConcurrentMap<br>val frequencies:scala.collection.mutable.ConcurrentMap[Char,Int] = new java.util.concurrent.ConcurrentHashMap[Char,Int]</p>
<p>并发问题，并发修改集合不安全。</p>
<p><strong>13.10</strong><br>Harry Hacker把文件读取到字符串中，然后想对字符串的不同部分用并行集合来并发地更新字母出现频率映射。他用了如下代码：<br>val frequencies = new scala.collection.mutable.HashMap[Char,Int]<br>for(c &lt;- str.par) frequencies(c) = frequencies.getOrElse(c,0) + 1<br>为什么说这个想法很糟糕？要真正地并行化这个计算，他应该怎么做呢？（提示：用aggregate） 并行修改共享变量，结果无法估计。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.collection.immutable.HashMap</div><div class="line"></div><div class="line"><span class="keyword">val</span> str = <span class="string">"abdcsdcd"</span></div><div class="line"><span class="keyword">val</span> frequencies = str.par.aggregate(HashMap[Char,Int]())(</div><div class="line">  {</div><div class="line">    (a,b) =&gt;</div><div class="line">      a + (b -&gt; (a.getOrElse(b,<span class="number">0</span>) + <span class="number">1</span>))</div><div class="line">  }</div><div class="line">  ,</div><div class="line">  {</div><div class="line">    (map1,map2) =&gt;</div><div class="line">      (map1.keySet ++ map2.keySet).foldLeft( HashMap[Char,Int]() ) {</div><div class="line">        (result,k) =&gt;</div><div class="line">          result + ( k -&gt; ( map1.getOrElse(k,<span class="number">0</span> ) + map2.getOrElse(k,<span class="number">0</span>) ) )</div><div class="line">      }</div><div class="line">  }</div><div class="line">)</div></pre></td></tr></table></figure>

<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第十二章习题解答]]></title>
    <link href="http://vernonzheng.com/2015/02/04/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94/"/>
    <id>http://vernonzheng.com/2015/02/04/《快学scala》第十二章习题解答/</id>
    <published>2015-02-04T14:11:42.000Z</published>
    <updated>2015-02-05T15:02:59.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第十二章_高阶函数">第十二章 高阶函数</h2>
<p><strong>12.1</strong><br>编写函数values(fun:(Int)=&gt;Int,low:Int,high:Int),该函数输出一个集合，对应给定区间内给定函数的输入和输出。比如，values(x=&gt;x*x,-5,5)应该产出一个对偶的集合(-5,25),(-4,16),(-3,9),…,(5,25)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> values(fun:(Int)=&gt;Int,low:Int,high:Int) ={</div><div class="line">  <span class="keyword">var</span> array = List[(Int,Int)]()</div><div class="line">  low to high foreach {</div><div class="line">    x =&gt;</div><div class="line">      array = (x, fun(x)) :: array</div><div class="line">  }</div><div class="line">  array</div><div class="line">}</div><div class="line">println(values(x =&gt; x * x, -<span class="number">5</span>, <span class="number">5</span>).mkString)</div></pre></td></tr></table></figure>

<p><strong>12.2</strong><br>如何用reduceLeft得到数组中的最大元素?</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> arr = Array(<span class="number">1</span>,<span class="number">333</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">32</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">2</span>)</div><div class="line">print(arr.reduceLeft((l,r)=&gt;<span class="keyword">if</span>(l&gt;=r) l <span class="keyword">else</span> r))</div></pre></td></tr></table></figure>

<p><strong>12.3</strong><br>用to和reduceLeft实现阶乘函数,不得使用循环或递归 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> factorial(n:Int): Unit ={</div><div class="line">  <span class="number">1</span> to n reduceLeft(_ * _)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>12.4</strong><br>前一个实现需要处理一个特殊情况，即n&lt;1的情况。展示如何用foldLeft来避免这个需要。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> factorial(n:Int) = (<span class="number">1</span> to n).foldLeft(<span class="number">1</span>)(_ * _)</div><div class="line"></div><div class="line">factorial(-<span class="number">3</span>)</div><div class="line">factorial(<span class="number">3</span>)</div></pre></td></tr></table></figure>

<p><strong>12.5</strong><br>编写函数largest(fun:(Int)=&gt;Int,inputs:Seq[Int]),输出在给定输入序列中给定函数的最大值。举例来说，largest(x=&gt;10<em>x-x</em>x,1 to 10)应该返回25.不得使用循环或递归 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> largest1(fun:(Int)=&gt;Int, inputs:Seq[Int]) = inputs.foldLeft(<span class="number">1</span>)((a,b)=&gt; <span class="keyword">if</span>(fun(b)&gt;a) fun(b) <span class="keyword">else</span> a)</div><div class="line"></div><div class="line"><span class="keyword">def</span> largest2(fun:(Int)=&gt;Int, inputs:Seq[Int]) = inputs.map(fun(_)).max</div><div class="line"></div><div class="line">println(largest1(x =&gt; <span class="number">10</span> * x - x * x, <span class="number">1</span> to <span class="number">10</span>))</div><div class="line">println(largest2(x =&gt; <span class="number">10</span> * x - x * x, <span class="number">1</span> to <span class="number">10</span>))</div></pre></td></tr></table></figure>

<p><strong>12.6</strong><br>修改前一个函数，返回最大的输出对应的输入。举例来说,largestAt(fun:(Int)=&gt;Int,inputs:Seq[Int])应该返回5。不得使用循环或递归 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> largestAt1(fun:(Int)=&gt;Int, inputs:Seq[Int]) = inputs.reduce((a,b)=&gt; <span class="keyword">if</span>(fun(b)&gt;fun(a)) b <span class="keyword">else</span> a)</div><div class="line"></div><div class="line"><span class="keyword">def</span> largestAt2(fun: (Int) =&gt; Int, inputs: Seq[Int]) = inputs.map(x =&gt; (x, fun(x))).reduceLeft((x,y) =&gt; <span class="keyword">if</span> (x._2 &gt; y._2) x <span class="keyword">else</span> y)._1</div><div class="line"></div><div class="line">println(largestAt1(x =&gt; <span class="number">10</span> * x - x * x, <span class="number">1</span> to <span class="number">10</span>))</div><div class="line">println(largestAt2(x =&gt; <span class="number">10</span> * x - x * x, <span class="number">1</span> to <span class="number">10</span>))</div></pre></td></tr></table></figure>

<p><strong>12.7</strong><br>要得到一个序列的对偶很容易，比如:<br>val pairs = (1 to 10) zip (11 to 20)<br>假定你想要对这个序列做某中操作—比如，给对偶中的值求和，但是你不能直接使用:</p>
<p>pairs.map(<em> + </em>)<br>函数<em> + </em> 接受两个Int作为参数，而不是(Int,Int)对偶。编写函数adjustToPair,该函数接受一个类型为(Int,Int)=&gt;Int的函数作为参数，并返回一个等效的, 可以以对偶作为参数的函数。举例来说就是:adjustToPair(<em> * </em>)((6,7))应得到42。然后用这个函数通过map计算出各个对偶的元素之和</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> ajustToPair(fun: (Int, Int) =&gt; Int) = (x: (Int, Int)) =&gt; fun(x._1, x._2)</div><div class="line"></div><div class="line"><span class="keyword">val</span> x = ajustToPair(_ * _)((<span class="number">6</span>, <span class="number">7</span>))</div><div class="line">println(x)</div><div class="line"></div><div class="line"><span class="keyword">val</span> pairs = (<span class="number">1</span> to <span class="number">10</span>) zip (<span class="number">11</span> to <span class="number">20</span>)</div><div class="line">println(pairs)</div><div class="line"></div><div class="line"><span class="keyword">val</span> y = pairs.map(ajustToPair(_ + _))</div><div class="line">println(y)</div></pre></td></tr></table></figure>

<p><strong>12.8</strong><br>在12.8节中，你看到了用于两组字符串数组的corresponds方法。做出一个对该方法的调用，让它帮我们判断某个字符串数组里的所有元素的长度是否和某个给定的整数数组相对应 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = Array(<span class="string">"asd"</span>,<span class="string">"df"</span>,<span class="string">"abcd"</span>)</div><div class="line"><span class="keyword">val</span> b = Array(<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>)</div><div class="line"><span class="keyword">val</span> c = Array(<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)</div><div class="line"></div><div class="line">println(a.corresponds(b)(_.length == _))</div><div class="line">println(a.corresponds(c)(_.length == _))</div></pre></td></tr></table></figure>

<p><strong>12.9</strong><br>不使用柯里化实现corresponds。然后尝试从前一个练习的代码来调用。你遇到了什么问题？</p>
<p>没有柯里化则不能使用前一个练习里的代码方式来调用</p>
<p><strong>12.10</strong><br>实现一个unless控制抽象，工作机制类似if,但条件是反过来的。第一个参数需要是换名调用的参数吗？你需要柯里化吗？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> unless(condition: =&gt; Boolean)(block: =&gt; Unit) { <span class="keyword">if</span> (!condition) { block } }</div><div class="line"></div><div class="line">unless (<span class="number">0</span> &gt; <span class="number">1</span>) { println(<span class="string">"Unless!"</span>) }</div></pre></td></tr></table></figure>

<p>需要换名和柯里化</p>
<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第十一章习题解答]]></title>
    <link href="http://vernonzheng.com/2015/02/03/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94/"/>
    <id>http://vernonzheng.com/2015/02/03/《快学scala》第十一章习题解答/</id>
    <published>2015-02-03T10:40:42.000Z</published>
    <updated>2015-02-03T15:55:29.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第十一章_操作符">第十一章 操作符</h2>
<p><strong>11.1</strong><br>根据优先级规则,3 + 4 -&gt; 5和3 -&gt; 4 + 5是如何被求值的？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="number">3</span>+<span class="number">4</span>-&gt;<span class="number">5</span></div><div class="line">res0: (Int, Int) = (<span class="number">7</span>,<span class="number">5</span>)</div><div class="line"></div><div class="line">scala&gt; <span class="number">3</span>-&gt;<span class="number">4</span>+<span class="number">5</span></div><div class="line">&lt;console&gt;:<span class="number">8</span>: error: <span class="keyword">type</span> mismatch;</div><div class="line"> found   : Int(<span class="number">5</span>)</div><div class="line"> required: String</div><div class="line">              <span class="number">3</span>-&gt;<span class="number">4</span>+<span class="number">5</span></div><div class="line">                   ^</div></pre></td></tr></table></figure>

<p><strong>11.2</strong><br>BigInt类有一个pow方法,但没有用操作符字符。Scala类库的设计者为什么没有选用**(像Fortran那样)或者^(像Pascal那样)作为乘方操作符呢？</p>
<p>Scala中的操作符就是方法，其优先级是根据首字母来判断的，优先级如下<br>最高优先级:除以下字符外的操作符字符</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">* / % </div><div class="line">+ - </div><div class="line">: </div><div class="line">= ! </div><div class="line">&lt; &gt; </div><div class="line">& </div><div class="line">ˆ </div><div class="line">| </div><div class="line">非操作符</div><div class="line">最低优先级:赋值操作符</div></pre></td></tr></table></figure>

<p>一般乘方的操作符是优于乘法操作的，如果使用<em>*作为乘方的话，那么其优先级则与</em>相同，而如果使用^的话，则优先级低于*操作。优先级都是有问题的。故没有使用这两种操作符</p>
<p><strong>11.3</strong><br>实现Fraction类，支持+<em>/操作。支持约分，例如将15/-6变为-5/2。除以最大公约数,像这样:<br>class Fraction(n:Int,d:Int){<br>    private val num:Int = if(d==0) 1 else n </em> sign(d)/gcd(n,d);<br>    private val den:Int = if(d==0) 0 else d * sign(d)/gcd(n,d);<br>    override def toString = num + “/“ + den<br>    def sign(a:Int) = if(a &gt; 0) 1 else if (a &lt; 0) -1 else 0<br>    def gcd(a:Int,b:Int):Int = if(b==0) abs(a) else gcd(b,a%b)<br>    …<br>}</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">mport scala.math.abs</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span><span class="params">(n: Int, d: Int)</span> </span>{</div><div class="line">  <span class="keyword">private</span> <span class="keyword">val</span> num: Int = <span class="keyword">if</span> (d == <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> n * sign(d) / gcd(n, d);</div><div class="line">  <span class="keyword">private</span> <span class="keyword">val</span> den: Int = <span class="keyword">if</span> (d == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> d * sign(d) / gcd(n, d);</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> toString = num + <span class="string">"/"</span> + den</div><div class="line"></div><div class="line">  <span class="keyword">def</span> sign(a: Int) = <span class="keyword">if</span> (a &gt; <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="keyword">if</span> (a &lt; <span class="number">0</span>) -<span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></div><div class="line"></div><div class="line">  <span class="keyword">def</span> gcd(a: Int, b: Int): Int = <span class="keyword">if</span> (b == <span class="number">0</span>) abs(a) <span class="keyword">else</span> gcd(b, a % b)</div><div class="line"></div><div class="line">  <span class="keyword">def</span> +(other:Fraction):Fraction={</div><div class="line">    newFraction((<span class="keyword">this</span>.num * other.den) + (other.num * <span class="keyword">this</span>.den),<span class="keyword">this</span>.den * other.den)</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> -(other:Fraction):Fraction={</div><div class="line">    newFraction((<span class="keyword">this</span>.num * other.den) - (other.num * <span class="keyword">this</span>.den),<span class="keyword">this</span>.den * other.den)</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> *(other:Fraction):Fraction={</div><div class="line">    newFraction(<span class="keyword">this</span>.num * other.num,<span class="keyword">this</span>.den * other.den)</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> /(other:Fraction):Fraction={</div><div class="line">    newFraction(<span class="keyword">this</span>.num * other.den,<span class="keyword">this</span>.den * other.num)</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">def</span> newFraction(a:Int,b:Int):Fraction={</div><div class="line">    <span class="keyword">val</span> x:Int = <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> a * sign(b) / gcd(a, b)</div><div class="line">    <span class="keyword">val</span> y:Int = <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> b * sign(b) / gcd(a, b)</div><div class="line">    <span class="keyword">new</span> Fraction(x,y)</div><div class="line">  }</div><div class="line">}</div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>{</div><div class="line">  <span class="keyword">val</span> f = <span class="keyword">new</span> Fraction(<span class="number">15</span>,-<span class="number">6</span>)</div><div class="line">  <span class="keyword">val</span> p = <span class="keyword">new</span> Fraction(<span class="number">20</span>,<span class="number">60</span>)</div><div class="line">  println(f)</div><div class="line">  println(p)</div><div class="line">  println(f + p)</div><div class="line">  println(f - p)</div><div class="line">  println(f * p)</div><div class="line">  println(f / p)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>11.4</strong><br>实现一个Money类,加入美元和美分字段。提供+,-操作符以及比较操作符==和&lt;。举例来说，Money(1,75)+Money(0,50)==Money(2,25)应为true。你应该同时提供*和/操作符吗？为什么？</p>
<p>不需要提供，金额的乘除没有实际意义。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Money</span><span class="params">(dollar:Int,cent:Int)</span></span>{</div><div class="line">  <span class="keyword">def</span> + (other:Money):Money = {</div><div class="line">    <span class="keyword">val</span> (a,b) = (<span class="keyword">this</span>.cent + other.cent) % <span class="number">100</span></div><div class="line">    <span class="keyword">new</span> Money(<span class="keyword">this</span>.dollar + other.dollar + a,b)</div><div class="line">  }</div><div class="line">  <span class="keyword">def</span> -(other:Money):Money={</div><div class="line">    <span class="keyword">val</span> (d,c) = (<span class="keyword">this</span>.toCent() - other.toCent()) % <span class="number">100</span></div><div class="line">    <span class="keyword">new</span> Money(d,c)</div><div class="line">  }</div><div class="line">  <span class="keyword">def</span> ==(other:Money):Boolean = <span class="keyword">this</span>.dollar == other.dollar && <span class="keyword">this</span>.cent == other.cent</div><div class="line"></div><div class="line">  <span class="keyword">def</span> &lt;(other:Money):Boolean = <span class="keyword">this</span>.dollar &lt; other.dollar || (<span class="keyword">this</span>.dollar == other.dollar && <span class="keyword">this</span>.cent &lt; other.cent)</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> toString = <span class="string">"dollar = "</span> + dollar + <span class="string">" cent = "</span> + cent</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">def</span> toCent()={</div><div class="line">    <span class="keyword">this</span>.dollar * <span class="number">100</span> + <span class="keyword">this</span>.cent</div><div class="line">  }</div><div class="line">}</div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Money</span></span>{</div><div class="line">  <span class="keyword">def</span> apply(dollar:Int, cent:Int): Money ={</div><div class="line">    <span class="keyword">new</span> Money(dollar,cent)</div><div class="line">  }</div><div class="line">  <span class="keyword">def</span> main(args:Array[String]){</div><div class="line"></div><div class="line">    <span class="keyword">val</span> m1 = Money(<span class="number">1</span>,<span class="number">200</span>)</div><div class="line">    <span class="keyword">val</span> m2 = Money(<span class="number">2</span>,<span class="number">2</span>)</div><div class="line">    println(m1 + m2)</div><div class="line">    println(m1 - m2)</div><div class="line">    println(m1 == m2)</div><div class="line">    println(m1 &lt; m2)</div><div class="line">    println(Money(<span class="number">1</span>,<span class="number">75</span>)+Money(<span class="number">0</span>,<span class="number">50</span>))</div><div class="line">    println(Money(<span class="number">1</span>,<span class="number">75</span>)+Money(<span class="number">0</span>,<span class="number">50</span>)==Money(<span class="number">2</span>,<span class="number">25</span>))</div><div class="line"></div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>11.5</strong><br>提供操作符用于构造HTML表格。例如:Table() | “Java” | “Scala” || “Gosling” | “Odersky” || “JVM” | “JVM,.NET”应产出:<table><tr><td>Java</td></tr><td>Scala</td><tr><td>Gosling…</td></tr></table></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Table</span></span>{</div><div class="line"></div><div class="line">  <span class="keyword">var</span> s:String = <span class="string">""</span></div><div class="line"></div><div class="line">  <span class="keyword">def</span> |(str:String):Table={</div><div class="line">    <span class="keyword">val</span> t = Table()</div><div class="line">    t.s = <span class="keyword">this</span>.s + <span class="string">"&lt;td&gt;"</span> + str + <span class="string">"&lt;/td&gt;"</span></div><div class="line">    t</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> ||(str:String):Table={</div><div class="line">    <span class="keyword">val</span> t = Table()</div><div class="line">    t.s = <span class="keyword">this</span>.s + <span class="string">"&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;"</span> + str + <span class="string">"&lt;/td&gt;"</span></div><div class="line">    t</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> toString():String={</div><div class="line">    <span class="string">"&lt;table&gt;&lt;tr&gt;"</span> + <span class="keyword">this</span>.s + <span class="string">"&lt;/tr&gt;&lt;/table&gt;"</span></div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Table</span></span>{</div><div class="line"></div><div class="line">  <span class="keyword">def</span> apply():Table={</div><div class="line">    <span class="keyword">new</span> Table()</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> main(args: Array[String]) {</div><div class="line">    println(Table() | <span class="string">"Java"</span> | <span class="string">"Scala"</span> || <span class="string">"Gosling"</span> | <span class="string">"Odersky"</span> || <span class="string">"JVM"</span> | <span class="string">"JVM,.NET"</span>)</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>11.6</strong><br>提供一个ASCIIArt类，其对象包含类似这样的图形:<br> /_/\<br>( ‘ ‘ )<br>(  -  )<br> | | |<br>(<strong>|</strong>)<br>提供将两个ASCIIArt图形横向或纵向结合的操作符。选用适当优先级的操作符命名。纵向结合的实例<br> /_/\     ——-<br>( ‘ ‘ )  / Hello \<br>(  -  ) &lt;  Scala |<br> | | |   \ Coder /<br>(<strong>|</strong>)    ——-</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> collection.mutable.ArrayBuffer</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ASCIIArt</span><span class="params">(str:String)</span></span>{</div><div class="line">  <span class="keyword">val</span> arr:ArrayBuffer[ArrayBuffer[String]] = <span class="keyword">new</span> ArrayBuffer[ArrayBuffer[String]]()</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (str != <span class="keyword">null</span> && !str.trim.eq(<span class="string">""</span>)){</div><div class="line">    str.split(<span class="string">"[\r\n]+"</span>).foreach{</div><div class="line">      line =&gt;</div><div class="line">        <span class="keyword">val</span> s = <span class="keyword">new</span> ArrayBuffer[String]()</div><div class="line">        s += line</div><div class="line">        arr += s</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> <span class="keyword">this</span>(){</div><div class="line">    <span class="keyword">this</span>(<span class="string">""</span>)</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> +(other:ASCIIArt):ASCIIArt={</div><div class="line">    <span class="keyword">val</span> art = <span class="keyword">new</span> ASCIIArt()</div><div class="line">    <span class="keyword">val</span> length = <span class="keyword">if</span> (<span class="keyword">this</span>.arr.length &gt;= other.arr.length) <span class="keyword">this</span>.arr.length <span class="keyword">else</span> other.arr.length</div><div class="line">    <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until length){</div><div class="line">      <span class="keyword">val</span> s = <span class="keyword">new</span> ArrayBuffer[String]()</div><div class="line">      <span class="keyword">val</span> thisArr:ArrayBuffer[String] = <span class="keyword">if</span> (i &lt; <span class="keyword">this</span>.arr.length) <span class="keyword">this</span>.arr(i) <span class="keyword">else</span> <span class="keyword">new</span> ArrayBuffer[String]()</div><div class="line">      <span class="keyword">val</span> otherArr:ArrayBuffer[String] = <span class="keyword">if</span> (i &lt; other.arr.length) other.arr(i) <span class="keyword">else</span> <span class="keyword">new</span> ArrayBuffer[String]()</div><div class="line">      thisArr.foreach(s += _)</div><div class="line">      otherArr.foreach(s += _)</div><div class="line">      art.arr += s</div><div class="line">    }</div><div class="line">    art</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> *(other:ASCIIArt):ASCIIArt={</div><div class="line">    <span class="keyword">val</span> art = <span class="keyword">new</span> ASCIIArt()</div><div class="line">    <span class="keyword">this</span>.arr.foreach(art.arr += _)</div><div class="line">    other.arr.foreach(art.arr += _)</div><div class="line">    art</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> toString()={</div><div class="line">    <span class="keyword">var</span> ss:String = <span class="string">""</span></div><div class="line">    arr.foreach{</div><div class="line">      ss += _.mkString(<span class="string">" "</span>) + <span class="string">"\n"</span></div><div class="line">    }</div><div class="line">    ss</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>{</div><div class="line">  <span class="keyword">val</span> a = <span class="keyword">new</span> ASCIIArt(<span class="string">""" /\_/\</span></div><div class="line">                         |( ' ' )</div><div class="line">                         |(  -  )</div><div class="line">                         | | | |</div><div class="line">                         |(__|__)</div><div class="line">                         |""".stripMargin)</div><div class="line">  <span class="keyword">val</span> b = <span class="keyword">new</span> ASCIIArt( <span class="string">"""    -----</span></div><div class="line">                          |  / Hello \</div><div class="line">                          | &lt;  Scala |</div><div class="line">                          |  \ Coder /</div><div class="line">                          |    -----</div><div class="line">                          |""".stripMargin)</div><div class="line">  println(a + b * b)</div><div class="line">  println((a + b) * b)</div><div class="line">  println(a * b)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>11.7</strong><br>实现一个BigSequence类,将64个bit的序列打包在一个Long值中。提供apply和update操作来获取和设置某个具体的bit</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitSequence</span><span class="params">(private var value: Long = 0)</span> </span>{</div><div class="line"></div><div class="line">  implicit <span class="keyword">def</span> bool2int(b: Boolean) = <span class="keyword">if</span> (b) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></div><div class="line"></div><div class="line">  <span class="keyword">def</span> update(bit: Int, state: Int) = value |= (state & <span class="number">1</span>L) &lt;&lt; bit % <span class="number">64</span></div><div class="line">  <span class="keyword">def</span> apply(bit: Int): Int = <span class="keyword">if</span> ((value & <span class="number">1</span>L &lt;&lt; bit % <span class="number">64</span>) &gt; <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> toString = <span class="string">"%64s"</span>.format(value.toBinaryString).replace(<span class="string">" "</span>, <span class="string">"0"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">val</span> x = <span class="keyword">new</span> BitSequence()</div><div class="line"></div><div class="line">x(<span class="number">5</span>) = <span class="number">1</span></div><div class="line">x(<span class="number">63</span>) = <span class="number">1</span></div><div class="line">x(<span class="number">64</span>) = <span class="number">1</span></div><div class="line"></div><div class="line">println(x(<span class="number">5</span>))</div><div class="line"></div><div class="line">println(x)</div></pre></td></tr></table></figure>

<p><strong>11.8</strong><br>提供一个Matrix类—你可以选择需要的是一个2<em>2的矩阵，任意大小的正方形矩阵，或m</em>n的矩阵。支持+和<em>操作。</em>操作应同样适用于单值，例如mat*2。单个元素可以通过mat(row,col)得到</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span><span class="params">(val m: Int, val n: Int=m)</span> </span>{</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">val</span> value = Array.ofDim[Double](m, n)</div><div class="line"></div><div class="line">	<span class="keyword">def</span> update(x: Int, y: Int, v: Double) = value(x)(y) = v</div><div class="line">	<span class="keyword">def</span> apply(x: Int, y: Int) = value(x)(y)</div><div class="line"></div><div class="line">	<span class="keyword">def</span> +(other: Matrix) = {</div><div class="line">		require (n == other.n)</div><div class="line">		require (m == other.m)</div><div class="line"></div><div class="line">		<span class="keyword">var</span> res = <span class="keyword">new</span> Matrix(m, n)</div><div class="line">		<span class="keyword">for</span>(i &lt;- <span class="number">0</span> until m; j &lt;- <span class="number">0</span> until n) {</div><div class="line">			res(i, j) = <span class="keyword">this</span>.value(i)(j) + other.value(i)(j)</div><div class="line">		}</div><div class="line">		res </div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">def</span> -(other: Matrix) = <span class="keyword">this</span> + other * -<span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">	<span class="keyword">def</span> *(factor: Double) = {</div><div class="line">		<span class="keyword">var</span> res = <span class="keyword">new</span> Matrix(m, n)</div><div class="line">		<span class="keyword">for</span>(i &lt;- <span class="number">0</span> until m; j &lt;- <span class="number">0</span> until n) {</div><div class="line">			res(i, j) = <span class="keyword">this</span>.value(i)(j) * factor</div><div class="line">		}</div><div class="line">		res </div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">def</span> prod(other: Matrix, i: Int, j: Int) = {</div><div class="line">		(<span class="keyword">for</span> (k &lt;- <span class="number">0</span> until n) <span class="keyword">yield</span> value(i)(k) * other.value(j)(k)).sum</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">def</span> *(other: Matrix) = {</div><div class="line">		require(n == other.m)</div><div class="line">		<span class="keyword">var</span> res = <span class="keyword">new</span> Matrix(m, n)</div><div class="line">		<span class="keyword">for</span>(i &lt;- <span class="number">0</span> until m; j &lt;- <span class="number">0</span> until n) {</div><div class="line">			res(i, j) = prod(other, i, j)</div><div class="line">		}</div><div class="line">		res </div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">override</span> <span class="keyword">def</span> toString = value.map(_.mkString(<span class="string">" "</span>)).mkString(<span class="string">"\n"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">val</span> x = <span class="keyword">new</span> Matrix(<span class="number">2</span>, <span class="number">2</span>)</div><div class="line">x(<span class="number">0</span>, <span class="number">0</span>) = <span class="number">1</span></div><div class="line">x(<span class="number">0</span>, <span class="number">1</span>) = <span class="number">2</span></div><div class="line">x(<span class="number">1</span>, <span class="number">0</span>) = <span class="number">3</span></div><div class="line">x(<span class="number">1</span>, <span class="number">1</span>) = <span class="number">4</span></div><div class="line"></div><div class="line">println(x)</div><div class="line">println()</div><div class="line">println(x * <span class="number">2</span>)</div><div class="line">println()</div><div class="line">println(x * <span class="number">2</span> - x)</div><div class="line">println()</div><div class="line"></div><div class="line">println((x * <span class="number">2</span>) * (x * <span class="number">3</span>))</div></pre></td></tr></table></figure>

<p><strong>11.9</strong><br>为RichFile类定义unapply操作，提取文件路径，名称和扩展名。举例来说，文件/home/cay/readme.txt的路径为/home/cay,名称为readme,扩展名为txt</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RichFile</span><span class="params">(val path:String)</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">File</span><span class="params">(path)</span></span>{</div><div class="line"></div><div class="line">}</div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">RichFile</span></span>{</div><div class="line">  <span class="keyword">def</span> unapply(richFile:RichFile): Unit ={</div><div class="line">    <span class="keyword">val</span> path = richFile.path</div><div class="line">    <span class="keyword">val</span> pos = path.lastIndexOf(<span class="string">"/"</span>)</div><div class="line">    <span class="keyword">if</span> (pos == -<span class="number">1</span>) None <span class="keyword">else</span> Some((path.substring(<span class="number">0</span>, pos), path.substring(pos + <span class="number">1</span>)))</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>11.10</strong><br>为RichFile类定义一个unapplySeq，提取所有路径段。举例来说，对于/home/cay/readme.txt，你应该产出三个路径段的序列:home,cay和readme.txt</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">RichFile</span> </span>{</div><div class="line">  <span class="keyword">def</span> unapplySeq(s: String): Option[Seq[String]] = {</div><div class="line">    <span class="keyword">if</span> (s.trim == <span class="string">""</span>) None <span class="keyword">else</span> Some(s.trim.split(<span class="string">"/"</span>))</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第十章习题解答]]></title>
    <link href="http://vernonzheng.com/2015/02/02/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%AC%AC%E5%8D%81%E7%AB%A0%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94/"/>
    <id>http://vernonzheng.com/2015/02/02/《快学scala》第十章习题解答/</id>
    <published>2015-02-01T16:30:42.000Z</published>
    <updated>2015-02-02T13:36:51.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第十章_特质">第十章 特质</h2>
<p><strong>10.1</strong><br>java.awt.Rectangle类有两个很有用的方法translate和grow,但可惜的是像java.awt.geom.Ellipse2D这样的类没有。在Scala中，你可以解决掉这个问题。定义一个RenctangleLike特质,加入具体的translate和grow方法。提供任何你需要用来实现的抽象方法,以便你可以像如下代码这样混入该特质:<br>val egg = new java.awt.geom.Ellipse2D.Double(5,10,20,30) with RectangleLike<br>egg.translate(10,-10)<br>egg.grow(10,20)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.awt.geom.Ellipse2D</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">RectangleLike</span></span>{</div><div class="line">  <span class="keyword">this</span>:Ellipse2D.Double=&gt;</div><div class="line">  <span class="keyword">def</span> translate(x:Double,y:Double){</div><div class="line">    <span class="keyword">this</span>.x = x</div><div class="line">    <span class="keyword">this</span>.y = y</div><div class="line">  }</div><div class="line">  <span class="keyword">def</span> grow(x:Double,y:Double){</div><div class="line">    <span class="keyword">this</span>.x += x</div><div class="line">    <span class="keyword">this</span>.y += y</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>{</div><div class="line">  <span class="keyword">val</span> egg = <span class="keyword">new</span> Ellipse2D.Double(<span class="number">5</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>) <span class="keyword">with</span> RectangleLike</div><div class="line">  println(<span class="string">"x = "</span> + egg.getX + <span class="string">" y = "</span> + egg.getY)</div><div class="line">  egg.translate(<span class="number">10</span>,-<span class="number">10</span>)</div><div class="line">  println(<span class="string">"x = "</span> + egg.getX + <span class="string">" y = "</span> + egg.getY)</div><div class="line">  egg.grow(<span class="number">10</span>,<span class="number">20</span>)</div><div class="line">  println(<span class="string">"x = "</span> + egg.getX + <span class="string">" y = "</span> + egg.getY)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>10.2</strong><br>通过把scala.math.Ordered[Point]混入java.awt.Point的方式，定义OrderedPoint类。按辞典编辑方式排序，也就是说，如果x&lt;x’或者x=x’且y&lt;y’则(x,y)&lt;(x’,y’)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.awt.Point</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderedPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> <span class="keyword">with</span> <span class="title">Ordered</span>[<span class="title">Point</span>]</span>{</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> compare(that: Point): Int = {</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.x &lt;= that.x && <span class="keyword">this</span>.y &lt; that.y) -<span class="number">1</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.x == that.x && <span class="keyword">this</span>.y == that.y) <span class="number">0</span></div><div class="line">    <span class="keyword">else</span> <span class="number">1</span></div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>10.3</strong><br>查看BitSet类,将它的所有超类和特质绘制成一张图。忽略类型参数([…]中的所有内容)。然后给出该特质的线性化规格说明 </p>
<p>略</p>
<p><strong>10.4</strong><br>提供一个CryptoLogger类，将日志消息以凯撒密码加密。缺省情况下密匙为3，不过使用者也可以重写它。提供缺省密匙和-3作为密匙是的使用示例 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Logger</span></span>{</div><div class="line">  <span class="keyword">def</span> log(str:String,key:Int = <span class="number">3</span>):String</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CryptoLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span></span>{</div><div class="line"></div><div class="line">  <span class="keyword">def</span> log(str: String, key:Int): String = {</div><div class="line">    <span class="keyword">for</span> ( i &lt;- str) <span class="keyword">yield</span> <span class="keyword">if</span> (key &gt;= <span class="number">0</span>) (<span class="number">97</span> + ((i - <span class="number">97</span> + key)%<span class="number">26</span>)).toChar <span class="keyword">else</span> (<span class="number">97</span> + ((i - <span class="number">97</span> + <span class="number">26</span> + key)%<span class="number">26</span>)).toChar</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>{</div><div class="line">    <span class="keyword">val</span> plain = <span class="string">"chenzhen"</span>;</div><div class="line">    println(<span class="string">"明文为："</span> + plain);</div><div class="line">    println(<span class="string">"加密后为："</span> + <span class="keyword">new</span> CryptoLogger().log(plain));</div><div class="line">    println(<span class="string">"加密后为："</span> + <span class="keyword">new</span> CryptoLogger().log(plain,-<span class="number">3</span>));</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>10.5</strong><br>JavaBean规范里有一种提法叫做属性变更监听器(property change listener)，这是bean用来通知其属性变更的标准方式。PropertyChangeSupport类对于任何想要支持属性变更通知其属性变更监听器的bean而言是个便捷的超类。但可惜已有其他超类的类—比如JComponent—必须重新实现相应的方法。将PropertyChangeSupport重新实现为一个特质,然后将它混入到java.awt.Point类中 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.awt.Point</div><div class="line"><span class="keyword">import</span> java.beans.PropertyChangeSupport</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PropertyChange</span> <span class="keyword">extends</span> <span class="title">PropertyChangeSupport</span></span></div><div class="line"></div><div class="line"><span class="keyword">val</span> p = <span class="keyword">new</span> Point() <span class="keyword">with</span> PropertyChange</div></pre></td></tr></table></figure>

<p><strong>10.6</strong><br>在Java AWT类库中,我们有一个Container类，一个可以用于各种组件的Component子类。举例来说,Button是一个Component,但Panel是Container。这是一个运转中的组合模式。Swing有JComponent和JContainer,但如果你仔细看的话，你会发现一些奇怪的细节。尽管把其他组件添加到比如JButton中毫无意义,JComponent依然扩展自Container。Swing的设计者们理想情况下应该会更倾向于图10-4中的设计。但在Java中那是不可能的。请解释这是为什么？Scala中如何用特质来设计出这样的效果? </p>
<p>Java只能单继承。</p>
<p><strong>10.7</strong><br>市面上有不下数十种关于Scala特质的教程,用的都是些”在叫的狗”啦，”讲哲学的青蛙”啦之类的傻乎乎的例子。阅读和理解这些机巧的继承层级很乏味且对于理解问题没什么帮助,但自己设计一套继承层级就不同了,会很有启发。做一个你自己的关于特质的继承层级，要求体现出叠加在一起的特质,具体的和抽象的方法，以及具体的和抽象的字段 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Fly</span></span>{</div><div class="line">  <span class="keyword">def</span> fly(){</div><div class="line">    println(<span class="string">"flying"</span>)</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> flywithnowing()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Walk</span></span>{</div><div class="line">  <span class="keyword">def</span> walk(){</div><div class="line">    println(<span class="string">"walk"</span>)</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>{</div><div class="line">  <span class="keyword">var</span> name:String = _</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlueBird</span> <span class="keyword">extends</span> <span class="title">Bird</span> <span class="keyword">with</span> <span class="title">Fly</span> <span class="keyword">with</span> <span class="title">Walk</span></span>{</div><div class="line">  <span class="keyword">def</span> flywithnowing() {</div><div class="line">    println(<span class="string">"BlueBird flywithnowing"</span>)</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>{</div><div class="line">  <span class="keyword">val</span> b = <span class="keyword">new</span> BlueBird()</div><div class="line">  b.walk()</div><div class="line">  b.flywithnowing()</div><div class="line">  b.fly()</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>10.8</strong><br>在java.io类库中，你可以通过BufferedInputStream修饰器来给输入流增加缓冲机制。用特质来重新实现缓冲。简单起见，重写read方法 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.{InputStream, FileInputStream}</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Buffering</span> </span>{</div><div class="line">	<span class="keyword">this</span>: InputStream =&gt;</div><div class="line"></div><div class="line">	<span class="keyword">val</span> BUF_SIZE: Int = <span class="number">5</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">val</span> buf = <span class="keyword">new</span> Array[Byte](BUF_SIZE)</div><div class="line">	<span class="keyword">private</span> <span class="keyword">var</span> bufsize: Int = <span class="number">0</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">var</span> pos: Int = <span class="number">0</span></div><div class="line"></div><div class="line">	<span class="keyword">override</span> <span class="keyword">def</span> read(): Int = {</div><div class="line">		<span class="keyword">if</span> (pos &gt;= bufsize) {</div><div class="line">			bufsize = <span class="keyword">this</span>.read(buf, <span class="number">0</span>, BUF_SIZE)</div><div class="line">			<span class="keyword">if</span> (bufsize &gt; <span class="number">0</span>) -<span class="number">1</span></div><div class="line">			pos = <span class="number">0</span></div><div class="line">		}</div><div class="line">		pos += <span class="number">1</span></div><div class="line">		buf(pos-<span class="number">1</span>)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">val</span> f = <span class="keyword">new</span> FileInputStream(<span class="string">"08.txt"</span>) <span class="keyword">with</span> Buffering</div><div class="line"></div><div class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">10</span>) println(f.read())</div></pre></td></tr></table></figure>

<p><strong>10.9</strong><br>使用本章的日志生成器特质,给前一个练习中的方案增加日志功能，要求体现缓冲的效果</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.{InputStream, FileInputStream}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Logger</span> </span>{</div><div class="line">  <span class="keyword">def</span> log(msg: String)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">NoneLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>{</div><div class="line">  <span class="keyword">def</span> log(msg: String) = {}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PrintLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>{</div><div class="line">  <span class="keyword">def</span> log(msg: String) = println(msg)</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Buffering</span> </span>{</div><div class="line">  <span class="keyword">this</span>: InputStream <span class="keyword">with</span> Logger =&gt;</div><div class="line"></div><div class="line">  <span class="keyword">val</span> BUF_SIZE: Int = <span class="number">5</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">val</span> buf = <span class="keyword">new</span> Array[Byte](BUF_SIZE)</div><div class="line">  <span class="keyword">private</span> <span class="keyword">var</span> bufsize: Int = <span class="number">0</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">var</span> pos: Int = <span class="number">0</span></div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> read(): Int = {</div><div class="line">    <span class="keyword">if</span> (pos &gt;= bufsize) {</div><div class="line">      bufsize = <span class="keyword">this</span>.read(buf, <span class="number">0</span>, BUF_SIZE)</div><div class="line">      log(<span class="string">"buffered %d bytes: %s"</span>.format(bufsize, buf.mkString(<span class="string">", "</span>)))</div><div class="line">      <span class="keyword">if</span> (bufsize &gt; <span class="number">0</span>) -<span class="number">1</span></div><div class="line">      pos = <span class="number">0</span></div><div class="line">    }</div><div class="line">    pos += <span class="number">1</span></div><div class="line">    buf(pos-<span class="number">1</span>)</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">val</span> f = <span class="keyword">new</span> FileInputStream(<span class="string">"exercise08.txt"</span>) <span class="keyword">with</span> Buffering <span class="keyword">with</span> PrintLogger</div><div class="line"></div><div class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">10</span>) println(f.read())</div></pre></td></tr></table></figure>

<p><strong>10.10</strong><br>实现一个IterableInputStream类，扩展java.io.InputStream并混入Iterable[Byte]特质 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IterableInputStream</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">InputStream</span> <span class="keyword">with</span> <span class="title">Iterable</span>[<span class="title">Byte</span>]</span>{</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">InputStreamIterator</span><span class="params">(outer: IterableInputStream)</span> <span class="keyword">extends</span> <span class="title">Iterator</span>[<span class="title">Byte</span>] </span>{</div><div class="line">    <span class="keyword">def</span> hasNext: Boolean = outer.available() &gt; <span class="number">0</span></div><div class="line">    <span class="keyword">def</span> next: Byte = outer.read().toByte</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> iterator: Iterator[Byte] = <span class="keyword">new</span> InputStreamIterator(<span class="keyword">this</span>)</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> read(): Int = <span class="number">0</span></div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第九章习题解答]]></title>
    <link href="http://vernonzheng.com/2015/02/01/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%AC%AC%E4%B9%9D%E7%AB%A0%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94/"/>
    <id>http://vernonzheng.com/2015/02/01/《快学scala》第九章习题解答/</id>
    <published>2015-02-01T02:30:42.000Z</published>
    <updated>2015-02-01T07:10:22.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第九章_文件和正则表达式">第九章 文件和正则表达式</h2>
<p><strong>9.1</strong><br>编写一小段Scala代码，将某个文件中的行倒转顺序(将最后一行作为第一行,依此类推)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> path = <span class="string">"./exercise01.txt"</span></div><div class="line"><span class="keyword">val</span> file = Source.fromFile(path)</div><div class="line"><span class="keyword">val</span> reverseLines = file.getLines().toArray.reverse</div><div class="line"><span class="keyword">val</span> pw = <span class="keyword">new</span> PrintWriter(path)</div><div class="line">reverseLines.foreach (line =&gt; pw.write(line+<span class="string">"\n"</span>))</div><div class="line">pw.close()</div></pre></td></tr></table></figure>

<p><strong>9.2</strong><br>编写Scala程序,从一个带有制表符的文件读取内容,将每个制表符替换成一组空格,使得制表符隔开的n列仍然保持纵向对齐,并将结果写入同一个文件</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> io.Source</div><div class="line"><span class="keyword">import</span> java.io.PrintWriter</div><div class="line"></div><div class="line"><span class="keyword">val</span> path = <span class="string">"test.txt"</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> reader = Source.fromFile(path).getLines()</div><div class="line"></div><div class="line"><span class="keyword">val</span> result = <span class="keyword">for</span> ( t &lt;- reader) <span class="keyword">yield</span> t.replaceAll(<span class="string">"\\t"</span>,<span class="string">"    "</span>)</div><div class="line"></div><div class="line"><span class="keyword">val</span> pw = <span class="keyword">new</span> PrintWriter(path)</div><div class="line"></div><div class="line">result.foreach(line =&gt; pw.write(line + <span class="string">"\n"</span>))</div><div class="line"></div><div class="line">pw.close()</div></pre></td></tr></table></figure>

<p><strong>9.3</strong><br>编写一小段Scala代码,从一个文件读取内容并把所有字符数大于12的单词打印到控制台。如果你能用单行代码完成会有额外奖励</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scala.io.Source.fromFile(<span class="string">"./exercise01.txt"</span>).mkString.split(<span class="string">"\\s+"</span>).foreach(line=&gt; <span class="keyword">if</span>(line.length&gt;<span class="number">12</span>) println(line))</div></pre></td></tr></table></figure>

<p><strong>9.4</strong><br>编写Scala程序，从包含浮点数的文本文件读取内容，打印出文件中所有浮点数之和，平均值，最大值和最小值</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.io.Source</div><div class="line"><span class="keyword">val</span> nums = Source.fromFile(<span class="string">"exercise01.txt"</span>).mkString.split(<span class="string">"\\s+"</span>)</div><div class="line"></div><div class="line"><span class="keyword">var</span> total = <span class="number">0</span>d</div><div class="line"></div><div class="line">nums.foreach(total += _.toDouble)</div><div class="line"></div><div class="line">println(total)</div><div class="line">println(total/nums.length)</div><div class="line">println(nums.max)</div><div class="line">println(nums.min)</div></pre></td></tr></table></figure>

<p><strong>9.5</strong><br>编写Scala程序，向文件中写入2的n次方及其倒数，指数n从0到20。对齐各列:<br>  1         1<br>  2         0.5<br>  4         0.25<br>…         …</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.PrintWriter</div><div class="line"></div><div class="line"><span class="keyword">val</span> pw = <span class="keyword">new</span> PrintWriter(<span class="string">"exercise01.txt"</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> ( n &lt;- <span class="number">0</span> to <span class="number">20</span>){</div><div class="line">  <span class="keyword">val</span> t = BigDecimal(<span class="number">2</span>).pow(n)</div><div class="line">  pw.write(t.toString())</div><div class="line">  pw.write(<span class="string">"\t\t"</span>)</div><div class="line">  pw.write((<span class="number">1</span>/t).toString())</div><div class="line">  pw.write(<span class="string">"\n"</span>)</div><div class="line">}</div><div class="line"></div><div class="line">pw.close()</div></pre></td></tr></table></figure>

<p><strong>9.6</strong><br>编写正则表达式,匹配Java或C++程序代码中类似”like this,maybe with \” or\“这样的带引号的字符串。编写Scala程序将某个源文件中所有类似的字符串打印出来</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">val source = scala.io.Source.fromFile("test.txt").mkString</div><div class="line"></div><div class="line">val pattern = """"([^"\\]*([\\]+"[^"\\]*)*)"""".r</div><div class="line"></div><div class="line">pattern.findAllIn(source).foreach(println)</div></pre></td></tr></table></figure>

<p><strong>9.7</strong><br>编写Scala程序，从文本文件读取内容，并打印出所有的非浮点数的词法单位。要求使用正则表达式</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> io.Source</div><div class="line"></div><div class="line"><span class="keyword">val</span> source = Source.fromFile(<span class="string">"test.txt"</span>).mkString</div><div class="line"></div><div class="line"><span class="keyword">val</span> pattern = <span class="string">"""[^((\d+\.){0,1}\d+)^\s+]+"""</span>.r</div><div class="line"></div><div class="line">pattern.findAllIn(source).foreach(println)</div></pre></td></tr></table></figure>

<p><strong>9.8</strong><br>编写Scala程序打印出某个网页中所有img标签的src属性。使用正则表达式和分组</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> pattern = <span class="string">"""&lt;img[^&gt;]+(src\s*=\s*"[^&gt;^"]+")[^&gt;]*&gt;"""</span>.r</div><div class="line"><span class="keyword">val</span> source = scala.io.Source.fromURL(<span class="string">"http://www.vernonzheng.com"</span>,<span class="string">"utf-8"</span>).mkString</div><div class="line"></div><div class="line"><span class="keyword">for</span> (pattern(str) &lt;- pattern.findAllIn(source)) println(str)</div></pre></td></tr></table></figure>

<p><strong>9.9</strong><br>编写Scala程序，盘点给定目录及其子目录中总共有多少以.class为扩展名的文件</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> countClass(dir:java.io.File): Int = {</div><div class="line">  <span class="keyword">var</span> num:Int = <span class="number">0</span></div><div class="line">  <span class="keyword">val</span> files = dir.listFiles()</div><div class="line">  num += files.filter(_.isFile).count(_.getName.endsWith(<span class="string">".class"</span>))</div><div class="line">  files.filter(_.isDirectory).foreach(num += countClass(_))</div><div class="line">  num</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>9.10</strong><br>扩展那个可序列化的Person类，让它能以一个集合保存某个人的朋友信息。构造出一些Person对象，让他们中的一些人成为朋友，然后将Array[Person]保存到文件。将这个数组从文件中重新读出来，校验朋友关系是否完好</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">mport collection.mutable.ArrayBuffer</div><div class="line"><span class="keyword">import</span> java.io.{ObjectInputStream, FileOutputStream, FileInputStream, ObjectOutputStream}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(var name:String)</span> <span class="keyword">extends</span> <span class="title">Serializable</span></span>{</div><div class="line"></div><div class="line">  <span class="keyword">val</span> friends = <span class="keyword">new</span> ArrayBuffer[Person]()</div><div class="line"></div><div class="line">  <span class="keyword">def</span> addFriend(friend : Person){</div><div class="line">    friends += friend</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> toString() = {</div><div class="line">    <span class="keyword">var</span> str = <span class="string">"My name is "</span> + name + <span class="string">" and my friends name is "</span></div><div class="line">    friends.foreach(str += _.name + <span class="string">","</span>)</div><div class="line">    str</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>{</div><div class="line">  <span class="keyword">val</span> p1 = <span class="keyword">new</span> Person(<span class="string">"Ivan"</span>)</div><div class="line">  <span class="keyword">val</span> p2 = <span class="keyword">new</span> Person(<span class="string">"F2"</span>)</div><div class="line">  <span class="keyword">val</span> p3 = <span class="keyword">new</span> Person(<span class="string">"F3"</span>)</div><div class="line"></div><div class="line">  p1.addFriend(p2)</div><div class="line">  p1.addFriend(p3)</div><div class="line">  println(p1)</div><div class="line"></div><div class="line">  <span class="keyword">val</span> out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"person.obj"</span>))</div><div class="line">  out.writeObject(p1)</div><div class="line">  out.close()</div><div class="line"></div><div class="line">  <span class="keyword">val</span> in =  <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"person.obj"</span>))</div><div class="line">  <span class="keyword">val</span> p = in.readObject().asInstanceOf[Person]</div><div class="line">  println(p)</div><div class="line">}</div></pre></td></tr></table></figure>

<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第八章习题解答]]></title>
    <link href="http://vernonzheng.com/2015/02/01/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%AC%AC%E5%85%AB%E7%AB%A0%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94/"/>
    <id>http://vernonzheng.com/2015/02/01/《快学scala》第八章习题解答/</id>
    <published>2015-02-01T00:10:42.000Z</published>
    <updated>2015-02-01T01:19:53.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第八章_继承">第八章 继承</h2>
<p><strong>8.1</strong><br>扩展如下的BankAccount类，新类CheckingAccount对每次存款和取款都收取1美元的手续费<br>class BankAccount(initialBalance:Double){<br>    private var balance = initialBalance<br>    def deposit(amount:Double) = { balance += amount; balance}<br>    def withdraw(amount:Double) = {balance -= amount; balance}<br>}</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankAccount</span><span class="params">(initialBalance:Double)</span></span>{</div><div class="line">  <span class="keyword">private</span> <span class="keyword">var</span> balance = initialBalance</div><div class="line">  <span class="keyword">def</span> deposit(amount:Double) = { balance += amount; balance}</div><div class="line">  <span class="keyword">def</span> withdraw(amount:Double) = {balance -= amount; balance}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckingAccount</span><span class="params">(initialBanlance:Double)</span> <span class="keyword">extends</span> <span class="title">BankAccount</span><span class="params">(initialBanlance)</span></span>{</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> deposit(amount:Double) = <span class="keyword">super</span>.deposit(amount-<span class="number">1</span>)</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> withdraw(amount:Double) = <span class="keyword">super</span>.withdraw(amount+<span class="number">1</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>8.2</strong><br>扩展前一个练习的BankAccount类，新类SavingsAccount每个月都有利息产生(earnMonthlyInterest方法被调用)，并且有每月三次免手续费的存款或取款。在earnMonthlyInterest方法中重置交易计数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankAccount</span><span class="params">(initialBalance:Double)</span></span>{</div><div class="line">  <span class="keyword">private</span> <span class="keyword">var</span> balance = initialBalance</div><div class="line">  <span class="keyword">def</span> deposit(amount:Double) = { balance += amount; balance}</div><div class="line">  <span class="keyword">def</span> withdraw(amount:Double) = {balance -= amount; balance}</div><div class="line">}</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SavingsAccount</span><span class="params">(initialBalance:Double)</span> <span class="keyword">extends</span> <span class="title">BankAccount</span><span class="params">(initialBalance)</span></span>{</div><div class="line">  <span class="keyword">private</span> <span class="keyword">var</span> num:Int = _</div><div class="line">  <span class="keyword">def</span> earnMonthlyInterest()={</div><div class="line">    num = <span class="number">3</span></div><div class="line">    <span class="keyword">super</span>.deposit(<span class="number">1</span>)</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> deposit(amount: Double): Double = {</div><div class="line">    num -= <span class="number">1</span></div><div class="line">    <span class="keyword">if</span>(num &lt; <span class="number">0</span>) <span class="keyword">super</span>.deposit(amount - <span class="number">1</span>) <span class="keyword">else</span> <span class="keyword">super</span>.deposit(amount)</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> withdraw(amount: Double): Double = {</div><div class="line">    num -= <span class="number">1</span></div><div class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) <span class="keyword">super</span>.withdraw(amount + <span class="number">1</span>) <span class="keyword">else</span> <span class="keyword">super</span>.withdraw(amount)</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>8.3</strong><br>翻开你喜欢的Java或C++教科书，一定会找到用来讲解继承层级的实例，可能是员工，宠物，图形或类似的东西。用Scala来实现这个示例。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**</span></div><div class="line"> * java</div><div class="line"> * class Art{</div><div class="line">    Art(){System.out.println("Art constructor");}</div><div class="line">  }</div><div class="line"></div><div class="line">  class Drawing extends Art{</div><div class="line">    Drawing() {System.out.println("Drawing constructor");}</div><div class="line">  }</div><div class="line"></div><div class="line">  public class Cartoon extends Drawing{</div><div class="line">    public Cartoon() { System.out.println("Cartoon constructor");}</div><div class="line">  }</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Art</span></span>{</div><div class="line">  println(<span class="string">"Art constructor"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drawing</span> <span class="keyword">extends</span> <span class="title">Art</span></span>{</div><div class="line">  println(<span class="string">"Drawing constructor"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cartoon</span> <span class="keyword">extends</span> <span class="title">Drawing</span></span>{</div><div class="line">  println(<span class="string">"Cartoon constructor"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>8.4</strong><br>定义一个抽象类Item,加入方法price和description。SimpleItem是一个在构造器中给出价格和描述的物件。利用val可以重写def这个事实。Bundle是一个可以包含其他物件的物件。其价格是打包中所有物件的价格之和。同时提供一个将物件添加到打包当中的机制，以及一个适合的description方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> collection.mutable.ArrayBuffer</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span></span>{</div><div class="line">  <span class="keyword">def</span> price():Double</div><div class="line">  <span class="keyword">def</span> description():String</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> toString():String={</div><div class="line">    <span class="string">"description:"</span> + description() + <span class="string">"  price:"</span> + price()</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleItem</span><span class="params">(val price:Double,val description:String)</span> <span class="keyword">extends</span> <span class="title">Item</span></span>{</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bundle</span> <span class="keyword">extends</span> <span class="title">Item</span></span>{</div><div class="line"></div><div class="line">  <span class="keyword">val</span> items = <span class="keyword">new</span> ArrayBuffer[Item]()</div><div class="line"></div><div class="line">  <span class="keyword">def</span> addItem(item:Item){</div><div class="line">    items += item</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> price(): Double = {</div><div class="line">    <span class="keyword">var</span> total = <span class="number">0</span>d</div><div class="line">    items.foreach(total += _.price())</div><div class="line">    total</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> description(): String = {</div><div class="line">    items.mkString(<span class="string">" "</span>)</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>8.5</strong><br>设计一个Point类，其x和y坐标可以通过构造器提供。提供一个子类LabeledPoint，其构造器接受一个标签值和x,y坐标,比如:new LabeledPoint(“Black Thursday”,1929,230.07)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span><span class="params">(x:Double, y:Double)</span></span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LabeledPoint</span><span class="params">(x:Double, y:Double, tag:String)</span> <span class="keyword">extends</span> <span class="title">Point</span><span class="params">(x,y)</span></span></div></pre></td></tr></table></figure>

<p><strong>8.6</strong><br>定义一个抽象类Shape，一个抽象方法centerPoint，以及该抽象类的子类Rectangle和Circle。为子类提供合适的构造器，并重写centerPoint方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>{</div><div class="line">  <span class="keyword">def</span> centerPoint()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span><span class="params">(startX:Int,startY:Int,endX:Int,endY:Int)</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>{</div><div class="line">  <span class="keyword">def</span> centerPoint() {}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span><span class="params">(x:Int,y:Int,radius:Double)</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>{</div><div class="line">  <span class="keyword">def</span> centerPoint() {}</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>8.7</strong><br>提供一个Square类，扩展自java.awt.Rectangle并且是三个构造器：一个以给定的端点和宽度构造正方形，一个以(0,0)为端点和给定的宽度构造正方形，一个以(0,0)为端点,0为宽度构造正方形</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.awt.{Point, Rectangle}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span><span class="params">(point:Point,width:Int)</span> <span class="keyword">extends</span> <span class="title">Rectangle</span><span class="params">(point.x,point.y,width,width)</span></span>{</div><div class="line"></div><div class="line">  <span class="keyword">def</span> <span class="keyword">this</span>(){</div><div class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> Point(<span class="number">0</span>,<span class="number">0</span>),<span class="number">0</span>)</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> <span class="keyword">this</span>(width:Int){</div><div class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> Point(<span class="number">0</span>,<span class="number">0</span>),width)</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>8.8</strong><br>编译8.6节中的Person和SecretAgent类并使用javap分析类文件。总共有多少name的getter方法？它们分别取什么值？(提示：可以使用-c和-private选项)</p>
<p>总共两个。Person中取得的是传入的name,而SecretAgent中取得的是默认的”secret”</p>
<p><strong>8.9</strong><br>在8.10节的Creature类中，将val range替换成一个def。如果你在Ant子类中也用def的话会有什么效果？如果在子类中使用val又会有什么效果？为什么？</p>
<p>在Ant中使用def没有问题。但是如果使用val则无法编译。因为val只能重写不带参数的def。这里的def是带参数的</p>
<p><strong>8.10</strong><br>文件scala/collection/immutable/Stack.scala包含如下定义:<br>class Stack[A] protected (protected val elems: List[A])<br>请解释protected关键字的含义。(提示：回顾我们在第5章中关于私有构造器的讨论) 此构造方法只能被其子类来调用,而不能被外界直接调用</p>
<p>此构造方法只能被其子类来调用,而不能被外界直接调用</p>
<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第七章习题解答]]></title>
    <link href="http://vernonzheng.com/2015/01/31/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%AC%AC%E4%B8%83%E7%AB%A0%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94/"/>
    <id>http://vernonzheng.com/2015/01/31/《快学scala》第七章习题解答/</id>
    <published>2015-01-31T11:32:42.000Z</published>
    <updated>2015-01-31T12:14:37.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第七章_包和引用">第七章 包和引用</h2>
<p><strong>7.1</strong><br>编写示例程序，展示为什么<br>package com.horstmann.impatient<br>不同于<br>package com<br>package horstmann<br>package impatient </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com {</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">T1</span><span class="params">()</span> </span>{}</div><div class="line"></div><div class="line">  <span class="keyword">package</span> horstmann {</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">T2</span><span class="params">(t: T1)</span> </span>{}</div><div class="line"></div><div class="line">    <span class="keyword">package</span> impatient {</div><div class="line">      <span class="class"><span class="keyword">class</span> <span class="title">T3</span><span class="params">(t1: T1, t2: T2)</span> </span>{}</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div><div class="line"><span class="keyword">package</span> com.horstmann.impatient{</div><div class="line">  <span class="comment">//class T4(t1:T1,t3:T3)      //can not find type T1</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>7.2</strong><br>编写一段让你的Scala朋友们感到困惑的代码，使用一个不在顶部的com包</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> vernon {</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">T1</span><span class="params">()</span> </span>{}</div><div class="line"></div><div class="line">  <span class="keyword">package</span> com {</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">T2</span><span class="params">(t: T1)</span> </span>{}</div><div class="line">  }</div><div class="line">  </div><div class="line"></div><div class="line">  <span class="keyword">package</span> impatient {</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">T3</span><span class="params">(t1: T1, t2: com.T2)</span> </span>{}</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>7.3</strong><br>编写一个包random,加入函数nextInt():Int,nextDouble():Double,setSeed(seed:Int):Unit。生成随机数的算法采用线性同余生成器</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">object</span> <span class="title">random</span></span>{</div><div class="line"></div><div class="line">  <span class="keyword">var</span> seed:Int = _</div><div class="line">  <span class="keyword">val</span> a = BigDecimal(<span class="number">1664525</span>)</div><div class="line">  <span class="keyword">val</span> b = BigDecimal(<span class="number">1013904223</span>)</div><div class="line">  <span class="keyword">val</span> n = <span class="number">32</span></div><div class="line"></div><div class="line">  <span class="keyword">def</span> nextInt():Int={</div><div class="line">    <span class="keyword">val</span> temp = (seed * a + b) % BigDecimal(<span class="number">2</span>).pow(n)</div><div class="line">    seed = temp.toInt</div><div class="line">    seed</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> nextDouble():Double={</div><div class="line">    <span class="keyword">val</span> temp = (seed * a + b) % BigDecimal(<span class="number">2</span>).pow(n)</div><div class="line">    seed = temp.toInt</div><div class="line">    temp.toDouble</div><div class="line">  }</div><div class="line">}</div><div class="line"><span class="keyword">import</span> random._</div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Q3</span> <span class="keyword">extends</span> <span class="title">App</span> </span>{</div><div class="line">  (<span class="number">1</span> to <span class="number">10</span>).foreach(x =&gt; println(nextInt()))</div><div class="line">  (<span class="number">1</span> to <span class="number">10</span>).foreach(x =&gt; println(nextDouble()))</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>7.4</strong><br>在你看来Scala的设计者为什么要提供package object语法而不是简单的让你将函数和变量添加到包中呢？</p>
<p>JVM不支持</p>
<p><strong>7.5</strong><br>private[com] def giveRaise(rate:Double)的含义是什么？有用吗？</p>
<p>除了com包可访问giveRaise，其他包都不能访问。有用。</p>
<p><strong>7.6</strong><br>编写一段程序,将Java哈希映射中的所有元素拷贝到Scala哈希映射。用引入语句重命名这两个类。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Q6</span> <span class="keyword">extends</span> <span class="title">App</span></span>{</div><div class="line"></div><div class="line">  <span class="keyword">import</span> java.util.{HashMap =&gt; JavaHashMap}</div><div class="line">  <span class="keyword">import</span> collection.mutable.{HashMap =&gt; ScalaHashMap, Map =&gt; ScalaMap}</div><div class="line"></div><div class="line">  <span class="keyword">val</span> javaMap = <span class="keyword">new</span> JavaHashMap[Int,String]</div><div class="line"></div><div class="line">  javaMap.put(<span class="number">1</span>, <span class="string">"One"</span>);</div><div class="line">  javaMap.put(<span class="number">2</span>, <span class="string">"Two"</span>);</div><div class="line">  javaMap.put(<span class="number">3</span>, <span class="string">"Three"</span>);</div><div class="line">  javaMap.put(<span class="number">4</span>, <span class="string">"Four"</span>);</div><div class="line"></div><div class="line">  <span class="keyword">val</span> scalaMap = <span class="keyword">new</span> ScalaHashMap[Int,String]</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(key &lt;- javaMap.keySet().toArray){</div><div class="line">    scalaMap += (key.asInstanceOf[Int] -&gt; javaMap.get(key))</div><div class="line">  }</div><div class="line"></div><div class="line">  println(scalaMap.mkString(<span class="string">" "</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>7.7</strong><br>在前一个练习中，将所有引入语句移动到尽可能小的作用域里</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Q7</span> <span class="keyword">extends</span> <span class="title">App</span></span>{</div><div class="line"></div><div class="line">  <span class="keyword">import</span> java.util.{HashMap =&gt; JavaHashMap}</div><div class="line">  </div><div class="line">  <span class="keyword">val</span> javaMap = <span class="keyword">new</span> JavaHashMap[Int,String]</div><div class="line"></div><div class="line">  javaMap.put(<span class="number">1</span>, <span class="string">"One"</span>);</div><div class="line">  javaMap.put(<span class="number">2</span>, <span class="string">"Two"</span>);</div><div class="line">  javaMap.put(<span class="number">3</span>, <span class="string">"Three"</span>);</div><div class="line">  javaMap.put(<span class="number">4</span>, <span class="string">"Four"</span>);</div><div class="line">  </div><div class="line">  <span class="keyword">import</span> collection.mutable.{HashMap =&gt; ScalaHashMap, Map =&gt; ScalaMap}</div><div class="line">  </div><div class="line">  <span class="keyword">val</span> scalaMap = <span class="keyword">new</span> ScalaHashMap[Int,String]</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(key &lt;- javaMap.keySet().toArray()){</div><div class="line">    scalaMap += (key.asInstanceOf[Int] -&gt; javaMap.get(key))</div><div class="line">  }</div><div class="line"></div><div class="line">  println(scalaMap.mkString(<span class="string">" "</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>7.8</strong><br>以下代码的作用是什么？这是个好主意吗？<br>import java.<em><br>import javax.</em></p>
<p>导入java和javax下的所有类。而java和javax下是没有类的。所以此代码无用</p>
<p><strong>7.9</strong><br>编写一段程序，引入java.lang.System类，从user.name系统属性读取用户名，从Console对象读取一个密码,如果密码不是”secret”，则在标准错误流中打印一个消息；如果密码是”secret”，则在标准输出流中打印一个问候消息。不要使用任何其他引入，也不要使用任何限定词(带句点的那种)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Q9</span> <span class="keyword">extends</span> <span class="title">App</span></span>{</div><div class="line">  <span class="keyword">import</span> java.lang.System._</div><div class="line">  <span class="keyword">var</span> password = Console.readLine()</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (password equals <span class="string">"secret"</span>)</div><div class="line">    System.out.println(<span class="string">"Hello "</span> + getProperty(<span class="string">"user.name"</span>))</div><div class="line">  <span class="keyword">else</span></div><div class="line">    System.err.println(<span class="string">"password error!"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>7.10</strong><br>除了StringBuilder,还有哪些java.lang的成员是被scala包覆盖的？</p>
<p>比对java.lang下的类和scala包下的类，略</p>
<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第六章习题解答]]></title>
    <link href="http://vernonzheng.com/2015/01/31/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%AC%AC%E5%85%AD%E7%AB%A0%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94/"/>
    <id>http://vernonzheng.com/2015/01/31/《快学scala》第六章习题解答/</id>
    <published>2015-01-31T08:32:42.000Z</published>
    <updated>2015-01-31T09:25:41.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第六章_对象">第六章 对象</h2>
<p><strong>6.1</strong><br>编写一个 Conversions 对象，加入 inchesToCentimeters,gallonsToLiters 和 milesToKilometers 方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Conversions</span></span>{</div><div class="line">  <span class="keyword">def</span> inchesToSantimeters(value: Double) = value * <span class="number">2.54</span></div><div class="line">  <span class="keyword">def</span> gallonsToLiters(value: Double) = value * <span class="number">3.78541178</span></div><div class="line">  <span class="keyword">def</span> milesToKilometers(value: Double) = value * <span class="number">1.609344</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>6.2</strong><br>前一个练习不是很面向对象。提供一个通用的超类 UnitConversion并定义扩展该超类的 InchesToCentimeters,GallonsToLiters 和 MilesToKilometers 对象</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnitConversion</span><span class="params">(val factor: Double)</span> </span>{</div><div class="line">	<span class="keyword">def</span> convert(value: Double): Double = factor * value</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">InchesToSantimeters</span> <span class="keyword">extends</span> <span class="title">UnitConversion</span><span class="params">(2.54)</span></span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">GallonsToLiters</span> <span class="keyword">extends</span> <span class="title">UnitConversion</span><span class="params">(3.78541178)</span></span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">MilesToKilometers</span> <span class="keyword">extends</span> <span class="title">UnitConversion</span><span class="params">(1.609344)</span></span></div></pre></td></tr></table></figure>

<p><strong>6.3</strong><br>定义一个扩展自 java.awt.Point 的 Origin 对象。为什么说这实际上不是个好主意？(仔细看 Point 类的方法)Point 中的 getLocation 方法返回的是 Point 对象，如果想返回 Origin 对象，需要 Origin 类才行</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.awt.Point</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Origin</span> <span class="keyword">extends</span> <span class="title">Point</span></span>{</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> getLocation : Point = <span class="keyword">super</span>.getLocation</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>6.4</strong><br>定义一个 Point 类和一个伴生对象,使得我们可以不用 new 而直接用 Point(3,4)来构造 Point 实例 apply 方法的使用</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span><span class="params">(x: Int = 0, y: Int = 0)</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">awt</span>.<span class="title">Point</span><span class="params">(x, y)</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Point</span> </span>{</div><div class="line">	<span class="keyword">def</span> apply(x: Int = <span class="number">0</span>, y: Int = <span class="number">0</span>) = <span class="keyword">new</span> Point(x, y)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>6.5</strong><br>编写一个 Scala 应用程序,使用 App 特质,以反序打印命令行参数,用空格隔开。举例来说,scala Reverse Hello World 应该打印 World Hello</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Reverse</span> <span class="keyword">extends</span> <span class="title">App</span></span>{</div><div class="line">  args.reverse.mkString(<span class="string">" "</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>6.6</strong><br>编写一个扑克牌 4 种花色的枚举,让其 toString 方法分别返回♣,♦,♥,♠</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Suits</span> <span class="keyword">extends</span> <span class="title">Enumeration</span></span>{</div><div class="line">  <span class="keyword">type</span> Suits = Value</div><div class="line">  <span class="keyword">val</span> Spade = Value(<span class="string">"♠"</span>)</div><div class="line">  <span class="keyword">val</span> Club = Value(<span class="string">"♣"</span>)</div><div class="line">  <span class="keyword">val</span> Heart = Value(<span class="string">"♥"</span>)</div><div class="line">  <span class="keyword">val</span> Diamond = Value(<span class="string">"♦"</span>)</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> toString():String={</div><div class="line">    Suits.values.mkString(<span class="string">","</span>)</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>6.7</strong><br>实现一个函数,检查某张牌的花色是否为红色</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Suits</span> <span class="keyword">extends</span> <span class="title">Enumeration</span> </span>{</div><div class="line">  <span class="keyword">type</span> Suits = Value</div><div class="line">  <span class="keyword">val</span> Spade = Value(<span class="string">"♠"</span>)</div><div class="line">  <span class="keyword">val</span> Club = Value(<span class="string">"♣"</span>)</div><div class="line">  <span class="keyword">val</span> Heart = Value(<span class="string">"♥"</span>)</div><div class="line">  <span class="keyword">val</span> Diamond = Value(<span class="string">"♦"</span>)</div><div class="line">  <span class="keyword">def</span> isRed(card: Suits) = card == Heart || card == Diamond</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>6.8</strong><br>编写一个枚举,描述 RGB 立方体的 8 个角。ID 使用颜色值(例如 :红色是 0xff0000)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">RGBCube</span> <span class="keyword">extends</span> <span class="title">Enumeration</span> </span>{</div><div class="line">	<span class="keyword">val</span> black = Value(<span class="number">0x000000</span>, <span class="string">"Black"</span>)</div><div class="line">	<span class="keyword">val</span> red = Value(<span class="number">0xff0000</span>, <span class="string">"Red"</span>)</div><div class="line">	<span class="keyword">val</span> green = Value(<span class="number">0x00ff00</span>, <span class="string">"Green"</span>)</div><div class="line">	<span class="keyword">val</span> blue = Value(<span class="number">0x0000ff</span>, <span class="string">"Blue"</span>)</div><div class="line">	<span class="keyword">val</span> yellow = Value(<span class="number">0xffff00</span>, <span class="string">"Yellow"</span>)</div><div class="line">	<span class="keyword">val</span> magenta = Value(<span class="number">0xff00ff</span>, <span class="string">"Magenta"</span>)</div><div class="line">	<span class="keyword">val</span> cyan = Value(<span class="number">0x00ffff</span>, <span class="string">"Cyan"</span>)</div><div class="line">	<span class="keyword">val</span> white = Value(<span class="number">0xffffff</span>, <span class="string">"White"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span>( c &lt;- RGBCube.values ) println(<span class="string">"0x%06x: %s"</span>.format(c.id, c))</div></pre></td></tr></table></figure>

<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第五章习题解答]]></title>
    <link href="http://vernonzheng.com/2015/01/25/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94/"/>
    <id>http://vernonzheng.com/2015/01/25/《快学scala》第五章习题解答/</id>
    <published>2015-01-25T11:27:42.000Z</published>
    <updated>2015-01-25T12:12:51.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第五章_类">第五章 类</h2>
<p><strong>5.1</strong><br>改进5.1节的Counter类,让它不要在Int.MaxValue时变成负数</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span><span class="params">()</span></span>{</div><div class="line">  <span class="keyword">private</span> <span class="keyword">var</span> value = <span class="number">0</span></div><div class="line">  <span class="keyword">def</span> increment(){ <span class="keyword">if</span>(value&lt;Int.MaxValue) value += <span class="number">1</span> }</div><div class="line">  <span class="keyword">def</span> current() = value</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>5.2</strong><br>编写一个BankAccount类，加入deposit和withdraw方法，和一个只读的balance属性</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankAccount</span></span>{</div><div class="line">  <span class="keyword">private</span> <span class="keyword">val</span> banlance = <span class="number">0</span></div><div class="line">  <span class="keyword">def</span> deposit(){}</div><div class="line">  <span class="keyword">def</span> withdraw(){}</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>5.3</strong><br>编写一个Time类，加入只读属性hours和minutes，和一个检查某一时刻是否早于另一时刻的方法before(other:Time):Boolean。Time对象应该以new Time(hrs,min)方式构建。其中hrs以军用时间格式呈现(介于0和23之间)</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span><span class="params">(private[this] val hrs:Int,private[this] val min:Int)</span></span>{</div><div class="line">  <span class="keyword">val</span> hours = hrs</div><div class="line">  <span class="keyword">val</span> minutes = min</div><div class="line">  <span class="keyword">def</span> before(other:Time):Boolean = {</div><div class="line">    <span class="keyword">if</span>(hours&lt;other.hours)</div><div class="line">      <span class="keyword">true</span></div><div class="line">    <span class="keyword">if</span>(hours==other.hours)</div><div class="line">      <span class="keyword">if</span>(minutes&lt;other.minutes)</div><div class="line">        <span class="keyword">true</span></div><div class="line">    <span class="keyword">false</span></div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>5.4</strong><br>重新实现前一个类中的Time类，将内部呈现改成午夜起的分钟数(介于0到24*60-1之间)。不要改变公有接口。也就是说，客户端代码不应因你的修改而受影响</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span><span class="params">(private[this] val hrs:Int,private[this] val min:Int)</span></span>{</div><div class="line">  <span class="keyword">val</span> minutesInDay = hrs*<span class="number">24</span>+min</div><div class="line">  <span class="keyword">def</span> before(other:Time):Boolean = {</div><div class="line">    <span class="keyword">if</span>(minutesInDay&lt;other.minutesInDay)</div><div class="line">      <span class="keyword">true</span></div><div class="line">    <span class="keyword">false</span></div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>5.5</strong><br>创建一个Student类，加入可读写的JavaBeans属性name(类型为String)和id(类型为Long)。有哪些方法被生产？(用javap查看。)你可以在Scala中调用JavaBeans的getter和setter方法吗？应该这样做吗？</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.beans.BeanProperty</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>{</div><div class="line">  <span class="annotation">@BeanProperty</span> <span class="keyword">var</span> name:String = _</div><div class="line">  <span class="annotation">@BeanProperty</span> <span class="keyword">var</span> id:Long = _</div><div class="line">}</div><div class="line"><span class="javadoc">/**</span></div><div class="line">javap -c Student 后显示如下</div><div class="line"></div><div class="line">Compiled from "Student.scala"</div><div class="line">public class Student extends java.lang.Object implements scala.ScalaObject{</div><div class="line">  public java.lang.String name();</div><div class="line">  Code:</div><div class="line">  0:   aload_0</div><div class="line">  1:   getfield        #13; //Field name:Ljava/lang/String;</div><div class="line">  4:   areturn</div><div class="line"></div><div class="line">  public void name_$eq(java.lang.String);</div><div class="line">  Code:</div><div class="line">  0:   aload_0</div><div class="line">  1:   aload_1</div><div class="line">  2:   putfield        #13; //Field name:Ljava/lang/String;</div><div class="line">  5:   return</div><div class="line"></div><div class="line">  public void setName(java.lang.String);</div><div class="line">  Code:</div><div class="line">  0:   aload_0</div><div class="line">  1:   aload_1</div><div class="line">  2:   putfield        #13; //Field name:Ljava/lang/String;</div><div class="line">  5:   return</div><div class="line"></div><div class="line">  public long id();</div><div class="line">  Code:</div><div class="line">  0:   aload_0</div><div class="line">  1:   getfield        #19; //Field id:J</div><div class="line">  4:   lreturn</div><div class="line"></div><div class="line">  public void id_$eq(long);</div><div class="line">  Code:</div><div class="line">  0:   aload_0</div><div class="line">  1:   lload_1</div><div class="line">  2:   putfield        #19; //Field id:J</div><div class="line">  5:   return</div><div class="line"></div><div class="line">  public void setId(long);</div><div class="line">  Code:</div><div class="line">  0:   aload_0</div><div class="line">  1:   lload_1</div><div class="line">  2:   putfield        #19; //Field id:J</div><div class="line">  5:   return</div><div class="line"></div><div class="line">  public long getId();</div><div class="line">  Code:</div><div class="line">  0:   aload_0</div><div class="line">  1:   invokevirtual   #25; //Method id:()J</div><div class="line">  4:   lreturn</div><div class="line"></div><div class="line">  public java.lang.String getName();</div><div class="line">  Code:</div><div class="line">  0:   aload_0</div><div class="line">  1:   invokevirtual   #28; //Method name:()Ljava/lang/String;</div><div class="line">  4:   areturn</div><div class="line"></div><div class="line">  public Student();</div><div class="line">  Code:</div><div class="line">  0:   aload_0</div><div class="line">  1:   invokespecial   #34; //Method java/lang/Object."&lt;init&gt;":()V</div><div class="line">  4:   return</div><div class="line"></div><div class="line">}</div><div class="line">  **/</div></pre></td></tr></table></figure>

<p><strong>5.6</strong><br>在5.2节的Person类中提供一个主构造器,将负年龄转换为0</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(var age:Int)</span></span>{</div><div class="line">  age = <span class="keyword">if</span>(age &lt; <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> age</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>5.7</strong><br>编写一个Person类，其主构造器接受一个字符串，该字符串包含名字，空格和姓，如new Person(“Fred Smith”)。提供只读属性firstName和lastName。主构造器参数应该是var,val还是普通参数？为什么？</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(private[this] val name:String)</span></span>{</div><div class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> tmp = name.split(<span class="string">"\\s+"</span>)</div><div class="line">  <span class="keyword">val</span> firstName = tmp(<span class="number">0</span>)</div><div class="line">  <span class="keyword">val</span> lastName = tmp(<span class="number">1</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>5.8</strong><br>创建一个Car类，以只读属性对应制造商，型号名称，型号年份以及一个可读写的属性用于车牌。提供四组构造器。每个构造器fc都要求制造商和型号为必填。型号年份和车牌可选，如果未填，则型号年份为-1，车牌为空串。你会选择哪一个作为你的主构造器？为什么？</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">(val manufactuer:String, val model: String, val year: Int = -1, var license: String = <span class="string">""</span>)</span></span></div></pre></td></tr></table></figure>

<p><strong>5.9</strong><br>在Java,C#或C++重做前一个练习。Scala相比之下精简多少？</p>
<p>答：<br>略</p>
<p><strong>5.10</strong><br>考虑如下的类</p>
<p>class Employ(val name:String,var salary:Double){<br>    def this(){this(“John Q. Public”,0.0)}<br>}<br>重写该类,使用显示的字段定义，和一个缺省主构造器。你更倾向于使用哪种形式？为什么？</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employ</span><span class="params">()</span></span>{</div><div class="line">  <span class="keyword">val</span> name:String = <span class="string">"John Q. Public"</span></div><div class="line">  <span class="keyword">var</span> salary:Double = <span class="number">0.0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第四章习题解答]]></title>
    <link href="http://vernonzheng.com/2015/01/25/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%AC%AC%E5%9B%9B%E7%AB%A0%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94/"/>
    <id>http://vernonzheng.com/2015/01/25/《快学scala》第四章习题解答/</id>
    <published>2015-01-25T09:27:42.000Z</published>
    <updated>2015-01-25T11:21:19.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第四章_映射和元组">第四章 映射和元组</h2>
<p><strong>4.1</strong><br>设置一个映射,其中包含你想要的一些装备，以及它们的价格。然后构建另一个映射，采用同一组键，但是价格上打9折</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> buildEquipMap() :Map[String,Double] = {</div><div class="line">  <span class="keyword">val</span> equipMap:Map[String,Double] = Map(<span class="string">"eq1"</span>-&gt;<span class="number">11.1</span>,<span class="string">"eq2"</span>-&gt;<span class="number">12.2</span>,<span class="string">"eq3"</span>-&gt;<span class="number">14</span>)</div><div class="line">  <span class="keyword">for</span> ((k,v) &lt;- equipMap) <span class="keyword">yield</span> (k,v*<span class="number">0.9</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>4.2</strong><br>编写一段程序，从文件中读取单词。用一个可变映射来清点每个单词出现的频率。读取这些单词的操作可以使用java.util.Scanner</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.collection.mutable</div><div class="line"><span class="keyword">import</span> scala.io.Source</div><div class="line"></div><div class="line"><span class="keyword">def</span> countWord() : Unit = {</div><div class="line">  <span class="keyword">val</span> wordMap = <span class="keyword">new</span> mutable.HashMap[String,Int]</div><div class="line">  <span class="keyword">val</span> in = <span class="keyword">new</span> java.util.Scanner(<span class="keyword">new</span> java.io.File(<span class="string">"exercise02.txt"</span>))</div><div class="line">  <span class="keyword">while</span>(in.hasNext){</div><div class="line">    <span class="keyword">val</span> word = in.next()</div><div class="line">    wordMap(word) = wordMap.getOrElse(word,<span class="number">0</span>) + <span class="number">1</span></div><div class="line">  }</div><div class="line">  println(wordMap.mkString(<span class="string">","</span>))</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">def</span> countWord2() : Unit = {</div><div class="line">  <span class="keyword">val</span> source = Source.fromFile(<span class="string">"exercise02.txt"</span>).mkString</div><div class="line">  <span class="keyword">val</span> tokens = source.split(<span class="string">"\\s+"</span>)</div><div class="line">  <span class="keyword">val</span> wordMap = <span class="keyword">new</span> mutable.HashMap[String,Int]</div><div class="line">  <span class="keyword">for</span>(word &lt;- tokens){</div><div class="line">    wordMap(word) = wordMap.getOrElse(word,<span class="number">0</span>) + <span class="number">1</span></div><div class="line">  }</div><div class="line">  println(wordMap.mkString(<span class="string">","</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>4.3</strong><br>重复前一个练习，这次用不可变的映射</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">mport scala.collection.{mutable, immutable}</div><div class="line"><span class="keyword">import</span> scala.io.Source</div><div class="line"></div><div class="line"><span class="keyword">def</span> countWord() : Unit = {</div><div class="line">  <span class="keyword">val</span> source = Source.fromFile(<span class="string">"exercise02.txt"</span>).mkString</div><div class="line">  <span class="keyword">val</span> tokens = source.split(<span class="string">"\\s+"</span>)</div><div class="line">  <span class="keyword">var</span> wordMap = <span class="keyword">new</span> immutable.HashMap[String,Int]</div><div class="line">  <span class="keyword">for</span>(key &lt;- tokens){</div><div class="line">    wordMap += (key -&gt; (wordMap.getOrElse(key,<span class="number">0</span>) + <span class="number">1</span>))</div><div class="line">  }</div><div class="line">  println(wordMap.mkString(<span class="string">","</span>))</div><div class="line">}</div><div class="line"></div><div class="line"><span class="javadoc">/**</span></div><div class="line"> * 书中:immutable map += 不断生成新的map，由于都是immutable，共享大部分数据结构，</div><div class="line"> * 测试下性能</div><div class="line"> */</div><div class="line"><span class="keyword">def</span> countWord1(tokens:Array[String]) : Unit = {</div><div class="line">  <span class="keyword">val</span> wordMap = <span class="keyword">new</span> mutable.HashMap[String,Int]</div><div class="line">  <span class="keyword">for</span>(word &lt;- tokens){</div><div class="line">    wordMap(word) = wordMap.getOrElse(word,<span class="number">0</span>) + <span class="number">1</span></div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">def</span> countWord2(tokens:Array[String]) : Unit = {</div><div class="line">  <span class="keyword">val</span> wordMap = <span class="keyword">new</span> mutable.HashMap[String,Int]</div><div class="line">  <span class="keyword">for</span>(word &lt;- tokens){</div><div class="line">    wordMap(word) = wordMap.getOrElse(word,<span class="number">0</span>) + <span class="number">1</span></div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">def</span> performance():Unit={</div><div class="line">  <span class="keyword">val</span> source = Source.fromFile(<span class="string">"exercise02.txt"</span>).mkString</div><div class="line">  <span class="keyword">val</span> tokens = source.split(<span class="string">"\\s+"</span>)</div><div class="line">  <span class="keyword">val</span> startTime1 = System.currentTimeMillis()</div><div class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> to <span class="number">10000</span>) {</div><div class="line">    countWord1(tokens)</div><div class="line">  }</div><div class="line">  <span class="keyword">val</span> endTime1 = System.currentTimeMillis()</div><div class="line">  <span class="keyword">val</span> startTime2 = System.currentTimeMillis()</div><div class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> to <span class="number">10000</span>) {</div><div class="line">    countWord2(tokens)</div><div class="line">  }</div><div class="line">  <span class="keyword">val</span> endTime2 = System.currentTimeMillis()</div><div class="line">  println(<span class="string">"countWord1(mutable map) cost:"</span>+(endTime1-startTime1))</div><div class="line">  println(<span class="string">"countWord2(immutable map) cost:"</span>+(endTime2-startTime2))</div><div class="line"></div><div class="line">  <span class="javadoc">/**</span></div><div class="line">   * scala&gt; performance</div><div class="line">countWord1(mutable map) cost:36</div><div class="line">countWord2(immutable map) cost:34</div><div class="line"></div><div class="line">scala&gt; performance</div><div class="line">countWord1(mutable map) cost:4</div><div class="line">countWord2(immutable map) cost:4</div><div class="line"></div><div class="line">scala&gt; performance</div><div class="line">countWord1(mutable map) cost:8</div><div class="line">countWord2(immutable map) cost:6</div><div class="line"></div><div class="line">scala&gt; performance</div><div class="line">countWord1(mutable map) cost:4</div><div class="line">countWord2(immutable map) cost:8</div><div class="line"></div><div class="line">scala&gt; performance</div><div class="line">countWord1(mutable map) cost:5</div><div class="line">countWord2(immutable map) cost:4</div><div class="line">   */</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>4.4</strong><br>重复前一个练习，这次使用已排序的映射，以便单词可以按顺序打印出来</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.collection.immutable.TreeMap</div><div class="line"><span class="keyword">import</span> scala.io.Source</div><div class="line"></div><div class="line"><span class="keyword">def</span> countWord() : Unit = {</div><div class="line">  <span class="keyword">val</span> source = Source.fromFile(<span class="string">"exercise02.txt"</span>).mkString</div><div class="line">  <span class="keyword">val</span> tokens = source.split(<span class="string">"\\s+"</span>)</div><div class="line">  <span class="keyword">var</span> wordMap = <span class="keyword">new</span> TreeMap[String,Int]</div><div class="line">  <span class="keyword">for</span>(key &lt;- tokens){</div><div class="line">    wordMap += (key -&gt; (wordMap.getOrElse(key,<span class="number">0</span>) + <span class="number">1</span>))</div><div class="line">  }</div><div class="line">  println(wordMap.mkString(<span class="string">","</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>4.5</strong><br>重复前一个练习，这次使用java.util.TreeMap并使之适用于Scala API</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util</div><div class="line"><span class="keyword">import</span> scala.collection.mutable.Map</div><div class="line"><span class="keyword">import</span> scala.collection.JavaConversions.mapAsScalaMap</div><div class="line"><span class="keyword">import</span> scala.io.Source</div><div class="line"></div><div class="line"><span class="keyword">def</span> countWord() : Unit = {</div><div class="line">  <span class="keyword">val</span> source = Source.fromFile(<span class="string">"exercise02.txt"</span>).mkString</div><div class="line">  <span class="keyword">val</span> tokens = source.split(<span class="string">"\\s+"</span>)</div><div class="line">  <span class="keyword">var</span> wordMap:Map[String,Int] = <span class="keyword">new</span> util.TreeMap[String,Int]</div><div class="line">  <span class="keyword">for</span>(key &lt;- tokens){</div><div class="line">    wordMap += (key -&gt; (wordMap.getOrElse(key,<span class="number">0</span>) + <span class="number">1</span>))</div><div class="line">  }</div><div class="line">  println(wordMap.mkString(<span class="string">","</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>4.6</strong><br>定义一个链式哈希映射,将”Monday”映射到java.util.Calendar.MONDAY,依次类推加入其他日期。展示元素是以插入的顺序被访问的</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Calendar</div><div class="line"><span class="keyword">import</span> scala.collection.mutable</div><div class="line"></div><div class="line"><span class="keyword">def</span> calendarDays():Unit = {</div><div class="line">  <span class="keyword">val</span> daysMap = mutable.LinkedHashMap(</div><div class="line">    <span class="string">"Monday"</span> -&gt; Calendar.MONDAY,</div><div class="line">    <span class="string">"Tuesday"</span> -&gt; Calendar.TUESDAY,</div><div class="line">    <span class="string">"Wednesday"</span> -&gt; Calendar.WEDNESDAY,</div><div class="line">    <span class="string">"Thursday"</span> -&gt; Calendar.THURSDAY,</div><div class="line">    <span class="string">"Friday"</span> -&gt; Calendar.FRIDAY,</div><div class="line">    <span class="string">"Saturday"</span> -&gt; Calendar.SATURDAY,</div><div class="line">    <span class="string">"Sunday"</span> -&gt; Calendar.SUNDAY</div><div class="line">  )</div><div class="line">  println(daysMap.mkString(<span class="string">","</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>4.7</strong><br>打印出所有Java系统属性的表格</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.collection.JavaConversions.propertiesAsScalaMap</div><div class="line"></div><div class="line"><span class="keyword">def</span> printJavaSysProps():Unit = {</div><div class="line">  <span class="keyword">val</span> propMap:collection.Map[String,String] = System.getProperties()</div><div class="line">  <span class="keyword">val</span> maxKeyLength = propMap.keySet.map(_.length).max</div><div class="line">  <span class="keyword">for</span>( (k,v) &lt;- propMap ) printf(<span class="string">"%-"</span> + maxKeyLength + <span class="string">"s | %s\n"</span>, k, v)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>4.8</strong><br>编写一个函数minmax(values:Array[Int]),返回数组中最小值和最大值的对偶</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> minmax(values:Array[Int])={</div><div class="line">  (values.max,values.min)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>4.9</strong><br>编写一个函数Iteqgt(values:Array[int],v:Int),返回数组中小于v,等于v和大于v的数量，要求三个值一起返回</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> Iteqgt(values:Array[Int],v:Int){</div><div class="line">  (values.count(_ &lt; v),values.count(_ == v),values.count(_ &gt; v))</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>4.10</strong><br>当你将两个字符串拉链在一起，比如”Hello”.zip(“World”)，会是什么结果？想出一个讲得通的用例</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="string">"Hello"</span>.zip(<span class="string">"hello"</span>).toMap</div><div class="line">res40: scala.collection.immutable.Map[Char,Char] = Map(H -&gt; h, e -&gt; e, l -&gt; l, o -&gt; o)</div></pre></td></tr></table></figure>

<p>StringOps中的zip定义如下:</p>
<p>abstract def zip<a href="that: GenIterable[B]" target="_blank" rel="external">B</a>: StringOps[(A, B)]<br>GenIterable是可遍历对象需要包含的trait，对于String来说，它是可遍历的。但是它的遍历是遍历单个字母。 所以拉链就针对每个字母来进行。</p>
<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第三章习题解答]]></title>
    <link href="http://vernonzheng.com/2015/01/21/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%AC%AC%E4%B8%89%E7%AB%A0%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94/"/>
    <id>http://vernonzheng.com/2015/01/21/《快学scala》第三章习题解答/</id>
    <published>2015-01-21T14:40:42.000Z</published>
    <updated>2015-01-25T06:28:43.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第三章_数组相关操作">第三章 数组相关操作</h2>
<p><strong>3.1</strong><br>编写一段代码，将a设置为一个n个随机整数的数组，要求随机数介于0(包含)和n(不包含)之间</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.util.Random</div><div class="line"><span class="keyword">import</span> scala.math.random</div><div class="line"><span class="keyword">def</span> randomArray(n: Int) :Array[Int] = {</div><div class="line">  <span class="keyword">val</span> array = <span class="keyword">for</span>( i&lt;- <span class="number">0</span> to n) <span class="keyword">yield</span> Random.nextInt(n)</div><div class="line">  array.toArray</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">def</span> randomArray2(n: Int) :Array[Int] = {</div><div class="line">  <span class="keyword">val</span> array = <span class="keyword">for</span>( i&lt;- <span class="number">0</span> to n) <span class="keyword">yield</span> (random * n).toInt</div><div class="line">  array.toArray</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>3.2</strong><br>编写一个循环，将整数数组中相邻的元素置换。例如,Array(1,2,3,4,5)经过置换后变为Array(2,1,4,3,5)</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> arrayChange(array: Array[Int]) :Array[Int] = {</div><div class="line">  <span class="keyword">if</span>(array == <span class="keyword">null</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span></div><div class="line"></div><div class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until array.length <span class="keyword">if</span> i % <span class="number">2</span> ==<span class="number">0</span> && i &gt; <span class="number">0</span>){</div><div class="line">    <span class="keyword">val</span> tmp = array(i-<span class="number">1</span>)</div><div class="line">    array(i-<span class="number">1</span>) = array(i)</div><div class="line">    array(i) = tmp</div><div class="line">  }</div><div class="line">  array</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">def</span> arrayChange2(arr: Array[Int]) :Array[Int] = {</div><div class="line">  <span class="keyword">val</span> t = arr.toBuffer</div><div class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until (t.length,<span class="number">2</span>) <span class="keyword">if</span> i + <span class="number">1</span> &lt; t.length){</div><div class="line">    <span class="keyword">val</span> a = t(i)</div><div class="line">    <span class="keyword">val</span> b = t(i + <span class="number">1</span>)</div><div class="line">    t.remove(i,<span class="number">2</span>)</div><div class="line">    t.insert(i,b)</div><div class="line">    t.insert(i + <span class="number">1</span>,a)</div><div class="line">  }</div><div class="line">  t.toArray</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>3.3</strong><br>重复前一个练习，不过这一次生成一个新的值交换过的数组。用for/yield</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> arrayChange(array: Array[Int]) :Array[Int] = {</div><div class="line">  <span class="keyword">if</span>(array == <span class="keyword">null</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span></div><div class="line"></div><div class="line">  <span class="keyword">val</span> length = array.length</div><div class="line">  <span class="keyword">var</span> flag = <span class="keyword">true</span></div><div class="line">  <span class="keyword">val</span> newArray = <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until length <span class="keyword">if</span> flag) <span class="keyword">yield</span>{</div><div class="line">    <span class="keyword">var</span> item = <span class="number">0</span></div><div class="line">    <span class="keyword">if</span>(i+<span class="number">1</span> &gt;= length){</div><div class="line">      flag = <span class="keyword">false</span></div><div class="line">    }</div><div class="line">    <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>){</div><div class="line">      item = array(i+<span class="number">1</span>)</div><div class="line">    }<span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">1</span>){</div><div class="line">      item = array(i-<span class="number">1</span>)</div><div class="line">    }</div><div class="line">    item</div><div class="line">  }</div><div class="line">  newArray.toArray</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>3.4</strong><br>给定一个整数数组，产生一个新的数组，包含元数组中的所有正值，以原有顺序排列，之后的元素是所有零或负值，以原有顺序排列</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> sortArray(array:Array[Int]):Array[Int] = {</div><div class="line">  <span class="keyword">val</span> newArrayBuffer = <span class="keyword">new</span> ArrayBuffer[Int]()</div><div class="line">  <span class="keyword">val</span> positiveIndex = <span class="keyword">for</span>(i &lt;- <span class="number">0</span> to array.length <span class="keyword">if</span> array(i) &gt; <span class="number">0</span> ) <span class="keyword">yield</span> {array(i)}</div><div class="line">  newArrayBuffer ++= positiveIndex.toBuffer</div><div class="line">  newArrayBuffer ++= (<span class="keyword">for</span>(i &lt;- <span class="number">0</span> to array.length <span class="keyword">if</span> !positiveIndex.contains(i)) <span class="keyword">yield</span>{array(i)}).toBuffer</div><div class="line">  newArrayBuffer.toArray</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">def</span> sortArray2(array:Array[Int]):Array[Int] = {</div><div class="line">  <span class="keyword">val</span> a = ArrayBuffer[Int]()</div><div class="line">  <span class="keyword">val</span> b = ArrayBuffer[Int]()</div><div class="line">  array.foreach(arg =&gt; <span class="keyword">if</span>(arg &gt; <span class="number">0</span>) a += arg <span class="keyword">else</span> b += arg)</div><div class="line">  a ++= b</div><div class="line">  a.toArray</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">def</span> sortArray3(array:Array[Int]):Array[Int] = {</div><div class="line">  <span class="keyword">val</span> a = array.filter(_&gt;<span class="number">0</span>).map(_*<span class="number">1</span>)</div><div class="line">  <span class="keyword">val</span> b = array.filter(_&lt;=<span class="number">0</span>).map(_*<span class="number">1</span>)</div><div class="line">  <span class="keyword">var</span> c = a.toBuffer</div><div class="line">  c ++= b.toBuffer</div><div class="line">  c.toArray</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>3.5</strong><br>如何计算Array[Double]的平均值</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> avgArray(array:Array[Double]):Double={</div><div class="line">  array.sum/array.length</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>3.6</strong><br>如何重新组织Array[Int]的元素将他们以反序排列？对于ArrayBuffer[Int]你又会怎么做呢？</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> reverseArray(arr:Array[Int]):Array[Int]={</div><div class="line">  arr.reverse</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>3.7</strong><br>编写一段代码，产出数组中的所有值，去掉重复项。(提示：查看Scaladoc)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> removeArray1(arr:Array[Int]):Array[Int]={</div><div class="line">  <span class="keyword">val</span> t = arr.toBuffer</div><div class="line">  <span class="keyword">val</span> idx =(<span class="keyword">for</span>(i &lt;- <span class="number">0</span> until t.length <span class="keyword">if</span> t(i) &lt; <span class="number">0</span>) <span class="keyword">yield</span> { i }).reverse.toBuffer</div><div class="line">  idx.trimEnd(<span class="number">1</span>)</div><div class="line">  idx.foreach(arg =&gt; t.remove(arg))</div><div class="line">  t.toArray</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">def</span> removeArray2(array:Array[Int]):Array[Int]={</div><div class="line">  <span class="keyword">val</span> arr = array.toBuffer</div><div class="line">  <span class="keyword">var</span> first = <span class="keyword">true</span></div><div class="line">  <span class="keyword">val</span> indexes = <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until arr.length <span class="keyword">if</span> first || arr(i) &gt;= <span class="number">0</span>) <span class="keyword">yield</span>{</div><div class="line">    <span class="keyword">if</span>(arr(i) &lt; <span class="number">0</span>) first = <span class="keyword">false</span>;i</div><div class="line">  }</div><div class="line">  <span class="keyword">for</span>(j &lt;- <span class="number">0</span> until indexes.length) arr(j) = arr(indexes(j))</div><div class="line">  arr.trimEnd(arr.length - indexes.length)</div><div class="line">  arr.toArray</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">def</span> performance():Unit={</div><div class="line">  <span class="keyword">val</span> array = Array(<span class="number">1</span>,-<span class="number">2</span>,<span class="number">3</span>,<span class="number">55</span>,<span class="number">3</span>,-<span class="number">4</span>,-<span class="number">6</span>,-<span class="number">2</span>,-<span class="number">1</span>,<span class="number">55</span>,-<span class="number">3</span>,<span class="number">5</span>)</div><div class="line">  <span class="keyword">val</span> startTime1 = System.currentTimeMillis()</div><div class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> to <span class="number">10000</span>) {</div><div class="line">    removeArray1(array)</div><div class="line">  }</div><div class="line">  <span class="keyword">val</span> endTime1 = System.currentTimeMillis()</div><div class="line">  <span class="keyword">val</span> startTime2 = System.currentTimeMillis()</div><div class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> to <span class="number">10000</span>) {</div><div class="line">    <span class="keyword">val</span> result2 = removeArray2(array)</div><div class="line">  }</div><div class="line">  <span class="keyword">val</span> endTime2 = System.currentTimeMillis()</div><div class="line">  println(<span class="string">"removeArray1 cost:"</span>+(endTime1-startTime1))</div><div class="line">  println(<span class="string">"removeArray2 cost:"</span>+(endTime2-startTime2))</div><div class="line">  <span class="comment">//10000次 201：81</span></div><div class="line">}</div><div class="line"><span class="javadoc">/**</span></div><div class="line">   * scala&gt; performance</div><div class="line">removeArray1 cost:231</div><div class="line">removeArray2 cost:163</div><div class="line"></div><div class="line">scala&gt; performance</div><div class="line">removeArray1 cost:16</div><div class="line">removeArray2 cost:14</div><div class="line"></div><div class="line">scala&gt; performance</div><div class="line">removeArray1 cost:12</div><div class="line">removeArray2 cost:6</div><div class="line"></div><div class="line">scala&gt; performance</div><div class="line">removeArray1 cost:13</div><div class="line">removeArray2 cost:7</div><div class="line"></div><div class="line">scala&gt; performance</div><div class="line">removeArray1 cost:18</div><div class="line">removeArray2 cost:5</div><div class="line">   */</div></pre></td></tr></table></figure>

<p><strong>3.9</strong><br>创建一个由java.util.TimeZone.getAvailableIDs返回ide时区集合，判断条件是它们在美洲。去掉”America/“前缀并排序</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> sortAmericaTimeZone():Unit = {</div><div class="line">  <span class="keyword">val</span> array = java.util.TimeZone.getAvailableIDs</div><div class="line">  <span class="keyword">val</span> result = array.filter(_.startsWith(<span class="string">"America"</span>)).map(_.replace(<span class="string">"America/"</span>,<span class="string">""</span>)).sorted</div><div class="line">  result.foreach(println(_))</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>3.10</strong><br>引入java.awt.datatransfer.并构建一个类型为SystemFlavorMap类型的对象:<br>  val flavors = SystemFlavorMap.getDefaultFlavorMap().asInstanceOf[SystemFlavorMap]<br>  然后以DataFlavor.imageFlavor为参数调用getNativesForFlavor方法，以Scala缓冲保存返回值。<br> (为什么用这样一个晦涩难懂的类？因为在Java标准库中很难找到使用java.util.List的代码)</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.awt.datatransfer.{DataFlavor, SystemFlavorMap}</div><div class="line"><span class="keyword">import</span> collection.JavaConversions.asScalaBuffer</div><div class="line"><span class="keyword">import</span> scala.collection.mutable</div><div class="line"></div><div class="line"><span class="keyword">def</span> test():Unit = {</div><div class="line">  <span class="keyword">val</span> flavors = SystemFlavorMap.getDefaultFlavorMap().asInstanceOf[SystemFlavorMap]</div><div class="line">  <span class="keyword">val</span> res:mutable.Buffer[String] = flavors.getNativesForFlavor(DataFlavor.imageFlavor)</div><div class="line">  println(res)</div><div class="line">}</div></pre></td></tr></table></figure>

<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第二章习题解答]]></title>
    <link href="http://vernonzheng.com/2015/01/20/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94/"/>
    <id>http://vernonzheng.com/2015/01/20/《快学scala》第二章习题解答/</id>
    <published>2015-01-20T14:46:42.000Z</published>
    <updated>2015-01-21T05:21:43.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第二章_控制结构与函数">第二章 控制结构与函数</h2>
<p><strong>2.1</strong><br>一个数字如果为正数，则它的signum为1;如果是负数,则signum为-1;如果为0,则signum为0.编写一个函数来计算这个值。</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> sigNum(num: Int):Int = {</div><div class="line">	<span class="keyword">if</span> (num &gt; <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">0</span>) -<span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></div><div class="line">}</div><div class="line"></div><div class="line">println(signum(<span class="number">10000</span>));</div><div class="line">println(signum(-<span class="number">22</span>));</div><div class="line">println(signum(<span class="number">0</span>));</div></pre></td></tr></table></figure>

<p><strong>2.2</strong><br>一个空的块表达式{}的值是什么？类型是什么？</p>
<p>答：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scala&gt; val x = {}</div><div class="line">x: Unit = ()</div></pre></td></tr></table></figure>

<p><strong>2.3</strong><br>指出在Scala中何种情况下赋值语句x=y=1是合法的。(提示：给x找个合适的类型定义)</p>
<p>答：<br>因为赋值语句的值是Unit型，所以x可定义为Unit型。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="keyword">var</span> y = <span class="number">5</span></div><div class="line">y: Int = <span class="number">5</span></div><div class="line"></div><div class="line">scala&gt; <span class="keyword">var</span> x = {}</div><div class="line">x: Unit = ()</div><div class="line"></div><div class="line">scala&gt; x = y= <span class="number">1</span></div><div class="line">x: Unit = ()</div></pre></td></tr></table></figure>

<p><strong>2.4</strong><br>针对下列Java循环编写一个Scala版本:<br> for(int i=10;i&gt;=0;i—) System.out.println(i);</p>
<p>答：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="keyword">for</span>(i &lt;- <span class="number">0</span> to <span class="number">10</span> reverse) println(i)</div><div class="line">warning: there was one feature warning; re-run <span class="keyword">with</span> -feature <span class="keyword">for</span> details</div><div class="line"><span class="number">10</span></div><div class="line"><span class="number">9</span></div><div class="line"><span class="number">8</span></div><div class="line"><span class="number">7</span></div><div class="line"><span class="number">6</span></div><div class="line"><span class="number">5</span></div><div class="line"><span class="number">4</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">0</span></div></pre></td></tr></table></figure>

<p><strong>2.5</strong><br>编写一个过程countdown(n:Int)，打印从n到0的数字。</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="keyword">def</span> countdown(n:Int){</div><div class="line">         <span class="keyword">for</span>(i &lt;- <span class="number">0</span> to n reverse){</div><div class="line">           println(i)</div><div class="line">         }</div><div class="line">       }</div><div class="line">warning: there was one feature warning; re-run <span class="keyword">with</span> -feature <span class="keyword">for</span> details</div><div class="line">countdown: (n: Int)Unit</div><div class="line"></div><div class="line">scala&gt; countdown(<span class="number">2</span>)</div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">0</span></div></pre></td></tr></table></figure>

<p><strong>2.6</strong><br>编写一个for循环,计算字符串中所有字母的Unicode代码的乘积。举例来说，”Hello”中所有字符串的乘积为9415087488L</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="keyword">def</span> test(str:String):Long = {</div><div class="line">         <span class="keyword">var</span> result:Long = <span class="number">1</span></div><div class="line">         <span class="keyword">for</span>(i &lt;- str) result *= i</div><div class="line">         result</div><div class="line">       }</div><div class="line">test: (str: String)Long</div><div class="line"></div><div class="line">scala&gt; test(<span class="string">"oh,yeah"</span>)</div><div class="line">res5: Long = <span class="number">62621117315328</span></div></pre></td></tr></table></figure>

<p><strong>2.7</strong><br>同样是解决前一个练习的问题，但这次不使用循环。（提示：在Scaladoc中查看StringOps）</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> test(str:String):Long = {</div><div class="line">  <span class="keyword">var</span> result:Long = <span class="number">1</span></div><div class="line">  str.foreach( ch =&gt; {result *= (ch.toLong)})</div><div class="line">  result</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>2.8</strong><br>编写一个函数product(s:String), 计算前面习题中提到的乘积。</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> product(str:String):Long = {</div><div class="line">  <span class="keyword">var</span> result:Long = <span class="number">1</span></div><div class="line">  str.foreach( result *= _.toLong )</div><div class="line">  result</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>2.9</strong><br>把前一个练习中的函数改成递归函数。</p>
<p>答:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> product(str:String):Long = {</div><div class="line">  <span class="keyword">var</span> result:Long = <span class="number">1</span></div><div class="line">  <span class="keyword">if</span> (str.length==<span class="number">1</span>)</div><div class="line">    result = str.head.toLong</div><div class="line">  <span class="keyword">else</span></div><div class="line">    result = str.head.toLong * product(str.tail)</div><div class="line">  result</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>2.10</strong><br>编写函数计算x^n, 其中n为整数。使用如下的递归定义：</p>
<ul>
<li>x^n = y^2,如果</li>
<li>x^n = x*x^(n-1)</li>
<li>x^0 = 1</li>
<li>x^n = 1/x^(-n)</li>
</ul>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> getPower(x:Double, n:Int):Double = {</div><div class="line">  <span class="keyword">if</span> (n == <span class="number">0</span> ) <span class="number">1</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( n&gt;<span class="number">0</span> && n % <span class="number">2</span> != <span class="number">0</span> ) x * getPower(x, n-<span class="number">1</span>)</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;<span class="number">0</span> && n % <span class="number">2</span> == <span class="number">0</span> ) getPower (x, n/<span class="number">2</span>) * getPower (x, n/<span class="number">2</span>)</div><div class="line">  <span class="keyword">else</span> <span class="number">1</span>/getPower( x, -n) </div><div class="line">}</div></pre></td></tr></table></figure>

<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《MongoDB实战》笔记]]></title>
    <link href="http://vernonzheng.com/2015/01/19/%E3%80%8AMongoDB%E5%AE%9E%E6%88%98%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://vernonzheng.com/2015/01/19/《MongoDB实战》笔记/</id>
    <published>2015-01-19T08:26:23.000Z</published>
    <updated>2015-01-21T06:36:21.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《MongoDB实战》的学习笔记。
</code></pre><h2 id="第一章_为现代Web而生的数据库">第一章 为现代Web而生的数据库</h2>
<p><em>特性</em><br>mongodb适合做水平扩展的数据库。<br>mongodb把文档组织成集合，无schema。</p>
<p><strong>索引</strong><br>mongodb的二级索引是B树实现。<br>每个集合最多可以创建64个索引，</p>
<p><strong>副本集</strong><br>mongodb通过副本集（replication set）的结构提供了复制功能。<br>副本集有一个主节点(primary node)和一个或多个从节点(secondary node)构成。主节点支持读写，从节点只读。而且副本集支持自动故障转移：如果主节点出了问题，集群会选一个从节点自动将它提升为主节点，在先前的主节点恢复之后，它就变成一个从节点。</p>
<p><strong>journaling日志</strong><br>mongodb中，用户可以选择写入语义，决定是否开启Journaling日志记录，控制写入速度与持久性的之间的平衡，Journaling日志是默认开启的，所有写操作都会被提交到一个只能追加的日志里。</p>
<p><strong>fire-and-forget</strong><br>mongodb默认是fire-and-forget，即写操作通过TCP套接字发送，不要求数据库应答。如果需要应该，需要开启特殊的安全模式。安全模式可配置，还可以用于阻塞操作，知道写操作被复制到特定数量的服务器。</p>
<p><strong>自动分片</strong><br>mongodb是基于范围的分片方式，自动分片（auto-sharding)。单个分片由一个副本集组成，每个副本集至少三个节点，两个携带数据的副本，就能保证自动恢复，没有单点失败。</p>
<p><strong>副本集</strong><br>通常副本集由两个副本组成，再加上一个部署在第三台服务器上的仲裁进程（arbiter process）。对于mongodb的自动分片架构而言，其组建包含配置为预先分片的副本集的mongod进程，以及特殊的元数据服务器，称为配置服务器（config server），另外还有单独名为mongos的路由服务器向适当的分片发送请求。</p>
<p><strong>_id</strong><br>所有文档都要有一个主键，存储在_id字段里，只要保证唯一性，也可以输入自定义_id.如果省略了_id，会自动插入一个mongo对象ID。</p>
<h2 id="第二章_MongoDB_Javascript_Shell">第二章 MongoDB Javascript Shell</h2>
<p><strong>针对性更新（targeted modification)</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.users.update({“favorites.movies”:”sxxx”},{$addToSet:{“favorites.movies”:”ssff”},<span class="literal">false</span>,<span class="literal">true</span>)</div></pre></td></tr></table></figure>

<p>第四个参数为多项更新，如果为false，则更新（默认）只应用于查询选择器匹配的第一个文档。</p>
<p><strong>创建索引</strong><br>ensureIndex({num:1}),其中1表示升序，getIndexes()验证。<br>在查询语句后面紧跟.explain()可以看到查询计划。</p>
<p><strong>db.stats</strong><br>获取数据库与集合更底层的信息，db.stats()。<br>stats只是辅助方法，他封装了shell的命令调用方法，等同于<br>db.runCommand({dbstats:1})，往runCommand传递文档定义。<br>看下文档定义，执行去掉无括号的版本，db.runCommand。</p>
<h2 id="第三章_使用MongoDB编程程序">第三章 使用MongoDB编程程序</h2>
<p><strong>mongo数据驱动</strong><br>mongodb数据驱动三个功能：</p>
<ul>
<li>生成mongodb对象ID，即所有文档_id字段的默认值。</li>
<li>将所有语言特定的文档表述和BSON（mongodb的二级制数据格式）互相转化。</li>
<li>使用mongodb的网络协议通过TCP套接字与数据库通信。</li>
</ul>
<p><strong>对象ID</strong><br>mongodb对象ID是全局唯一的标识符，不会重复。<br>它由12个字节构成，<br>4字节时间戳，3字节机器ID，2字节进程ID，3字节计数器<br>如：4c291856 238d3b 19b2 000001<br>可以看到对象ID包含了时间戳，从而提供对象创建时间（秒）</p>
<p><strong>BSON数据类型</strong><br>BSON规范包含了19种数据类型，如UTF-8字符串，32位和64位整数，双精度浮点数，布尔值，时间戳，UTC时间（datetime），针对模糊对象的大数据（opaque blob），部分语言支持的符号类型（symbol type）</p>
<p><em>BSON格式</em><br>文档转化为BSON：头部4字节表明文档的大小，接下来N个键值对，<br>每对都由一个表示其类型的字节开头，随后由null结尾的字符串表示键名，然后是被存储的值，最后是一个null字节表示文档结束。如图：<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/mongoinaction1.png" alt="BSON格式"></p>
<p><strong>对象ID请使用BSON对象</strong><br>如果要存储mongodb对象id，应该使用mongodb对象ID，<br>而不是字符串，除了遵循对象ID的存储惯例，BSON对象还能比字符串省一半以上的空间。</p>
<p><strong>安全模式</strong><br>mongodb安全模式写入时，驱动会在插入消息后追加一条getlaterror命令。它做了两件事，getlasterror命令需要与服务器做一次通信，它确保写操作已经送达服务器。第二，验证服务器在当前链接中没有抛出任何错误。</p>
<h2 id="第四章_面向文档的数据">第四章 面向文档的数据</h2>
<p><strong>事务与原子性</strong><br>mongodb不支持事务，但它支持多种原子更新操作，用于复杂文档。</p>
<p><strong>数据库文件</strong><br>mongodb创建数据库时候，会在磁盘上分配一组数据文件，所有集合，索引和数据库其他元数据都保存在这个文件里。数据文件都被放在启动mongod时指定的dbpath里，如未指定，则保存在/data/db里。<br>如图：<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/mongoinaction2.png" alt="数据库文件"><br>各文件说明：<br>mongod.lock文件，其中存储了服务器进程ID（不要删除，会影响异常恢复）。<br>数据库文件本身依赖所属的数据库命令，garden.ns是第一个生成的文件，ns后缀表示namespaces，数据库每个集合和索引都有自己的namespace，namespace的元数据都放在这个文件里。</p>
<p>默认情况下.ns文件固定在16MB，大约可以存24000个命令空间，也就是数据库索引和集合总数不能超过24000，通过—nssize配置。<br>看文件大小garden.0 64mb,garden.1 128mb,这些是mongoldb预先分配的数据文件，新数据文件大小是前一个的两倍，直达上限2G，通过—noprealloc和—small files配置。</p>
<p><strong>空间使用</strong><br>stats命令检查已使用空间和已分配空间。<br>如图:<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/mongoinaction3.png" alt="空间使用"><br>其中fileSize字段表示数据分配文件空间的总和。也就是前面garden数据库两个文件之和。<br>dataSize是数据库BSON对象的实际大小，storageSize是dataSize加上集合增长预留的额外空间和未分配的已删除空间。<br>indexSize是索引大小的总和。<br>另：集合的每个数据文件里按照块分配文件，这些块称为区段（extent）。storageSize就是集合区段所分配空间的总和。</p>
<p><strong>固定集合capped collection</strong><br>原本只针对高性能日志场景设计的。大小固定，满了以后，后续插入会覆盖集合最先插入的文档。<br>与标准集合的区别：</p>
<ul>
<li>固定集合默认不为_id创建索引，插入更快，也可以自己构建。（不定义索引情况下，最好把固定集合用于顺序处理的数据结构，而非用于随机查询，为此，mongodb提供了一个特殊的排序操作符$natural，按照文档的插入顺序返回文档。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.user.actions.find().sort({“$natural”:-<span class="number">1</span>})）</div></pre></td></tr></table></figure>

<ul>
<li>固定集合不能删除文档，不能执行任何增加文档大小的更新操作。</li>
</ul>
<p>mongodb使用固定集合来完成复制，每个副本集的成员都会把所有的写操作记录到一个特殊的oplog.rs固定集合里。从节点顺序读取这个集合内容，然后应用到自己数据库内。</p>
<p><strong>BSON数字类型</strong><br>BSON只定义了三种数字类型，double，int，long。而javascript只支持一种数据类型Number，等价于IEEE的双精度浮点数。如果要存储为整数，需要NumberLong()或者NumberInt</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.numbers.save({n:NumberLong(<span class="number">5</span>)})</div></pre></td></tr></table></figure>

<p><strong>BSON type</strong><br>每种BSON类型有一个整数标识，<br>db.numbers.find({n:{$type:18}});<br>{“_id”: ObjectId(“4c581c9bd5bbeb2365a838fa”)}</p>
<p>BSON缺少对小数的支持</p>
<p><strong>BSON 日期与时间</strong><br>javascript里月份是从零开始<br>new Date(2011,5,11)是2011年6月11号</p>
<p><strong>文档大小限制</strong><br>v2.0中BSON文档大小限制在16MB，不同版本输入db.isMaster查看maxBsonObjectSize字段。<br>大小限制的原因，一是防止设计深层嵌套，二是性能，在服务器端查询大文档，在讲结果发送给客户端前需要将文档复制到缓冲区里，同时驱动反序列化开销很大。</p>
<h2 id="第五章_查询与聚合">第五章 查询与聚合</h2>
<p><strong>find与findOne</strong><br>find返回的是游标对象，findOne返回一个文档</p>
<p><strong>分页</strong><br>分页可以使用：skip，limit，sort，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">products = db.products.find({‘category_id’:category[‘_id<span class="string">']}).skip((page_number-1)*12).limit(12).sort({helpful_votes:-1})</span></div></pre></td></tr></table></figure>

<p><strong>集合操作</strong><br>$in,$all,$nin,接受数组参数</p>
<p><strong>布尔操作符</strong><br>$ne,$not,$or,$and,$exists<br>如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.products.find(‘details.manufacturer’:’ACME’,tags:{$ne:”gardening”})</div></pre></td></tr></table></figure>

<p>or可以应用于条件选择器数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.products.find({$or:[{‘details.color’:’blue’},{‘details.manufacturer’:’ACME<span class="string">'}]})</span></div></pre></td></tr></table></figure>

<p><strong>数组下标表示</strong><br>db.users.find({‘address.0.state’:’NY’})<br>其中0表示数组的第一个</p>
<p><strong>$elemMatch</strong><br>用于子文档的多个条件限制查询<br>db.users.find({address: {$elemMatch: {name: ‘home’,state: ’NY’}})</p>
<p><strong>size</strong><br>根据数组大小查询，$size，不走索引，只支持精确查找。推荐将数组大小作为一个字段放入集合中。</p>
<p><strong>$where</strong><br>可以手动编写javacript执行<br>db.reviews.find({$where: “function(){ return this.helpful_votes &gt; 3;}”})<br>this指向当前文档，不走索引，性能低。<br>可以配合一般查询语句缩小遍历集合后使用，</p>
<p><strong>正则表达式</strong><br>使用了忽略大小写的选项则无法在查询中使用索引，就算在前缀匹配中也是如此。原生正则表达式例子：<br>db.reviews.find({user_id: ObjectId(“xxxx”), text: /best|worst/i})<br>不能用原生，则用$regex和$options</p>
<p><strong>投影</strong><br>返回结果中去掉不需要的字段，如<br>db.users.find({}, {address:0, payment_method:0})</p>
<p><strong>$slince</strong><br>返回头多少条或者尾多少条信息，也可以接受两参数的形式，一个是跳过多少，一个是返回元素个数限制。</p>
<p><strong>$skip</strong><br>类似于offset ,最好省略skip，添加一个范围条件，提高性能。</p>
<p><strong>min与max</strong><br>不提供min(),max()，自己实现，按照某字段降序排序，再limit。</p>
<p><strong>distinct</strong><br>默认覆盖整个集合，返回字段的不同值集合，也可传入查询器。</p>
<p><strong>group</strong><br>group最少需要三个参数，第一个参数定义对key怎么分组，第二个参数是聚合的js函数，叫reduce函数，第三个参数为reduce函数初始文档。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">results = db.views.group({key:{user_id:<span class="literal">true</span>}, initial = {review:<span class="number">0</span>, vote:<span class="number">0.0</span>},</div><div class="line">    reduce = <span class="function"><span class="keyword">function</span><span class="params">(doc, aggregator)</span></span>{</div><div class="line">        aggregator.views += <span class="number">1.0</span>;</div><div class="line">        aggregator.votes += doc.votes;</div><div class="line">    },</div><div class="line">    finalize: <span class="function"><span class="keyword">function</span><span class="params">(doc)</span></span>{</div><div class="line">        doc.average_votes = doc.votes /doc.reviews;</div><div class="line">   }</div><div class="line">});</div></pre></td></tr></table></figure>

<p><strong>distinct与group结果集合大小限制</strong><br>distinct和group返回结果集合不能超过16MB，因为这两个命令是对特殊$cmd集合的查询。同时group不会处理多余10000个唯一键，不能满足的情况，使用map-reduce。</p>
<p><strong>map-reduce</strong><br>定义一个map函数，内部调用emit()，emit方法第一个参数是分组依据的key，第二个参数是包含执行reduce的文档。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">map = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">	<span class="keyword">var</span> shipping_moth = <span class="keyword">this</span>.purchase_date.getMonth() + ‘-‘+<span class="keyword">this</span>.purchase_data.getFullYear();</div><div class="line">	<span class="keyword">var</span> items = <span class="number">0</span>;</div><div class="line">	<span class="keyword">this</span>.line_items.forEach(<span class="function"><span class="keyword">function</span><span class="params">(item)</span></span>{</div><div class="line">		tmpItems += item.qunatity;</div><div class="line">	});</div><div class="line">	emit(shipping_month,{order_total:<span class="keyword">this</span>.sub_total, item_total:<span class="number">0</span>})</div><div class="line">}</div><div class="line">reduce = <span class="function"><span class="keyword">function</span><span class="params">(key,values)</span></span>{</div><div class="line">	<span class="keyword">var</span> tmpTotal = <span class="number">0</span>;</div><div class="line">	<span class="keyword">var</span> tmpItems = <span class="number">0</span>;</div><div class="line">	tmpTotal += doc.order_total;</div><div class="line">	tmpItems += doc.items_total;</div><div class="line">	<span class="keyword">return</span> ({total: tmpTotal, items:tmpItems)});</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="第六章_更新、原子操作与删除">第六章 更新、原子操作与删除</h2>
<p><strong>原子性</strong><br>所有发往核心服务器的更新都是原子的，以文档为单位进行隔离。说更新操作符是原子性的是因为他们能在不先查询的前提下完成更新。</p>
<p><strong>findAndModify</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">db.orders.findAndModify({</div><div class="line">	query:{}</div><div class="line">	update:{}</div><div class="line">})</div></pre></td></tr></table></figure>

<p>默认情况下findAndModify返回更新前的文档，要返回更新后的文档，要制定{new:true}</p>
<p><strong>多文档更新</strong><br>db.products.update({},{$addToSet:{tags:’cheap’’}}, false,true)</p>
<p><strong>upsert</strong><br>如果查询选择器匹配到文档则更新，无匹配则新增。一次只插入或更新一个文档。</p>
<p><strong>$inc</strong><br>递增，递减操作</p>
<p><strong>$unset</strong><br>能删除文档中特定的键，但作用在数组上，只是置为null，要删除删除，调用$pull和$pop.</p>
<p><strong>$addToSet和$each</strong><br>如果想在一个操作里向数组添加多个唯一的值，必须结合$each操作符来使用$addToSet</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.products.update({slug:’shovel’},{$addToSet: {’tags’: {$each: [’tools’,’dirts<span class="string">']}})</span></div></pre></td></tr></table></figure>

<p><strong>$pop</strong><br>删除最后添加的内容</p>
<p><strong>$pull</strong><br>与$pop类似，但更高级，可以明确制定删除哪个数组元素，而不是位置。</p>
<p><strong>基于位置的更新</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">query = {_id: ObjectId(“<span class="number">4</span>c4d1476238d3b4dd5003981”),</div><div class="line">‘line_items.sku’:”<span class="number">10027</span>”}</div><div class="line">update = {$set: {‘line_items.$.quantity’:<span class="number">5</span>}}</div><div class="line">db.orders.update(query,update)</div></pre></td></tr></table></figure>

<p>在line_items.$quantity字符串中$表示位置操作符,如果查询选择器匹配到了这个文档，那么有10027这个sku的文档的下标就会替换位置操作符，从而正确更新文档。</p>
<p><strong>mongodb锁策略</strong><br>全局锁，已废弃,具体参考mongodb jira<br>写锁让步，可以使用$atomic参数控制隔离执行，不被暂停</p>
<p><strong>更新性能</strong><br>文档更新三种：</p>
<ul>
<li>BSON大小不改变</li>
<li>BSON大小改变，头四个字节需要修改，或者增加字段</li>
<li>重写文档，预分配磁盘放不下，需要移动，为降低这类开销，mongodb会根据每个集合的情况动态调整填充因子(padding factor),也就是如果一个集合会发生很多重新分配的情况，会自动增加填充因子。填充因子*插入文档的大小后，为要额外创建的空间。</li>
</ul>
<h2 id="第七章_索引与查询优化">第七章 索引与查询优化</h2>
<p><strong>$or与索引</strong><br>$or查询里，每个$or查询子句，都能使用不同的索引，但每个子句本身只能使用一个索引。</p>
<p><strong>tip</strong><br>就算拥有正确索引，还是可能得不到快速的查询，索引和数据集无法完全加入内存，是要考虑的问题。</p>
<p><strong>标准索引</strong><br>索引是B树，集合存储为双向列表<br>mongodb的B树实现里，新节点会被分配8192字节，也就是说实际上每个节点能包含几百个键。请牢记，默认情况下，B节点内容有意维持在60%左右。</p>
<p><strong>稀疏索引</strong><br>当集合中大量文档都不包含被索引键。创建时指定{sparse:true}。在稀疏索引中，只会出现被索引键有值的情况。</p>
<p><strong>声明索引要小心</strong><br>构建会花很长时间，则无法中止。最明智的建议，将索引构建当成某类数据库迁移来看。</p>
<p><strong>后台索引</strong><br>不暂停数据库访问，在后台构建索引，对读操作主动让步。{background:true}</p>
<p><strong>备份</strong><br>如果想在备份中包含索引，需要直接备份mongodb的数据文件。</p>
<p><strong>reIndex</strong><br>reIndex，重建索引，占写锁，实例暂时无法使用。</p>
<p><strong>慢查询</strong><br>mongod服务器启动，—slowms 50会把筛选日志。</p>
<p><strong>剖析器</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">use stocks</div><div class="line">db.setProfilingLevel(<span class="number">2.50</span>)</div></pre></td></tr></table></figure>

<p>第一个参数，2表示读写，第二参数表示超过50ms都写日志。</p>
<p><strong>查询优化器的三个规则</strong></p>
<ul>
<li>避免scanAndOrder，使用索引排序</li>
<li>通过有效索引约束来满足所有字段</li>
<li>如果查询包含范围查询或者排序，对于选择的索引，其中最后用到的键需能满足该范围查询或者索引</li>
</ul>
<p><strong>查询计划</strong><br>explain，传入true，输出查询计划</p>
<p><strong>查询计划器的缓存</strong><br>在发现了一个成功的计划之后，会记录下查询模式(query pattern)/nscanned的值以及索引说明，如<br>{pattern: {stock_symbol:’equality’, close: ‘bound’}, index:{stock_symbol:1}, scanned:894}<br>查询模式记录下每个键匹配的类型，你正请求对stock_symbol的精确匹配（相等），对close的范围匹配，就会使用这个索引。</p>
<p><strong>查询计划期缓存过期</strong></p>
<ul>
<li>对集合执行了100次写操作</li>
<li>在集合上增加或删除了索引</li>
<li>虽然使用了缓存的查询计划，但工作量大于预期，及nscanned超过缓存nsscanned的10倍</li>
</ul>
<h2 id="第八章_复制">第八章 复制</h2>
<p><strong>两种复制风格</strong><br>mongodb提供了两种复制风格：主从复制，副本集。都是主节点写，异步同步到从节点。<br>推荐使用副本集，因为支持自动故障转移，只有mongodb需要超过11个从节点，则需要主从复制。</p>
<p>虽然副本是冗余的，但副本不是备份的替代品。</p>
<p><strong>副本集</strong><br>副本集，至少三个节点，包括一个仲裁节点，选主。<br>启服务略<br>isMaster查看副本信息，rs.status()更详细信息，启动完成stateStr字段会从revocering到primary，secondary，arbiter。</p>
<p><strong>测试选主</strong><br>ctrl-c,kill -2或者连接上主节点，db.shutdownServer()</p>
<p><strong>副本集的基础机制</strong><br>副本集依赖于两个基础机制，oplog和心跳。<br>oplog是个固定集合，位于每个复制节点的local数据库里，记录所有对数据的变更。查看当前副本状态的基本信息，db.getReplicationInfo()</p>
<p><strong>local库</strong><br>replset.minvalid指定副本集成员的初始同步信息<br>system.replset保存了副本集配置文档<br>me和slaves实现写专注<br>system.indeses标准索引</p>
<p><strong>副本同步</strong><br>从节点从主节点赋值oplog，做三件事</p>
<ul>
<li>查看oplog最后一条的时间戳</li>
<li>查询主节点oplog里所有大于此时间戳的记录</li>
<li>将这些记录添加到自己库里</li>
</ul>
<p><strong>心跳检测</strong><br>默认情况下，每个副本集成员每两秒ping一下其他所有成员。<br>如果没有多数节点，主节点会自动降为从节点。</p>
<p><strong>回滚</strong><br>当mongodb从节点升为主节点，会触发其他从节点回滚。略<br>在数据路径下rollback子目录保存了呗回滚的写操作，对每个回滚写操作集合，创建独立BSON文件，通过bsondump查询，mongorestore恢复。</p>
<p><strong>重新配置副本集</strong><br>无论何时，重新配置副本集导致重新选举新的主节点，那么所有客户端的链接都会被关闭，防止fire-and-forget风格的写操作。</p>
<p><strong>配置文件</strong></p>
<ul>
<li>arbiterOnly：仲裁节点只存储配置数据。</li>
<li>priority，决定了选举的权重，设置为0，表示被动节点，永远不会被选为主节点，可以用于灾难恢复节点。</li>
<li>buildIndex：如果永远不会成为主节点，priority为0，可以设置。</li>
<li>slaveDelay：如果要设置大于0，务必保证priority为0.<br>其他略</li>
</ul>
<p><strong>写关注</strong><br>getlastError(w,timeout，j:true)<br>第一个参数为需要同步到服务器的数量,w可以等于”majority”。<br>第二参数为超时时间。<br>j表示强制同步到journaing日志。</p>
<p><strong>读扩展</strong><br>Mongo:: ReplSetConnection.new([‘arete’, 40000], [‘arete’,40001], :read =&gt; :secondary)<br>read的设置，读会从选择附近一个从节点读取。</p>
<p>副本扩展无法处理一致性读，需要将一致性读的部分抽取出来。</p>
<h2 id="第九章_分片">第九章 分片</h2>
<p><strong>分片集群</strong><br>分片集群由分片，mongos路由器和配置服务器组成。<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/mongoinaction4.png" alt="分片集群"></p>
<p><strong>mongos路由器</strong><br>通常运行于应用服务器相同的机器上，提供所有读写请求的统一系统视图。mongos进程是轻量级非持久化的。</p>
<p><strong>配置服务器</strong><br>持久化分片集群的元数据，包括集群配置，每个数据库集合特定范围数据的位置，一份变更记录，保证数据在分片之间迁移的历史。</p>
<p>mongos对配置服务器写入时候，使用二阶段提交。配置服务器最好三个以上，同时存在于不同机器实现冗余。</p>
<p><strong>分片与块</strong><br>分片是基于范围的，分片建(shared key)。<br>块（chunk），位于分片种的一段连续的分片范围，如<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/mongoinaction5.png" alt="块与分片"></p>
<p>分片的重点是块的拆分和迁移，拆分是对元数据的逻辑操作，迁移是均衡器(balancer)处理的物理操作。</p>
<p><strong>分片索引</strong><br>每个分片都维护了自己的索引，分片集合上的索引声明，会对所有分片起效。<br>分片集合只允许在_id和分片键上添加唯一索引。</p>
<p>分片键无法修改。</p>
<p><strong>拓扑结构</strong><br>运行mongodb两分片集群，一共要启动九个进程，每个副本集三个mongod，外加三个配置服务器。其中副本集是资源密集型，需要暂用独立的机器，仲裁节点不需要，配置服务器间不共用机器。如图：<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/mongoinaction6.png" alt="两分片集群"></p>
<p>考虑到灾难恢复<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/mongoinaction7.png" alt="两分片集群+容灾"></p>
<p><strong>监控</strong><br>mongos上运行serverStatus和currentOp看到所有分片的聚合统计信息，或者查询config数据库，对于不均衡的块，进行split，movechunk。</p>
<p><strong>增加分片</strong><br>考虑向新分片移动的时间，预计每分钟100-200MB。在现有索引和工作集达到分片的90%就要开始计划。</p>
<p><strong>移除分片</strong><br>removeshard，会删除块，重新分配到其他分片上。</p>
<p><strong>集合去分片</strong><br>导出集合，再用不同名字将数据恢复到一个新的集合里。用mongodump连接mongos导出。</p>
<h2 id="第十章_部署与管理">第十章 部署与管理</h2>
<p><strong>时钟</strong><br>不同服务器见都是用NTP，网络时间，在linux上使用ntpd守护进程。</p>
<p><strong>journaling日志</strong></p>
<ul>
<li>会降低写操作性能</li>
<li>不保证不丢失写操作，只保证恢复一致状态。每100ms将写缓冲同步到磁盘。</li>
</ul>
<p><strong>副本集验证</strong><br>启动—keyfile指定密码文件，为至少6个base64字符集。</p>
<p><strong>服务器监控</strong></p>
<ul>
<li>serverStatus<br>输出页错误，B树访问率，打开连接数，总的插入，更新，查询和删除等。globalLock会显示所有锁的时间，currentQueue显示读写队列。mem部分是内存，理想状况下所有工作集都应该放到内存中。</li>
<li>top<br>操作计数器，显示操作的平均耗时。</li>
<li>db.currentOp()<br>返回正在运行的所有操作。要杀掉，db.killOp(opid)</li>
<li>mongostat<br>显示实时活动视图，以固定时间查询服务器信息，显示统计数据的矩阵，从每秒插入数到常驻内存量，再到B树页丢失频率。</li>
<li>web控制台<br>mongod的端口+1000为web控制台端口，一般为28017.</li>
</ul>
<p><strong>诊断工具</strong><br>mongosniff，mongodump略</p>
<p><strong>数据备份与恢复</strong><br>两种方式</p>
<ul>
<li>一个是mongodump，mongorestore</li>
<li>一个是基于原始数据的备份，大多数情况更快，但是要求锁定数据库，可以选择锁定从节点（可以保留全部索引）。</li>
</ul>
<p><strong>锁定数据库</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">use admin</div><div class="line">db.rumCommand({fsync:<span class="number">1</span>,lock:<span class="literal">true</span>})</div></pre></td></tr></table></figure>

<p>此时数据库是写锁定的。<br>解锁:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.$cmd.sys.unlock.findOne()</div></pre></td></tr></table></figure>

<p>再查看db.currentOp是否解锁</p>
<p><strong>压紧与修复</strong><br>mongod —repair<br>或者单个数据库<br>use cloud-docs<br>db.runCommand({repairDatabase:1})</p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
<hr>
<p>参考：《MongoDB实战》：<a href="http://book.douban.com/subject/19977785/" target="_blank" rel="external">http://book.douban.com/subject/19977785/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《MongoDB实战》的学习笔记。
</code></pre><h2 id="第一章_为现代Web而生的数据库">第一章 为现代Web而生的数据库</h2>
<p><em>特性</em><br>mongodb适合做水平扩展的数据库。<br>mongodb把文]]>
    </summary>
    
      <category term="mongodb" scheme="http://vernonzheng.com/tags/mongodb/"/>
    
      <category term="nosql" scheme="http://vernonzheng.com/tags/nosql/"/>
    
      <category term="mongodb" scheme="http://vernonzheng.com/categories/mongodb/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》第一章习题解答]]></title>
    <link href="http://vernonzheng.com/2015/01/12/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94/"/>
    <id>http://vernonzheng.com/2015/01/12/《快学scala》第一章习题解答/</id>
    <published>2015-01-12T14:20:42.000Z</published>
    <updated>2015-01-20T14:46:18.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。 </p>
<h2 id="第一章_基础">第一章 基础</h2>
<p><strong>1.1</strong><br>在Scala REPL中键入3,然后按Tab键。有哪些方法可以被应用? </p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">%   +   &gt;    &gt;&gt;&gt;            isInstanceOf   toDouble   toLong     unary_+   |</div><div class="line">&   -   &gt;=   ^              toByte         toFloat    toShort    unary_-</div><div class="line">*   /   &gt;&gt;   asInstanceOf   toChar         toInt      toString   unary_~</div></pre></td></tr></table></figure>

<p><strong>1.2</strong><br>在Scala REPL中，计算3的平方根,然后再对该值求平方。现在，这个结果与3相差多少？(提示:res变量是你的朋友) </p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="keyword">import</span> scala.math._</div><div class="line"><span class="keyword">import</span> scala.math._</div><div class="line"></div><div class="line">scala&gt; sqrt(<span class="number">3</span>)</div><div class="line">res7: Double = <span class="number">1.7320508075688772</span></div><div class="line"></div><div class="line">scala&gt; <span class="number">3</span> - res7</div><div class="line">res8: Double = <span class="number">1.2679491924311228</span></div></pre></td></tr></table></figure>

<p><strong>1.3</strong><br>res变量是val还是var? </p>
<p>答：<br>res变量是val</p>
<p><strong>1.4</strong><br>Scala允许你用数字去乘字符串—去REPL中试一下”crazy”*3。这个操作做什么？在Scaladoc中如何找到这个操作? </p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="string">"crazy"</span>*<span class="number">3</span></div><div class="line">res9: String = crazycrazycrazy</div></pre></td></tr></table></figure>

<p>scala docs 去查StringOps:<a href="http://www.scala-lang.org/api/current/#scala.collection.immutable.StringOps" target="_blank" rel="external">http://www.scala-lang.org/api/current/#scala.collection.immutable.StringOps</a></p>
<p><strong>1.5</strong><br>10 max 2的含义是什么？max方法定义在哪个类中？</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="number">10</span> max <span class="number">2</span></div><div class="line">res10: Int = <span class="number">10</span></div></pre></td></tr></table></figure>

<p>返回两者中比较大的一个<br>max方法定义在RichInt方法中。<a href="http://www.scala-lang.org/api/current/#scala.runtime.RichInt" target="_blank" rel="external">http://www.scala-lang.org/api/current/#scala.runtime.RichInt</a></p>
<p><strong>1.6</strong><br>用BigInt计算2的1024次方</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scala&gt; BigInt(<span class="number">2</span>).pow(<span class="number">1024</span>)</div><div class="line">res13: scala.math.BigInt = <span class="number">179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216</span></div></pre></td></tr></table></figure>

<p><strong>1.7</strong><br>为了在使用probablePrime(100,Random)获取随机素数时不在probablePrime和Radom之前使用任何限定符，你需要引入什么？</p>
<p>答：<br>import需要的包。Random在scala.util中，而probablePrime是BigInt中的方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.math.BigInt._  </div><div class="line"><span class="keyword">import</span> scala.util.Random  </div><div class="line">  </div><div class="line">probablePrime(<span class="number">100</span>,Random) </div><div class="line">res15: scala.math.BigInt = <span class="number">1137139793510393954801305013479</span></div></pre></td></tr></table></figure>

<p><strong>1.8</strong><br>创建随机文件的方式之一是生成一个随机的BigInt，然后将它转换成三十六进制，输出类似”qsnvbevtomcj38o06kul”这样的字符串。查阅Scaladoc，找到在Scala中实现该逻辑的办法。</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scala&gt; scala.math.BigInt(scala.util.Random.nextInt).toString(<span class="number">36</span>)</div><div class="line">res19: String = -wda3r0</div></pre></td></tr></table></figure>

<p><strong>1.9</strong><br>在Scala中如何获取字符串的首字符和尾字符？</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="string">"Hello"</span>(<span class="number">0</span>)</div><div class="line">res20: Char = H</div><div class="line"></div><div class="line">scala&gt; <span class="string">"Hello"</span>.take(<span class="number">1</span>)</div><div class="line">res21: String = H</div><div class="line"></div><div class="line">scala&gt; <span class="string">"Hello"</span>.reverse(<span class="number">0</span>)</div><div class="line">res22: Char = o</div><div class="line"></div><div class="line">scala&gt; <span class="string">"Hello"</span>.takeRight(<span class="number">1</span>)</div><div class="line">res23: String = o</div></pre></td></tr></table></figure>

<p><strong>1.10</strong><br>take,drop,takeRight和dropRight这些字符串函数是做什么用的？和substring相比，他们的优点和缺点都是哪些？</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="string">"Hello world"</span>.take(<span class="number">3</span>)</div><div class="line">res26: String = Hel</div><div class="line"></div><div class="line">scala&gt; <span class="string">"Hello world"</span>.takeRight(<span class="number">3</span>)</div><div class="line">res27: String = rld</div><div class="line"></div><div class="line">scala&gt; <span class="string">"Hello world"</span>.drop(<span class="number">3</span>)</div><div class="line">res28: String = lo world</div><div class="line"></div><div class="line">scala&gt; <span class="string">"Hello world"</span>.dropRight(<span class="number">3</span>)</div><div class="line">res29: String = Hello wo</div><div class="line"></div><div class="line">scala&gt; <span class="string">"Hello world"</span>.take(<span class="number">3</span>).drop(<span class="number">1</span>)</div><div class="line">res32: String = el</div></pre></td></tr></table></figure>

<p>take,drop,takeRight,dropRight适合从两边处理字符串，很方便可以配合使用，substring适合处理中间的字符串。</p>
<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2014年终小结与书单]]></title>
    <link href="http://vernonzheng.com/2014/12/28/2014%E5%B9%B4%E7%BB%88%E5%B0%8F%E7%BB%93%E4%B8%8E%E4%B9%A6%E5%8D%95/"/>
    <id>http://vernonzheng.com/2014/12/28/2014年终小结与书单/</id>
    <published>2014-12-28T08:36:23.000Z</published>
    <updated>2014-12-28T11:10:11.000Z</updated>
    <content type="html"><![CDATA[<pre><code>年初觉得可能发生的事情，大多数都发生了。
</code></pre><h2 id="一、2014小结">一、2014小结</h2>
<p>去了青岛，舟山，上海，路过香港，台湾12天环岛。（台湾之行，加大我对环球游梦的‘执念’）</p>
<p>11月份，根据地从杭州搬到了北京。（搬家是件痛苦的事情，特别是书都得处理掉，好处是杂乱的东西都可以丢了）</p>
<p>工作换了两家，经历了一些波折，11月连续两周的面试，第一次体会了面霸的感觉，这也是大北京的优势，公司多。离年初和同学戏称的30岁金钱目标，意外的跨了一大步，同时又觉得路程还很远，养成习惯和身体健康的重要性。</p>
<p>学习方面，英语没有任何质变。。唯一欣慰的是今年读了39本书。</p>
<p>附：<br>我的足迹：<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/2014_year_foot_print" alt="2014_foot_print"></p>
<h2 id="二、2015目标">二、2015目标</h2>
<p>既然是总结，就不得不写一些2015的目标。</p>
<ul>
<li>英语：为了环球游的‘执念’，蹩脚的英语得加把劲了，每天90分钟的听说练习，至少日常口语没问题，流利的聊天更好。</li>
<li>刷书，积累：技术类30本，其他类20本，英语原版书3本以上。</li>
<li>坚持锻炼：养成每天早上起床锻炼的习惯，《囚徒健身》。</li>
<li>旅行：精神和身体都得奔跑在路上。既然base在北京，周边几个省的旅游机会别浪费了。</li>
<li>职业：写的像招聘信息。。熟练掌握scala，nodejs，仔细阅读kafka，nignx源码，了解下大数据处理相关（spark，hadoop），分析问题能追到c实现，能写点基于unix的偏底层的网络程序，用scala写一些中间件。技能水平，从应用级别高级开发到类库框架级别的高级开发吧。</li>
</ul>
<h2 id="三、2014书单">三、2014书单</h2>
<p>我的2014书单，书封面就不贴了，可以参考我的豆瓣读书：<a href="http://book.douban.com/people/vernonzheng/" target="_blank" rel="external">http://book.douban.com/people/vernonzheng/</a></p>
<h3 id="3-1_IT技术类">3.1 IT技术类</h3>
<ul>
<li><p>《深入理解Java虚拟机：JVM高级特性与最佳实践》<br>周志明<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/深入理解Java虚拟机.jpg" alt="深入理解Java虚拟机"><br>5星，非常推荐。</p>
</li>
<li><p>《Java并发编程实践》<br>Brian Goetz、Tim Peierls、Joshua Bloch、Joseph Bowbeer、David Holmes、Doug Lea / 童云兰<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/Java并发编程实战.jpg" alt="Java并发编程实践"><br>5星，非常推荐，有点理论程度的。</p>
</li>
<li><p>《高性能MySQL》<br>Baron Schwartz、Peter Zaitsev、Vadim Tkachenko、Jeremy D.Zawodny、Arjen Lent、Derek J.Ballin / 王小东、李军、康建勋<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/高性能MySQL.jpg" alt="高性能MySQL"><br>5星，非常推荐，特别是4，5，6章的索引，查询优化等等讲的很透彻。</p>
</li>
<li><p>《领域特定语言》<br>Martin Fowler / ThoughtWorks中国<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/领域特定语言.jpg" alt="领域特定语言"><br>5星，Martin难得出那么厚的书，写的很好，只看了前几章理论部分，后面的实用性挺高。</p>
</li>
<li><p>《设计模式：可复用面向对象软件的基础》<br>GOF<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/设计模式 - 可复用面向对象软件的基础.jpg" alt="设计模式"><br>5星，不是很推荐，惜字如金，有点难度，以后还得翻。</p>
</li>
<li><p>《点石成金：访客至上的网页设计秘笈》<br>[美] 史蒂夫·克鲁克 / De Dream’<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/点石成金.jpg" alt="点石成金"><br>5星，推荐，英文名是Don’t make me think，特点是很薄，147页。</p>
</li>
<li><p>《大型网站系统与Java中间件开发实践》<br>曾宪杰<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/大型网站系统与Java中间件开发实践.jpg" alt="大型网站系统与Java中间件开发实践"><br>5星，没有特别高深的概念，能学会解决这类问题的思路，结合非常实际的案例在讲。</p>
</li>
<li><p>《人月神话》<br>弗雷德里克.布鲁克斯 / UMLChina翻译组、汪颖<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/人月神话.jpg" alt="人月神话"><br>4星，多少年前的书，却相当经典。</p>
</li>
<li><p>《MySQL技术内幕：SQL编程》<br>姜承尧<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/MySQL技术内幕 - SQL编程.jpg" alt="MySQL技术内幕：SQL编程"><br>4星，对于有一些数据库设计开发经验的人，有许多技巧性和细节性的建议和提高。</p>
</li>
<li><p>《测试驱动开发：实战与模式解析》<br>Kent Beck / 白云鹏<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/测试驱动开发.jpg" alt="测试驱动开发"><br>4星，翻译不太好，kent beck的书实在少，只能看个经典旧书了。</p>
</li>
<li><p>《The Little Book on CoffeeScript》<br>Alex MacCaw<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/The Little Book on CoffeeScript.jpg" alt="The Little Book on CoffeeScript"><br>4星，实用，简短，快速上手。</p>
</li>
<li><p>《Node.js实战》<br>[美] Mike Cantelon、[美] TJ Holowaychuk、[美] Nathan Rajlich<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/node.js 实战.jpg" alt="Node.js实战"><br>4星，有些翻译问题，适合做nodejs的前两本入门书。</p>
</li>
<li><p>《Spring实战》<br>沃尔斯 (Craig Walls) / 耿渊、张卫滨<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/Spring实战.jpg" alt="Spring实战"><br>4星，过一下基础。</p>
</li>
<li><p>《Maven实战》<br>许晓斌<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/Maven实战.jpg" alt="Maven实战"><br>4星，内容比较全，稍微有点拖沓。</p>
</li>
<li><p>《Robust Java中文版：Java异常处理、测试与调试》<br>史德汀<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/Robust Java 中文版 - Java异常处理、测试与调试.jpg" alt="Robust Java中文版"><br>3星，介绍了java异常的体系结构，设计，开发，测试，架构，比较基础和全面。</p>
</li>
<li><p>《Java 7 Concurrency Cookbook》<br>Fernandez Javier / Packt Publishing<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/Java 7 Concurrency Cookbook.jpg" alt="Java 7 Concurrency Cookbook"><br>3星，就当查漏补缺了。</p>
</li>
<li><p>《Netty权威指南》<br>李林峰<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/Netty权威指南.jpg" alt="Netty权威指南"><br>3星，作者没有用心写感觉。。</p>
</li>
</ul>
<h3 id="3-2_IT非技术类">3.2 IT非技术类</h3>
<ul>
<li><p>《重来》<br>[美] 贾森·弗里德、[丹] 戴维·海涅迈尔·汉森 / 李瑜偲<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/重来.jpg" alt="重来"><br>5星，推荐，设计商业，创业，软件设计，需求，技术等，触发思考的内容远超一个创业书的范围。</p>
</li>
<li><p>《黑客与画家》<br>[美] Paul Graham / 阮一峰<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/黑客与画家.jpg" alt="黑客与画家"><br>5星，硅谷创业之父Paul Graham文集，黑客精神，创业，lisp等。</p>
</li>
<li><p>《暗时间》<br>刘未鹏<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/暗时间.jpg" alt="暗时间"><br>5星，知识密度相当大</p>
</li>
<li><p>《MacTalk 人生元编程》<br>池建强<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/MacTalk 人生元编程.jpg" alt="MacTalk 人生元编程"><br>3星，如果你喜欢编程的乐趣和mac相关内容，可以翻一翻。</p>
</li>
<li><p>《软件架构师的12项修炼》<br>Dave Hendricksen / 张菲<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/软件架构师的12项修炼.jpg" alt="软件架构师的12项修炼"><br>2星，讲的太泛了，没啥实用性</p>
</li>
</ul>
<h3 id="3-3_其他杂类">3.3 其他杂类</h3>
<ul>
<li><p>《人间词话》<br>王国维<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/人间词话.jpg" alt="人间词话"><br>5星，有一半是对古人词的赏析，之外对于境界的理解部分收获很多。</p>
</li>
<li><p>《正见：佛陀的证悟》<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/正见.jpg" alt="正见"><br>宗萨蒋扬钦哲仁波切 / 姚仁喜<br>5星，有兴趣的人可以看看，讲佛家四见地的。因为书中“佛陀看一个人，是看到他的圆熟和衰朽同时在发生。”这句话，去看了这本书。</p>
</li>
<li><p>《囚徒健身》<br>保罗·威德<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/囚徒健身.jpg" alt="囚徒健身"><br>5星，简单，实用。</p>
</li>
<li><p>《少有人走过的路：心智成熟的旅程》<br>[美] M·斯科特·派克 / 于海生<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/少有人走的路 - 心智成熟的旅程.jpg" alt="少有人走过的路：心智成熟的旅程"><br>5星，推荐前半部分</p>
</li>
<li><p>《撒哈拉的故事》<br>三毛<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/撒哈拉的故事.jpg" alt="撒哈拉的故事"><br>5星，echo作品里最喜欢的一本。她的文字和独特壮阔的生活方式，有一种特别的魅力，无论是孤独还是爱的追寻，真实＆真挚的让人感动。</p>
</li>
<li><p>《穷游锦囊：骑行台湾》<br>穷游网<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/穷游锦囊：骑行台湾.jpg" alt="穷游锦囊"><br>5星，穷游系列的书都很不错。台湾环岛攻略就靠这个系列。</p>
</li>
<li><p>《如何阅读一本书》<br>[美] 莫提默·J. 艾德勒、查尔斯·范多伦 / 郝明义、朱衣<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/如何阅读一本书.jpg" alt="如何阅读一本书"><br>4星，推荐，多读书，多总结适合自己的方式。</p>
</li>
<li><p>《女人的性爱动机》<br>【美】辛迪•梅斯顿、【美】戴维•巴斯 / 海兰、插画师：顾爷<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/女人的性爱动机.jpg" alt="女人的性爱动机"><br>4星，生理和心理角度看待问题，前几章不错。</p>
</li>
<li><p>《我所理解的生活》<br>韩寒<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/我所理解的生活.jpg" alt="我所理解的生活"><br>4星，多年没读韩寒，变化挺大。</p>
</li>
<li><p>《天才在左，疯子在右》<br>高铭<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/天才在左 疯子在右.jpg" alt="天才在左，疯子在右"><br>4星，国内第一本精神病人访谈手记，你可以把它当做故事书，很有趣。</p>
</li>
<li><p>《慢慢来，一切都来得及》<br>meiya<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/慢慢来.一切都来得及.jpg" alt="慢慢来，一切都来得及"><br>4星，被打动的一本书，讲述奋斗路上作者的生命体验。</p>
</li>
<li><p>《魔鬼约会学》<br>魔鬼咨询师<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/魔鬼约会学.jpg" alt="魔鬼约会学"><br>4星，男女思考行为的差距，还有一些活泼的例子。</p>
</li>
<li><p>《5分钟和陌生人成为朋友-101个瞬间化解尴尬的沟通技巧-II : 101个瞬间化解尴尬的沟通技巧》<br>唐·加博尔 / 何云<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/5分钟和陌生人成为朋友-101个瞬间化解尴尬的沟通技巧-II - 101个瞬间化解尴尬的沟通技巧.jpg" alt="5分钟和陌生人成为朋友"><br>3星，例子比较实用，先有心，后有术。</p>
</li>
<li><p>《二十五岁的世界：我在25座城市，遇见的25个人》<br>(西)马克•塞雷纳 / 吴娴敏<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/二十五岁的世界.jpg" alt="二十五岁的世界"><br>3星，印度，菲利宾，津巴布韦到日本寺庙。。有许多细节被震撼到。</p>
</li>
<li><p>《我是个算命先生》<br>易之<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/我是个算命先生.jpg" alt="我是个算命先生"><br>3星，amazon上卖的很火，但是和盗墓笔记比差太多，是纯小说。</p>
</li>
<li><p>《潜伏职场心理学》<br>张超<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/职场潜伏心理学.jpg" alt="潜伏职场心理学"><br>3星，茶语饭后翻一番，还是有收获的。</p>
</li>
<li><p>《软件架构师的12项修炼》<br>Dave Hendricksen / 张菲<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/软件架构师的12项修炼.jpg" alt="软件架构师的12项修炼"><br>2星，讲的太泛了，没啥实用性</p>
</li>
</ul>
<p>完。</p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>年初觉得可能发生的事情，大多数都发生了。
</code></pre><h2 id="一、2014小结">一、2014小结</h2>
<p>去了青岛，舟山，上海，路过香港，台湾12天环岛。（台湾之行，加大我对环球游梦的‘执念’）</p>
<p>11月份，根据地]]>
    </summary>
    
      <category term="日记" scheme="http://vernonzheng.com/tags/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="书单" scheme="http://vernonzheng.com/tags/%E4%B9%A6%E5%8D%95/"/>
    
      <category term="日记" scheme="http://vernonzheng.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NodeJS实战经验总结]]></title>
    <link href="http://vernonzheng.com/2014/12/28/NodeJS%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <id>http://vernonzheng.com/2014/12/28/NodeJS实战经验总结/</id>
    <published>2014-12-28T05:07:57.000Z</published>
    <updated>2014-12-29T01:17:18.000Z</updated>
    <content type="html"><![CDATA[<pre><code>看完《Node.js 实战》，整理总结了觉得比较有价值的内容。
</code></pre><h2 id="1、require">1、require</h2>
<p>require是少有的同步i/o操作，请只在模块初始化时候使用require。</p>
<h2 id="2、exports与module-exports的区别">2、exports与module.exports的区别</h2>
<p>最终程序里导出的都是module.exports。<br>而exports只是对module.exports的一个<strong>全局引用</strong>，如exports.myFunc为module.exports.myFunc的简写。<br>为了不破坏exports对module.exports的引用，不能设置exports。<br>如果破坏了，修复方式：<br>module.exports = exports = Currency;</p>
<h2 id="3、模块缓存与猴子补丁：">3、模块缓存与猴子补丁：</h2>
<p>Node 能把模块作为对象缓存起来。<br>如果程序中的两个文件引入了相同的模块，第一个文件会把模块返回的数据存到程序的内存中，这样第二个文件就不用再去访问和计算模块的源文件了。<br>实际上在第二个引入是有机会修改缓存数据的。这种方式称为“猴子补丁”（monkey patching ）：让一个模块可以改变另一个模块的行为，开发人员可以不用创建它的新版本。</p>
<h2 id="4、Node两种常用的响应逻辑组织方式">4、Node两种常用的响应逻辑组织方式</h2>
<p><strong>一次性为回调函数，绑定的为事件</strong>（继承event emitter事件发射器，emit发射消息）</p>
<p>这里给个event emitter的例子：</p>
<p>扩展文件监视器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**Watcher构造器**/</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Watch</span><span class="params">(watchDir, processDir)</span></span>{</div><div class="line">	<span class="keyword">this</span>.watchDir = watchDir;</div><div class="line">	<span class="keyword">this</span>.processedDir = processDir;</div><div class="line">}</div><div class="line"><span class="comment">/**继承eventEmitter行为**/</span></div><div class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(‘events’);</div><div class="line">util = reuqire(‘util’);</div><div class="line">util = util.inherits(Watcher, event.EventEmitter);</div><div class="line"></div><div class="line"><span class="comment">/**相当于Watcher.prototype = new events.EventEmitter();**/</span></div><div class="line"></div><div class="line"><span class="comment">/**再增加两个功能**/</span></div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(‘fs’)</div><div class="line">, watchDir = ‘./watch’</div><div class="line">, processedDir = ‘./done’</div><div class="line"></div><div class="line">Watcher.prototype.watch = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">	<span class="keyword">var</span> watcher = <span class="keyword">this</span>;</div><div class="line">	fs.readdir(<span class="keyword">this</span>.watchDir, <span class="function"><span class="keyword">function</span><span class="params">(err, files)</span></span>{</div><div class="line">		<span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</div><div class="line">		<span class="keyword">for</span>( <span class="keyword">var</span> index <span class="keyword">in</span> files){</div><div class="line">			watcher.emit(‘process’, files[index]);</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div><div class="line">Watcher.prototype.start = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">	<span class="keyword">var</span> watcher = <span class="keyword">this</span>;</div><div class="line">	fs.watchFile(watchDir, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">		watcher.watch();</div><div class="line">	});</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="5、减少if/else引起的回调嵌套">5、减少if/else引起的回调嵌套</h2>
<p>有两种方式，可以结合到一起用：</p>
<ul>
<li>（1）嵌套间引入中间函数，通过函数调用拆分嵌套</li>
<li>（2）尽早从函数中返回</li>
</ul>
<h2 id="6、Node的异步回调惯例">6、Node的异步回调惯例</h2>
<p>Node大多数内置模块使用回调会带两个参数，一个是err或者er，一个是存放结果。</p>
<h2 id="7、进程退出会等待事件异步完成">7、进程退出会等待事件异步完成</h2>
<p>Node的事件轮询会跟踪还没有完成的异步逻辑，只要有未完成的异步逻辑，Node进程就不会退出。事件轮询会跟踪所有数据库连接，知道它们关闭，以防止Node退出。</p>
<h2 id="8、在Node中使用闭包保留全局变量示例">8、在Node中使用闭包保留全局变量示例</h2>
<p>示例，用闭包私有化color值：<br>这里有一个asyncFunction函数，对它的调用被封装到一个匿名函数里，参数为color。<br>这样你就可以马上执行这个匿名函数，把当前的 color 的值传给它。而color 变成了匿名函数内部的本地变量，当 匿名函数外面的color 值发生变化时，本地版的color 不会受影响。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunction</span><span class="params">(callback)</span></span>{</div><div class="line">     setTimeout(callback, <span class="number">200</span>);</div><div class="line">}</div><div class="line"><span class="keyword">var</span> color = ‘blue’;</div><div class="line">(<span class="function"><span class="keyword">function</span><span class="params">(color)</span></span>{</div><div class="line">     asyncFunction(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">         <span class="built_in">console</span>.log(’The color is ‘ + color);</div><div class="line">     })(color);</div><div class="line">color = ‘green’;</div></pre></td></tr></table></figure>

<h2 id="9、Node的content-length与chunk">9、Node的content-length与chunk</h2>
<p>Node默认是chunk方式传输（块编码）。当设置content-length时，会隐含禁用Node的块编码。设置content-length传输，数据更少，提升性能。</p>
<p><strong>注意</strong>：<br>content-length是字节长度，不是字符长度，一般用Buffer.byteLength(body)</p>
<h2 id="10、__dirname">10、__dirname</h2>
<p>__dirname表示文件所在目录的路径，在开发时，这个目录和当前工作目录（CWD）是同个目录，但是生产环境可能是从另外一个目录运行。</p>
<h2 id="11、中间件设计惯例">11、中间件设计惯例</h2>
<p>中间件一般有三个参数：请求，响应，回调函数next<br>为了提供可配置能力，中间件遵循一个惯例：用函数返回另一个函数（闭包）</p>
<p>可配置中间件的<strong>基本结构</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setup</span><span class="params">(options)</span></span>{</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(req,res,next)</span></span>{</div><div class="line">	<span class="comment">//中间件逻辑</span></div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.use(setup({some:’options’}))</div></pre></td></tr></table></figure>

<h2 id="12、错误处理中间件">12、错误处理中间件</h2>
<p>错误处理中间件与普通中间三个参数不同，多了第一个参数err，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">errorHandler</span><span class="params">()</span></span>{</div><div class="line">	<span class="keyword">var</span> env = process.env.NODE_ENV || ‘development’;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(err, req, res, next)</span></span>{</div><div class="line">		res.statusCode = <span class="number">500</span>;</div><div class="line">		<span class="keyword">switch</span>(env){</div><div class="line">		<span class="keyword">case</span> ‘development’:</div><div class="line">			res.setHeader(‘content-type’, ‘application/json’);</div><div class="line">			res.end(<span class="built_in">JSON</span>.stringify(err));</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			res.end(’Server error’);</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>当Connect遇到错误，它会跳过后续的中间件，只调用错误处理中间件。</strong></p>
<p>在使用connect时，错误处理有三种方式：</p>
<ul>
<li>（1）使用Connect 默认的错误处理器；</li>
<li>（2）自己处理程序错误；</li>
<li>（3）使用多个错误处理中间件组件。</li>
</ul>
<p>第三种给个示例：<br>多个错误处理器的实现：<br>api挂载在/api上：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> api = connect()</div><div class="line">	.use(users)</div><div class="line">	.use(pets)</div><div class="line">	.use(errorHandler);</div><div class="line"></div><div class="line"><span class="keyword">var</span> app = connec()</div><div class="line">	.use(hello)</div><div class="line">	.use(<span class="string">'/api'</span>, api)</div><div class="line">	.use(errorPage)</div><div class="line">	.listen(<span class="number">3000</span>);</div></pre></td></tr></table></figure>

<p><img src="http://7te9ul.com1.z0.glb.clouddn.com/nodejs_in_action_duplicate_error_handle.png" alt="connect_dumplicate_error"><br>其中errorHandler处理来自api的所有错误，error处理来自app的所有错误。</p>
<h2 id="13、connect中间件">13、connect中间件</h2>
<p>包括：</p>
<ul>
<li>（1）cookieParser：为后续中间件提供req.cookies和req.signedCookies，<br>设置cookie这样用：res.setHeader(’Set-Cookie’,’’)</li>
<li>（2）bodyParser：为后续中间件提供req.body和req.files</li>
<li>（3）limit：基于给定字节长度限制请求主体的大小。必须用在bodyParser中间件之前，防止攻击。<br>更灵活的使用：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">app.use(type(‘application/x-www-form-urlencoded’, connect.limit(‘<span class="number">64</span>kb’))</div><div class="line">app.use(type(‘appication/json’, connect.limit(‘<span class="number">32</span>kb’)))</div></pre></td></tr></table></figure>

<ul>
<li>（4）query：为后续中间件提供req.query</li>
<li>（5）logger：将http请求的信息输出到stdout或日志文件之类的流中</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.user(connect.logger(‘dev’))</div></pre></td></tr></table></figure>

<p>输出有颜色区分的日志，便于开发调试<br><strong>两种输出日志频率</strong><br>immediate，表示一收到请求，就写日志。<br>buffer，以毫秒为单位，指定缓冲区刷新的时间间隔。</p>
<ul>
<li>（6）favicon：响应/favicon.ico http请求。通常放在中间件logger前面，这样它就不会出现在你的日志中了</li>
<li>（7）methodOverride：可以替不能使用正确请求方法的浏览器仿造req.method,依赖于bodyParser</li>
<li>（8）vhost：根据制定的主机名（如nodejs.org)使用给定的中间件和http服务器实例<br>可以做反向代理，缺点：一个网站崩溃，他的所有网站都会崩溃，一个都在同一个进程</li>
<li>（9）session：为用户设置一个http回话，并提供一个可以跨域请求的持久化req.session对象，依赖于cookieParser</li>
<li>（10）basicAuth：为程序提供http基础认证</li>
<li>（11）csrf：防止http表单中的跨站请求仿造攻击，依赖于session</li>
<li>（12）errorHandler：当出现错误时把堆栈跟踪信息返回给客户端。在开发时使用，不要在生产环境中使用</li>
<li>（13）static：把制定目录中的文件发给http客户端，跟connect的挂在功能配合得很好<br>返回./public目录下的静态资源文件：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.use(connect.static(‘public’));</div></pre></td></tr></table></figure>

<p>默认请求/js/test.js，会去.public/js/test.js去查找。<br>使用带挂载的static</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.use(‘/app/files’, connect.static(‘public’));</div></pre></td></tr></table></figure>

<ul>
<li>（14）compress：用gzip压缩优化http响应</li>
<li>（15）directory：为http客户端提供目录清单服务，基于客户端的accept请求（普通文件，son或html）提供经过优化的结果</li>
</ul>
<h2 id="14、_Express中两种渲染视图方式">14、 Express中两种渲染视图方式</h2>
<ul>
<li>（1）在程序中使用app.render（）</li>
<li>（2）在请求或者响应层用res.render()</li>
</ul>
<h3 id="14-1_视图的查找设置">14.1 视图的查找设置</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.set(‘views’,__dirname+’/views’);</div></pre></td></tr></table></figure>

<h3 id="14-2_设置模板引擎">14.2 设置模板引擎</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">app.set(‘view engine’, ‘jade’);</div><div class="line">app.get(‘/‘, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">     <span class="comment">/**假定为.jade**/</span>    </div><div class="line">     res.render(‘index’);</div><div class="line">});</div><div class="line">app.get(‘/feed’, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">     <span class="comment">/**因为扩展名为.ejs,所以使用EJS**/</span></div><div class="line">     res.render(‘rss.ejs’);</div><div class="line">});</div></pre></td></tr></table></figure>

<h3 id="14-3_视图缓存">14.3 视图缓存</h3>
<p>默认会开启view cache，模板修改，需要重启生效。</p>
<h3 id="14-4_视图查找">14.4 视图查找</h3>
<p>如photos为复数，暗示是一个资源列表。<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/blognodejs_in_action_express_view_search.png" alt="express_search"></p>
<h2 id="15、单元测试与验收测试">15、单元测试与验收测试</h2>
<p>有两种形态：测试驱动（TDD）和行为驱动开发（BDD）</p>
<ul>
<li>单元测试有Node的assert，Mocha，node unit，Vows以及should.js框架</li>
<li>验收测试，Tobi和Soda框架。<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/nodejs_in_action_test_soda.png" alt="test-modules-summary"></li>
</ul>
<h3 id="15-1_nodeunit：">15.1 nodeunit：</h3>
<p>例子：创建一个目录，每个测试脚本都应该用测试组装exports对象，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">exports.testPony = <span class="function"><span class="keyword">function</span><span class="params">(test)</span></span>{</div><div class="line">     <span class="keyword">var</span> isPony = <span class="literal">true</span>;</div><div class="line">     test.ok(isPony, ’This is not a pony.’);</div><div class="line">     test.done();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>nodeunit会自动给传入它的对象中引入assert模块。<br>nodeunit提供test.epect验证断言执行数量是否符合预期。</p>
<h3 id="15-2_mocha">15.2 mocha</h3>
<p>只支持串行测试，默认2s的timeout，并行请用vows：<br>BDD风格：describe,it,before,after,beforeEach,afterEach.<br>TDD风格：suite，test，setup，teardown替换上述</p>
<p>执行mocha，会执行./test目录下的javascript文件。</p>
<ul>
<li><strong>BDD风格</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> memdb = <span class="built_in">require</span>(‘..’);</div><div class="line"><span class="keyword">var</span> assert = <span class="built_in">require</span>(‘assert’);</div><div class="line"></div><div class="line">describe(‘memdb’, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">     describe(‘.save(doc)’, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">         it(’should save the documment’, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">              <span class="keyword">var</span> pey = { name: ’Tobi’ );</div><div class="line">               memdb.save(pet);</div><div class="line">               <span class="keyword">var</span> ret = memdb.first({ name: ’Tobi’ });</div><div class="line">               assert(ret == pet);</div><div class="line">          }</div><div class="line">     )</div><div class="line">)</div></pre></td></tr></table></figure>

<ul>
<li><strong>TDD风格</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = {</div><div class="line">     ‘memdb’ : {</div><div class="line">          ‘.save(doc)’ : {</div><div class="line">               ’should save the <span class="built_in">document</span>’ : <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">               }</div><div class="line">           }</div><div class="line">       }</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li><strong>测试异步</strong><br>增加done（）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">describe(‘.save(doc)’, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">     it(’should save the <span class="built_in">document</span>’, <span class="function"><span class="keyword">function</span><span class="params">(done)</span></span>{</div><div class="line">         <span class="keyword">var</span> pey = { name: ’Tobi’};</div><div class="line">          memdb.save(pet, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">              <span class="keyword">var</span> ret = memdb.first({ name: ’Tobi’ });</div><div class="line">               assert(ret == pet);</div><div class="line">               done();</div><div class="line">          }</div><div class="line">     }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="15-3_vows">15.3 vows</h3>
<p>支持并行测试</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> vows = <span class="built_in">require</span>(‘vows’);</div><div class="line"><span class="keyword">var</span> assert = <span class="built_in">require</span>(‘assert’);</div><div class="line"><span class="keyword">var</span> Todo = <span class="built_in">require</span>(‘./todo’);</div><div class="line"></div><div class="line">vows.describe(’Todo’).addBatch({</div><div class="line">     ‘when adding an item’:{</div><div class="line">          topic: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">               <span class="keyword">var</span> todo = <span class="keyword">new</span> Todo();</div><div class="line">               todo.add(‘Feed my cat’);</div><div class="line">               <span class="keyword">return</span> todo;</div><div class="line">          }</div><div class="line">     },</div><div class="line">     ‘it should exit <span class="keyword">in</span> my todos’: <span class="function"><span class="keyword">function</span><span class="params">(er, todo)</span></span>{</div><div class="line">         assert.equal(todo.getCount(), <span class="number">1</span>);</div><div class="line">     }</div><div class="line">}).run();</div></pre></td></tr></table></figure>

<p>如果你想把这段代码放到测试文件夹下，放在可以由Vows测试运行期运行，<br>run.()改成export(module);<br>然后<br>vows test/*</p>
<h3 id="15-4_should-js">15.4 should.js</h3>
<p>断言库，它有一个Object .prototype属性：可以写表达能力很强的断言。</p>
<h3 id="15-5_Tobi和Soda">15.5 Tobi和Soda</h3>
<p>Tobi模拟浏览器测试，可以结合should.js<br>Soda远程控制真实的浏览器：<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/blognodejs_in_action_test_soda.png" alt="test_tobi"></p>
<h2 id="16、使用EJS过滤器处理模板数据">16、使用EJS过滤器处理模板数据</h2>
<p><strong>格式</strong></p>
<p>&lt;%=:用在转义的EJS输出上的过滤器<br>&lt;%-:用在非转义的EJS输出上的过滤器</p>
<p>例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var ejs = require(‘ejs’);</div><div class="line">var template = ‘&lt;%=: movies | sort | first %&gt;’;</div><div class="line">var context = {‘movies’: [</div><div class="line">     ‘Bambi’,</div><div class="line">     ‘Babe: Pig in the city’,</div><div class="line">     ‘Enter the Void'</div><div class="line">]};</div></pre></td></tr></table></figure>

<p>看来上就是linux的管道符处理，</p>
<p><strong>各种常用处理</strong></p>
<ul>
<li>（1）处理选择：last，first，get:N</li>
<li>（2）处理大小写：capitalize把第一个字母变大写，还有upcase，downcase</li>
<li>（3）处理文本：把文本截成一定数量的单词truncate:20,替换replace:’A’,’B’,<br>排序sort，sort_by:’name’，其中sort返回的是对象，要返回属性的话：|get:’name’</li>
<li>（4）map：不用sort_by，再get。直接用map创建一个包含对象属性的数组，<br>map ’name’| sort|</li>
</ul>
<p>其他模板引擎：<br>Hotgan：实现mustache语法。<br>Jade：特点是空格的作用，缩进表示HTML的嵌入关系。</p>
<h2 id="17、fs-watchfile()与fs-watch()">17、fs.watchfile()与fs.watch()</h2>
<p>fs.watchfile()与fs.watch()是 Node.js中的两个监测文件API。</p>
<ul>
<li>比较老的是fs.watchFile,使用轮询的方式检查文件，不断的stat()，比较mtime时间戳.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(‘fs’);</div><div class="line">fs.watchFile(‘/<span class="keyword">var</span>/log/system.log’, <span class="function"><span class="keyword">function</span><span class="params">(curr, prev)</span></span>{</div><div class="line">     <span class="keyword">if</span>(cur.mtime.getTime() !== prev.mtime.getTime()){</div><div class="line">          <span class="built_in">console</span>.log(‘“System.log” has been modified’);</div><div class="line">     }</div><div class="line">});</div></pre></td></tr></table></figure>

<ul>
<li>新的api是fs.watch()，根据平台本地的文件修改通知API监测文件，性能更优，但是不如watchFile可靠。在OSX监测目录不会报告参数filename，其他见： 档<a href="http://nodejs.org/api/fs.html#fs_caveats" target="_blank" rel="external">http://nodejs.org/api/fs.html#fs_caveats</a></li>
</ul>
<h2 id="18、Process模块">18、Process模块</h2>
<ul>
<li>process.argv 存储了Node运行当前脚本时传入的参数</li>
<li>process.env 获取或设定环境变量</li>
<li>process不是eventEmitter实例，却可以发出exit和uncaughtException事件</li>
</ul>
<p><strong>注意点：</strong><br>其中exit是在事件循环（event loop）停止之后才激发的，所以你没有机会在exit事件启动任何异步任务。</p>
<h3 id="18-1_Process的信号处理">18.1 Process的信号处理</h3>
<p>UINX有信号的概念，是进程间通信（IPC）的基础形式，它是一组固定的名称，不能传递参数。</p>
<p><strong>信号举例如下</strong></p>
<ul>
<li>SIGUSR1：Node进入它内置的调试器</li>
<li>SIGWINCH：调试终端大小，由shell发送</li>
<li>SIGINT:ctrl+c，由shell发送，Node默认行为是杀死进程。如果你希望在杀掉服务器前，完成所有连接的处理，可以</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">process.on(’SIGINT’, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">     <span class="built_in">console</span>.log(‘Got Ctrl-C!’);</div><div class="line">     server.close();</div><div class="line">});</div></pre></td></tr></table></figure>

<ul>
<li>还有SIGUSR2和SIGKILL等等</li>
</ul>
<h2 id="19、子进程">19、子进程</h2>
<p>在NODE中创建子进程三种</p>
<ul>
<li>高层api，exec：在回调中创建命令并缓存结果的高层api。</li>
<li>底层api，spawn：将单例命令创建Child-Process对象中的底层API。</li>
<li>内置的特殊IPC通道fork：用内置的IPC通道创建额外Node进程的特殊方法。</li>
</ul>
<p><strong>三者比较</strong></p>
<ul>
<li><p>cp.exec()：只关心结果，不用从子进程的stdio流中访问数据（IRC协议模块有很多，irc，irc-js等等），结果需要转义，可以用execFile（）</p>
</li>
<li><p>cp.spawn()：返回一个可以交互的ChildProcess对象，允许你跟每个子进程的stdio流交互。（node-cgi范例模块）</p>
</li>
<li><p>cp.fork()：也返回一个ChildProcess对象，区别是这个API是用IPC通道添加的， 子进程现在有一个child.send(message) 函数，并且用fork() 调用的脚本能够监听process.on(‘message’) 事件。fork出来的子进程可以参与运算。</p>
</li>
</ul>
<h2 id="20、其他推荐的社区模块">20、其他推荐的社区模块</h2>
<ul>
<li>表单提交：foridable。</li>
<li>redis：hiredis，升级node时候，需要重新编译一下hiredis，npm rebuild hiredis。</li>
<li>mongodb：mongoose，使用时有个{safe：ture}选项表明你想让数据库操作在执行回调之前完成。</li>
</ul>
<hr>
<p>参考：<br>《Node.js 实战》：<a href="http://book.douban.com/subject/25870705/" target="_blank" rel="external">http://book.douban.com/subject/25870705/</a><br>《Node.js in action》：<a href="http://book.douban.com/subject/6805117/" target="_blank" rel="external">http://book.douban.com/subject/6805117/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>看完《Node.js 实战》，整理总结了觉得比较有价值的内容。
</code></pre><h2 id="1、require">1、require</h2>
<p>require是少有的同步i/o操作，请只在模块初始化时候使用require。</p>
<h2]]>
    </summary>
    
      <category term="nodejs" scheme="http://vernonzheng.com/tags/nodejs/"/>
    
      <category term="经验总结" scheme="http://vernonzheng.com/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
      <category term="nodejs" scheme="http://vernonzheng.com/categories/nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[整合Sentry和NodeJS实现分布式日志收集]]></title>
    <link href="http://vernonzheng.com/2014/12/26/%E6%95%B4%E5%90%88Sentry%E5%92%8CNodejs%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/"/>
    <id>http://vernonzheng.com/2014/12/26/整合Sentry和Nodejs实现分布式日志收集/</id>
    <published>2014-12-26T10:13:42.000Z</published>
    <updated>2015-01-14T09:52:00.000Z</updated>
    <content type="html"><![CDATA[<pre><code>内容包括如何利用raven-node模块，完成nodejs服务与开源日志框架Sentry的对接，实现分布式日志收集，附Http接口的性能测试，不涉及Sentry的使用。
</code></pre><h2 id="一、什么是Sentry？">一、什么是Sentry？</h2>
<p>一个基于Djongo的日志收集系统。具备收集日志（对于分布式环境下，日志分布在各台服务器上）、日志统计（统计次数最多的异常，往往这就是系统的隐患所在）、监控告警（出现异常或者异常积累到一定数量以短信或者邮件的形式告警）、以及以上功能的可视化界面。</p>
<p>目前我们部署公网sentry是6.4.4，<br><a href="http://sentry.funshion.com/dev-web-ads/hermes/" target="_blank" rel="external">http://sentry.funshion.com/dev-web-ads/hermes/</a><br>支持的raven-node是0.7.2<br><a href="https://github.com/getsentry/raven-node" target="_blank" rel="external">https://github.com/getsentry/raven-node</a></p>
<h2 id="二、NodeJS接入Sentry">二、NodeJS接入Sentry</h2>
<p>在package.json中增加dependencies：”raven”: “0.7.2”</p>
<p>调用方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> raven = <span class="built_in">require</span>(‘raven’);</div><div class="line"><span class="keyword">var</span> client = <span class="keyword">new</span> raven.Client(‘http:<span class="comment">//32位:32位@sentryHost');</span></div></pre></td></tr></table></figure>

<h3 id="2-1_raven-node两种使用方式">2.1 raven-node两种使用方式</h3>
<ul>
<li>2.1.1 全局拦截与实现</li>
</ul>
<p>调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">client.patchGlobal();</div></pre></td></tr></table></figure>

<p>源码如下，拦截所有uncaughtException。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports.patchGlobal = <span class="function"><span class="keyword">function</span> <span class="title">patchGlobal</span><span class="params">(client, cb)</span> </span>{</div><div class="line">    <span class="comment">// handle when the first argument is the callback, with no client specified</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> client === <span class="string">'function'</span>) {</div><div class="line">        cb = client;</div><div class="line">        client = <span class="keyword">new</span> Client();</div><div class="line">    <span class="comment">// first argument is a string DSN</span></div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> client === <span class="string">'string'</span>) {</div><div class="line">        client = <span class="keyword">new</span> Client(client);</div><div class="line">    }</div><div class="line">    <span class="comment">// at the end, if we still don't have a Client, let's make one!</span></div><div class="line">    !(client <span class="keyword">instanceof</span> Client) && (client = <span class="keyword">new</span> Client());</div><div class="line"></div><div class="line">    process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span><span class="params">(err)</span> </span>{</div><div class="line">        <span class="keyword">if</span>(cb) {  <span class="comment">// bind event listeners only if a callback was supplied</span></div><div class="line">            client.once(<span class="string">'logged'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">                cb(<span class="literal">true</span>, err);</div><div class="line">            });</div><div class="line">            client.once(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">                cb(<span class="literal">false</span>, err);</div><div class="line">            });</div><div class="line">        }</div><div class="line">        client.captureError(err, <span class="function"><span class="keyword">function</span><span class="params">(result)</span> </span>{</div><div class="line">            node_util.log(<span class="string">'uncaughtException: '</span>+client.getIdent(result));</div><div class="line">        });</div><div class="line">    });</div><div class="line">};</div></pre></td></tr></table></figure>

<p>测试下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> raven = <span class="built_in">require</span>(<span class="string">"raven"</span>)</div><div class="line"></div><div class="line">  <span class="keyword">var</span> testRaven = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">var</span> client = <span class="keyword">new</span> raven.Client(<span class="string">'http://a374661ff0374e488...略'</span>);</div><div class="line">    client.patchGlobal();</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"test throw error"</span>);</div><div class="line">    }<span class="keyword">catch</span>(err){</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"i'm caught error and throw myself again!"</span>)</div><div class="line">    }</div><div class="line">    <span class="comment">//client.captureError('test captureMessage');</span></div><div class="line">  }</div></pre></td></tr></table></figure>

<p>在sentry上显示如下：<br>会显示function名，Error message，错误出现次数等<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/sentry-test-item" alt="setry-test-item"><br>点进详情，看到程序调用栈：<br><img src="http://7te9ul.com1.z0.glb.clouddn.com/sentry-aggregation" alt="sentry-aggregation"></p>
<ul>
<li>2.1.2 手动调用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// record a simple message</span></div><div class="line">client.captureMessage(<span class="string">'hello world!'</span>)</div><div class="line"><span class="comment">// capture an exception</span></div><div class="line">client.captureError(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Uh oh!!'</span>));</div></pre></td></tr></table></figure>

<h3 id="2-2_raven-node推荐使用方式">2.2 raven-node推荐使用方式</h3>
<p>统一使用第二种:<br>（1）对于uncaughtException使用下图方式输出到sentry：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span><span class="params">(err)</span> </span>{</div><div class="line">    ravenClient.captureError(err)</div><div class="line">    <span class="comment">//console.log("uncaughtException:" + err.stack);</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  });</div></pre></td></tr></table></figure>

<p>（2）对于catchException或者业务错误，重写log的实现，完成可配置哪个log类型输出到sentry。</p>
<h3 id="2-3_raven-node容灾考虑">2.3 raven-node容灾考虑</h3>
<p>看完怎么导入使用后，如果把它丢到生产环境，我想到的，还需要考虑的问题有：</p>
<p>（1）日志发送应该是纯异步的，不影响业务。<br>（2）发日志是调用tcp还是udp还是http接口。<br>（3）超时重发机制。<br>（4）sentry挂了怎么处理。<br>（5）sentry忙不过来怎么处理。<br>等等。</p>
<ul>
<li>2.3.1 raven-node支持的协议</li>
</ul>
<p>要回答这些问题，看下sentry的transport.js。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports.http = <span class="keyword">new</span> HTTPTransport();</div><div class="line"><span class="built_in">module</span>.exports.https = <span class="keyword">new</span> HTTPSTransport();</div><div class="line"><span class="built_in">module</span>.exports.udp = <span class="keyword">new</span> UDPTransport();</div><div class="line"><span class="built_in">module</span>.exports.Transport = Transport;</div></pre></td></tr></table></figure>

<p>支持三种方式，根据SENTRY创建项目的设置来实现，体现在SENTRY_DNS的host里。<br>因为我们都是对内网服务器日志的监控，一般使用http。</p>
<ul>
<li>2.3.2 raven-node中http协议实现-send函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">HTTPTransport.prototype.send = <span class="function"><span class="keyword">function</span><span class="params">(client, message, headers, ident)</span> </span>{</div><div class="line">    <span class="keyword">var</span> options = {</div><div class="line">        hostname: client.dsn.host,</div><div class="line">        path: client.dsn.path + <span class="string">'api/store/'</span>,</div><div class="line">        headers: headers,</div><div class="line">        method: <span class="string">'POST'</span>,</div><div class="line">        port: client.dsn.port || <span class="keyword">this</span>.defaultPort</div><div class="line">    }, req = <span class="keyword">this</span>.transport.request(options, <span class="function"><span class="keyword">function</span><span class="params">(res)</span></span>{</div><div class="line">        res.setEncoding(<span class="string">'utf8'</span>);</div><div class="line">        <span class="keyword">if</span>(res.statusCode &gt;= <span class="number">200</span> && res.statusCode &lt; <span class="number">300</span>) {</div><div class="line">            client.emit(<span class="string">'logged'</span>, ident);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">var</span> reason = res.headers[<span class="string">'x-sentry-error'</span>];</div><div class="line">            <span class="keyword">var</span> e = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'HTTP Error ('</span> + res.statusCode + <span class="string">'): '</span> + reason);</div><div class="line">            e.response = res;</div><div class="line">            e.statusCode = res.statusCode;</div><div class="line">            e.reason = reason;</div><div class="line">            e.sendMessage = message;</div><div class="line">            e.requestHeaders = headers;</div><div class="line">            e.ident = ident;</div><div class="line">            client.emit(<span class="string">'error'</span>, e);</div><div class="line">        }</div><div class="line">        <span class="comment">// force the socket to drain</span></div><div class="line">        <span class="keyword">var</span> noop = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{};</div><div class="line">        res.on(<span class="string">'data'</span>, noop);</div><div class="line">        res.on(<span class="string">'end'</span>, noop);</div><div class="line">    });</div><div class="line">    req.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>{</div><div class="line">        client.emit(<span class="string">'error'</span>, e);</div><div class="line">    });</div><div class="line">    req.end(message);</div><div class="line">};</div></pre></td></tr></table></figure>

<p>代码很简短，post msg到{SENTRY_DSN}.host/dsn.path/api/store/，而且<br>（1）没有失败重试<br>（2）发送失败（resp状态码不是200或者req调用的error），发送事件到client.emit(‘error’)，再看下client对error事件的处理：none。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>{});  <span class="comment">// noop</span></div></pre></td></tr></table></figure>

<h2 id="三、小结与优化">三、小结与优化</h2>
<h3 id="3-1_疑问解答">3.1 疑问解答</h3>
<p>回答下前面对sentry和raven-node的疑问：</p>
<ul>
<li>（1）日志发送应该是纯异步的，不影响业务。<br>  raven-node send日志后是异步回调，但是调用发送日志api是同步的。<br>（因为nodejs是单进程单线程，io异步基本已满足需求，如需优化，可以考虑对整个log模块独立进程，增加重试，发送流量控制等等，但是进程间内存拷贝开销会很大，nodejs的优劣还是很明显的，具体看应用场景）。</li>
<li>（2）发日志是调用tcp还是udp还是http接口。<br>  内网服务日志监控推荐http/udp。</li>
<li>（3）超时重发机制。<br>  无retry机制</li>
<li>（4）sentry挂了怎么处理。</li>
<li>（5）sentry忙不过来怎么处理。<br>  （sentry接受到的请求不是实时处理，接受请求通过队列实现。性能测试可参考：<br><a href="http://blog.csdn.net/largetalk/article/details/8640854）" target="_blank" rel="external">http://blog.csdn.net/largetalk/article/details/8640854）</a><br>  sentry挂了或者忙不过来，client会接收到error，但是不会输出任何异常。</li>
<li>（6）raven-node 连接是否会复用，大量日志需要输出的时候，io和句柄占用都会影响到业务处理，是否需要过载保护？<br>参考3.2</li>
</ul>
<h3 id="3-2_优化与使用建议">3.2 优化与使用建议</h3>
<p>针对上面的rave-node可能存在的问题，给出以下优化建议</p>
<h4 id="3-2-1_规范哪些日志需要输出到sentry">3.2.1 规范哪些日志需要输出到sentry</h4>
<ul>
<li>新增monitor logger类型，专用于输出到sentry</li>
<li>必须error级别以上输出到sentry</li>
<li>error包括uncaughtException，业务异常，外部依赖服务异常，内部异常。（也可以增加服务正常启动的信息给sentry）</li>
</ul>
<h4 id="3-2-2_raven-node优化">3.2.2 raven-node优化</h4>
<p>上面提到的潜在问题总结为</p>
<ul>
<li>日志过多导致内存，句柄等资源占用过多的情况。</li>
<li>sentry异常，发送日志堆积，与日志过多情况相似。</li>
<li>目前与sentry交互的异常日志没有输出（有优点也有缺点）。</li>
</ul>
<p><strong>建议</strong></p>
<p>针对上面前两个问题，对raven-node封装或者扩展，支持固定大小的预发送队列。对外部依赖服务的异常进行隔离。</p>
<p>针对第三个问题，异常分为初始化和正常交互过程中两种情况</p>
<p>可以修改raven-node的client的prototype，支持异常输出日志。</p>
<p>或者<strong>常规解决方法</strong>：</p>
<p>正常交互过程中的异常：可以检测预发送队列的内容进行处理（如超过一定时间/次数，队列内容没有变更视为timeout异常），输出error日志。</p>
<p>初始化异常：因为封装raven-node后，client是复用的，仅当第一次初始化后，进行check，发送一个message：xxx服务启动。</p>
<h2 id="四、性能测试">四、性能测试</h2>
<p>因sentry公网只开了Http的接口，对公网测试的Http接口性能测试如下：</p>
<p><strong>环境：</strong><br>    本机(Mac os x 10.11)，双核四线程，node 0.8，raven-node 0.7.2</p>
<p><strong>tps监测方式：</strong>统计raven-node client：response中end事件的输出时间</p>
<p><strong>测试数据：</strong></p>
<p>4个cluster<br>4000条300byte消息，<br>560ms发送完毕<br>4000条消息，总耗时约5.3s<br>tps大概765/s</p>
<p>1个cluster<br>4000条300byte消息，<br>900ms发送完毕<br>4000条消息，总耗时约11s<br>tps大概365/s</p>
<p>测试是否对项目有连接数的限制：<br>200个cluster<br>20条300byte消息<br>sentry的web管理界面卡顿，raven-node client返回正常</p>
<p><strong>后续追加了不同cluster的性能表现：</strong></p>
<p>总消息数为4000条，每条300byte<br>cluster个数-tps<br>4-765<br>8-1256<br>12-1430<br>16-1752<br>20-1690<br>32-1320<br>注：多个cluster未做类似Barrier的实现（即cluster发起请求非同一起点）会有误差。</p>
<p><strong>结论：</strong><br>    sentry内部利用redis实现任务队列，测试机的tps在1800左右，预估还有较大提升，受限于测试机。如果使用http，极端情况下对client有压力，如果使用udp接口，问题不大，不影响client。另外，sentry连接数没有限制，连接管理表现一般。</p>
<hr>
<p>参考：<br>Raven-node github：<a href="https://github.com/getsentry/raven-node" target="_blank" rel="external">https://github.com/getsentry/raven-node</a><br>Getsentry官网：<a href="https://www.getsentry.com/docs/" target="_blank" rel="external">https://www.getsentry.com/docs/</a><br>使用开源软件sentry来收集日志：<a href="http://luxuryzh.iteye.com/blog/1980364" target="_blank" rel="external">http://luxuryzh.iteye.com/blog/1980364</a><br>关于Sentry：<a href="http://blog.csdn.net/largetalk/article/details/8640854" target="_blank" rel="external">http://blog.csdn.net/largetalk/article/details/8640854</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>内容包括如何利用raven-node模块，完成nodejs服务与开源日志框架Sentry的对接，实现分布式日志收集，附Http接口的性能测试，不涉及Sentry的使用。
</code></pre><h2 id="一、什么是Sentry？">一、什么是Sent]]>
    </summary>
    
      <category term="nodejs" scheme="http://vernonzheng.com/tags/nodejs/"/>
    
      <category term="sentry" scheme="http://vernonzheng.com/tags/sentry/"/>
    
      <category term="监控" scheme="http://vernonzheng.com/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="性能测试" scheme="http://vernonzheng.com/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
      <category term="nodejs" scheme="http://vernonzheng.com/categories/nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Coffeescript极简教程]]></title>
    <link href="http://vernonzheng.com/2014/12/20/Coffeescript%E6%9E%81%E7%AE%80%E6%95%99%E7%A8%8B/"/>
    <id>http://vernonzheng.com/2014/12/20/Coffeescript极简教程/</id>
    <published>2014-12-20T14:17:30.000Z</published>
    <updated>2014-12-28T10:38:17.000Z</updated>
    <content type="html"><![CDATA[<pre><code>配合没耐心的nodejs教程，写给希望快速上手的coffeescript使用者。
</code></pre><h2 id="一、一些简写和约定：">一、一些简写和约定：</h2>
<p>coffeescript和python类似，空格，缩写都是有意义的。<br>换行替换分号，缩进替换花括号，空格替换括号，<br>但是数组的’[]’不能省略。</p>
<h2 id="二、全局变量：">二、全局变量：</h2>
<p>CoffeeScript剔除了全局变量，避免js中全局变量的误用。（CoffeeScript使用一个匿名函数把所有脚本都包裹起来，将其限定在局部作用域中，并且在为所有的变量赋值前自动添加var）</p>
<p>当然也有需要用全局变量的时候，直接给全局对象windoow赋值即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">exports = this</div><div class="line">exports.tempVal = “tempVal”</div></pre></td></tr></table></figure>

<p>这里在顶级作用域中使用，this相当于全局变量</p>
<h2 id="三、函数">三、函数</h2>
<h3 id="3-1_函数的标准写法">3.1 函数的标准写法</h3>
<p>-&gt; 替代了function(){}<br>如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sum = (nums...) -&gt; </div><div class="line">	result = <span class="number">0</span></div><div class="line">	nums.forEach(n) -&gt; result += n</div><div class="line">	result</div></pre></td></tr></table></figure>

<p>（nums）为传入的参数槽（splats），…表示不定参数，同时自动返回result<br>调用输出结果 alert sum() 或者 alert sum a,b,c ,其中空格表示括号，但是易混淆或者无参调用的时候，请带上括号。</p>
<p><strong><em>多重赋值：</em></strong></p>
<p>btw，因为讲到…不定参数，就提下多重赋值与…的结合：<br>多重赋值就是将一个数组的值逐个赋给后面的一系列变量。<br>如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">myArray = [<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D”] </span></div><div class="line">[start, middle..., end] = myArray </div><div class="line">console.log "start is <span class="comment">#{start}” </span></div><div class="line">console.log <span class="string">"middle is #{middle}” </span></div><div class="line">console.log "end is <span class="comment">#{end}”</span></div></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">start is A </div><div class="line">middle is B,C </div><div class="line">end is D</div></pre></td></tr></table></figure>

<p>顺便提下，数组是支持range的用法的，[1…10]</p>
<h3 id="3-2函数上下文：">3.2函数上下文：</h3>
<p>js的上下文变化会很频繁，尤其在回调函数内，coffeescript提供=&gt;或者self(this)的方式，以下为=&gt;的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">this.clickHandler = -&gt; alert “clicked”</div><div class="line">element.addEventListener “click”, (e) =&gt;</div><div class="line">	his.clickHandler(e)</div></pre></td></tr></table></figure>

<h2 id="四、集合遍历">四、集合遍历</h2>
<h3 id="4-1_for循环：">4.1 for循环：</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myLetters = [“a”,”b”,”c”,”d”]</div><div class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> myLetters</div><div class="line">console.log letter.toUpperCase()</div></pre></td></tr></table></figure>

<p>for中增加when条件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> num，i <span class="keyword">in</span> a when num &lt; <span class="number">5</span></div><div class="line">console.log “第<span class="comment">#{i}个数为#{num}"</span></div></pre></td></tr></table></figure>

<h3 id="4-2_列表推导式(Comprehension)">4.2 列表推导式(Comprehension)</h3>
<p>类似ruby的前缀表达式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myLetters = [“a”,”b”,”c”,”d”]</div><div class="line"></div><div class="line">console.log letter.toUpperCase() <span class="keyword">for</span> letter <span class="keyword">in</span> myLetters</div></pre></td></tr></table></figure>

<h3 id="4-3_对象枚举的方式">4.3 对象枚举的方式</h3>
<p>(这里in换成了of）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">person = </div><div class="line">firstName: “Mark”</div><div class="line">lastName: “Bates”</div><div class="line"></div><div class="line"><span class="keyword">for</span> key, value of person</div><div class="line">console.log “<span class="comment">#{key} is #{value}”</span></div></pre></td></tr></table></figure>

<p>对象属性的枚举还支持when关键字；如果需要过滤继承属性，还可以使用own关键字</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">myObject = </div><div class="line">name: “Mark”</div><div class="line"></div><div class="line">Object.prototype.dob = new Date(<span class="number">1976</span>, <span class="number">7</span>, <span class="number">24</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> own key, value of myObject</div><div class="line">console.log “<span class="comment">#{key}:#{value}”</span></div></pre></td></tr></table></figure>

<h3 id="4-4_while用法">4.4 while用法</h3>
<p>与js不同，while还可以返回结果数组</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">num = <span class="number">6</span></div><div class="line">minstrel = <span class="keyword">while</span> num -= <span class="number">1</span></div><div class="line">	num + “ Brave Sir Robin ran away”</div></pre></td></tr></table></figure>

<p>综合例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@updateAvatars = -&gt;</div><div class="line">name = $(‘.avatar[data-name]’),map -&gt; $(this).data(’name’)</div><div class="line">Utils.findAvatar(name) <span class="keyword">for</span> name <span class="keyword">in</span> $.unique(names)</div></pre></td></tr></table></figure>

<h2 id="五、别名与存在操作符">五、别名与存在操作符</h2>
<h3 id="5-1_别名：">5.1 别名：</h3>
<p>@ 表示this的别名，如@saviour = this.saviour<br>:: 表示prototype</p>
<h3 id="5-2_存在操作符？：">5.2 存在操作符？：</h3>
<p>coffeescript中，？只会在变量不存在或者undefined的时候返回假，<br>如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">praise <span class="keyword">if</span> brain?</div></pre></td></tr></table></figure>

<p>还可以用来替换||操作符：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">velocity = southern ？ <span class="number">40</span></div></pre></td></tr></table></figure>

<p>或者在访问对象时进行null检查，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">blacknight.getLegs()?.kick()</div></pre></td></tr></table></figure>

<p>判断属性是否存在外，你还也可以把？放到kick右边，判断函数是否存在，是否可以调用等</p>
<h2 id="六、类">六、类</h2>
<p>Coffeescript中类定义是组合模式（组合使用构造模式和原型模式），继承方式则用寄生组合模式。</p>
<h3 id="6-1_定义类">6.1 定义类</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Employee</div><div class="line"></div><div class="line">constructor: (name) -&gt;</div><div class="line">@name = name</div><div class="line">dob: (year = <span class="number">1976</span>, month =<span class="number">7</span>, day = <span class="number">24</span>) -&gt;</div><div class="line">new Date(year, month, day)</div><div class="line"></div><div class="line">emp1 = new Employee(“Mark”)</div><div class="line">console.log emp1.name</div><div class="line">console.og emp11.dob()</div></pre></td></tr></table></figure>

<h3 id="6-2_添加方法">6.2 添加方法</h3>
<p>方法是直接定义在原型上，显示为原型添加方法，很简单：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Array::size = -&gt; @length</div></pre></td></tr></table></figure>

<h3 id="6-3_构造函数简化">6.3 构造函数简化</h3>
<p>如果把参数赋值给同名属性，可以用@语法糖，将构造函数简化为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">constructor: (@name) -&gt;</div></pre></td></tr></table></figure>

<h3 id="6-4_实例变量的使用">6.4 实例变量的使用</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Animal</div><div class="line">	price: <span class="number">5</span></div><div class="line"></div><div class="line">	sell: =&gt;</div><div class="line">		alert “Give me <span class="comment">#{@price} shillings!”</span></div><div class="line"></div><div class="line">animal = new Animal</div><div class="line">$(“<span class="comment">#sell”).click(animal.sell)</span></div></pre></td></tr></table></figure>

<p>其中注意到=&gt;的使用，表示引用方法调用的上下文，输出5.</p>
<h3 id="6-5_静态变量的使用">6.5 静态变量的使用</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class Animal</div><div class="line">	@find: (name) -&gt;</div><div class="line"></div><div class="line">Animal.find(“Parrot”)</div></pre></td></tr></table></figure>

<p>其实就是在类属性上（this）设置变量值。</p>
<h3 id="6-6_继承">6.6 继承</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Animal</div><div class="line">	constructor: (@name) -&gt;</div><div class="line">class Parrot extends Animal</div><div class="line"></div><div class="line">Animal::rip = <span class="literal">true</span></div><div class="line"></div><div class="line">parrot = new Parrot(“Macaw”)</div><div class="line">alert(“This parrot is no more”) <span class="keyword">if</span> parrot.rip</div></pre></td></tr></table></figure>

<p>这里要注意的是，静态变量是直接拷贝给子类的，而不是像实例属性那样使用原型来继承。</p>
<h2 id="七、Mixins混入">七、Mixins混入</h2>
<p>举个例子：<br>module类有两个静态方法，@extend()和@include()，分别来实现对类的静态属性和实例属性的扩展。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">moduleKeywords = [‘exteded’, ‘included’]</div><div class="line"></div><div class="line">class Module</div><div class="line">	@extend: (obj) -&gt;</div><div class="line">		<span class="keyword">for</span> key, value of obj when key not <span class="keyword">in</span> moduleKeywords</div><div class="line">			@[key] = value</div><div class="line">			obj.extended?.apply(@)</div><div class="line">			this</div><div class="line"></div><div class="line">	@include: (obj) -&gt;</div><div class="line">		<span class="keyword">for</span> key, value of obj when key not <span class="keyword">in</span> moduleKeywords</div><div class="line">			<span class="comment"># Assign properties to the prototype</span></div><div class="line">			@::[key] = value</div><div class="line"></div><div class="line">		obj.included?.apply(@)</div><div class="line">		this</div></pre></td></tr></table></figure>

<p>然后是如何使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">classProperties = </div><div class="line">	find: (id) -&gt;</div><div class="line">	create: (attrs) -&gt;</div><div class="line"></div><div class="line">instanceProperties = </div><div class="line">	save: -&gt;</div><div class="line"></div><div class="line">class User extends Module</div><div class="line">	@extends classProperties</div><div class="line">	@include instanceProperties</div><div class="line">	</div><div class="line"><span class="comment"># Usage:</span></div><div class="line">user = User.find((<span class="number">1</span>)</div><div class="line"></div><div class="line">user = new User</div><div class="line">user.save()</div></pre></td></tr></table></figure>

<p>以上，我们为User类添加了静态属性find()和create()，还添加了实例属性save()。</p>
<p>再给一个例子，在扩展类后执行回调：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ORM = </div><div class="line">	find: (id) -&gt;</div><div class="line">	create: (attrs) -&gt;</div><div class="line">	extended: -&gt;</div><div class="line">		@include</div><div class="line">			save: -&gt;</div><div class="line"></div><div class="line">class User extends Module</div><div class="line">	@extends ORM</div></pre></td></tr></table></figure>

<p>基础讲完，接下来就可以围绕网络，文件，进程，异步等进行专项练习了，好运！</p>
<hr>
<p>参考：<br>《The Little Book on CoffeeScript》：<a href="http://book.douban.com/subject/10462179/" target="_blank" rel="external">http://book.douban.com/subject/10462179/</a><br>Learn X in Y minutes Where X=coffeescript：<a href="http://learnxinyminutes.com/docs/coffeescript/" target="_blank" rel="external">http://learnxinyminutes.com/docs/coffeescript/</a><br>CoffeeScript极简教程：<a href="http://chunfenglee.com/blog/2013/10/13/beginning-coffeescript/" target="_blank" rel="external">http://chunfenglee.com/blog/2013/10/13/beginning-coffeescript/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>配合没耐心的nodejs教程，写给希望快速上手的coffeescript使用者。
</code></pre><h2 id="一、一些简写和约定：">一、一些简写和约定：</h2>
<p>coffeescript和python类似，空格，缩写都是有意义的。<b]]>
    </summary>
    
      <category term="coffeescript" scheme="http://vernonzheng.com/tags/coffeescript/"/>
    
      <category term="基础" scheme="http://vernonzheng.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="coffeescript" scheme="http://vernonzheng.com/categories/coffeescript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[没耐心的NodeJS基础教程]]></title>
    <link href="http://vernonzheng.com/2014/12/17/%E6%B2%A1%E8%80%90%E5%BF%83%E7%9A%84NodeJS%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
    <id>http://vernonzheng.com/2014/12/17/没耐心的NodeJS基础教程/</id>
    <published>2014-12-17T15:21:00.000Z</published>
    <updated>2014-12-28T10:41:42.000Z</updated>
    <content type="html"><![CDATA[<pre><code>这是一篇没耐心的nodejs教程，写给希望迅速上手的学习者。基础篇介绍权限，模块，包，工程目录结构，<span class="built_in">npm</span>等，不涉及常用api和中间件等。
</code></pre><h2 id="一、权限问题">一、权限问题</h2>
<p>linux下，nodejs需要监听80或443端口提供HTTP（S）服务时需要root权限。<br>有两种方式：</p>
<ul>
<li>（1）（推荐）需要js提供root权限<blockquote>
<p>$ sudo node server.js</p>
</blockquote>
</li>
<li>（2）使用chmod+s命令让nodejs总是以root权限运行，不安全。<blockquote>
<p>$ sudo chown root /usr/local/bin/node<br>$ sudo chmod +s /usr/local/bin/node</p>
</blockquote>
</li>
</ul>
<h2 id="二、模块">二、模块</h2>
<p>一个文件为一个模块，一个文件路径为一个模块名。<br>编写模块时，有require，exports，module三个变量。</p>
<ul>
<li><strong>2.1 required</strong><br>导入某个模块<blockquote>
<p>var foo1 = required(‘./foo’);//.js后缀可以省略<br>var foo2 = required(“./foo.js”);</p>
</blockquote>
</li>
</ul>
<p>也可以加载或者导入一个json：</p>
<blockquote>
<p>var data = require(‘./data.json’);</p>
</blockquote>
<ul>
<li><p><strong>2.2 exports</strong><br>是当前模块的导出对象，用于导出模块共有方式和属性。</p>
<blockquote>
<p>exports.hello = function(){</p>
<pre><code>console.<span class="built_in">log</span>(‘Hello World!’);
</code></pre><p>};</p>
</blockquote>
</li>
<li><p><strong>2.3 module</strong><br>可以访问当前模块的一些信息，最多的用途就是替换当前模块的到处对象。</p>
<blockquote>
<p>module.export = function(){</p>
<pre><code> console.<span class="built_in">log</span>(‘Hello World!’);
</code></pre><p>};</p>
</blockquote>
</li>
</ul>
<h2 id="三、模块初始化">三、模块初始化</h2>
<p>NodeJS使用CMD模块系统，主模块作为程序入口点，所有模块在执行过程中只初始化一次。</p>
<p><strong>初始化一次</strong></p>
<p>一个模块中的JS代码仅在模块第一次被使用时执行一次，并在执行过程中初始化模块的导出对象。之后，缓存起来的导出对象被重复利用。</p>
<ul>
<li><p><strong>3.1 主模块</strong><br>通过命令行参数传递给NodeJS以启动程序的模块被称为主模块。主模块负责调度组成整个程序的其他模块完成工作。默认是路径下的main.js。</p>
</li>
<li><p><strong>3.2 二进制模块（不推荐）</strong><br>nodejs支持使用c/c++编写二进制模块。编译好的二进制模块除了文件扩展名是.node外，和JS块的使用方式相同。</p>
</li>
</ul>
<h2 id="四、模块路径解析规则">四、模块路径解析规则</h2>
<p>除了相对路径和绝对路径外，require函数还支持第三种形式的路径。</p>
<ul>
<li><p><strong>4.1 内置模块</strong></p>
</li>
<li><p><strong>4.2 node_modules目录</strong><br>专门存放模块的路径。比如某个模块的绝对路径是/home/user/hello.js, 在该模块中使用require(‘foo/bar’)方式加载模块，则NodeJS依次尝试使用以下路径。</p>
<blockquote>
<p>/home/user/node_modules/foo/bar<br>/home/node_modules/foo/bar<br>/node_moduels/foo/bar</p>
</blockquote>
</li>
<li><p><strong>4.3 NODE_PATH环境变量</strong><br>指定额外的模块搜索路径。因为是额外，所以最后搜索。<br>使用：设置NODE_PATH环境变量，linux用：分隔，windows使用；分隔。</p>
</li>
</ul>
<h2 id="五、包">五、包</h2>
<ul>
<li><p><strong>5.1 入口模块</strong><br>多个js模块，组成一个包。所有模块都是同一个路径里，且需要指定一个入口模块，入口模块的导出对象作为包的导出对象。<br>比如cat目录下有main.js,lib1.js,lib2.js。<br>main.js作为入口模块，require lib1.js,lib2.js。</p>
</li>
<li><p><strong>5.2 index.js</strong><br>当模块文件名为index.js,加载模块时就可以使用模块所在目录的路径代替模块文件路径，如可写成<br>var cat = require(‘/home/user/lib/cat’);<br>var cat = require(‘/home/user/lib/cat/index’);</p>
</li>
<li><p><strong>5.3 自定义入口模块和存放位置（package.json）</strong><br>如果你想自定义入口模块的文件名和存放位置，就需要在包目录下包含一个package.json文件，如</p>
<blockquote>
<p>{</p>
<pre><code>“name”: “cat”,
“main”: “./lib/main.js<span class="string">"</span>
</code></pre><p>}<br>如此一来，就可以用require(‘/home/user/lib/cat’)加载。</p>
</blockquote>
</li>
</ul>
<h2 id="六、命令行程序">六、命令行程序</h2>
<p>将固定node命令开头执行的方式，变成命令行的方式。<br>node xx.js [param] =&gt; xx [param]，<br>如$node /home/user/bin/node-echo.js Hello World<br>变成<br>$node-echo Hello World<br>简便很多</p>
<p>那么如何做到，只讲在linux下怎么做：</p>
<ul>
<li>(1)node-echo.js顶部增加<blockquote>
<p>#!/usr/bin/env node</p>
</blockquote>
</li>
<li>(2)然后增加执行权限，并再/usr/local/bin下创建软链接<blockquote>
<p>$ chmod +x /home/user/bin/node-echo.js<br>$ sudo ln -s /home/user/bin/node-echo.js /usr/local/bin/node-echo</p>
</blockquote>
</li>
</ul>
<h2 id="七、工程目录结构">七、工程目录结构</h2>
<blockquote>
<ul>
<li>/home/user/workspace/node-echo/<ul>
<li>bin/<br>  node-echo</li>
</ul>
<ul>
<li>doc/</li>
</ul>
<ul>
<li>lib/<br>  echo.js</li>
<li>node_modules/<ul>
<li>argv/</li>
</ul>
</li>
</ul>
<ul>
<li>tests/<br>package.json<br>README.md</li>
</ul>
</li>
</ul>
</blockquote>
<p>其中部分文件：</p>
<blockquote>
<p>/<em> bin/node-echo </em>/<br>var argv = require(‘argue’),<br>     echo = require(‘../ilb/echo’);<br>console.log(echo(argv.join(‘ ‘)));</p>
<p>/<em> lib/echo.js</em>/<br>module.exports = function(message){<br>    return message;<br>}</p>
<p>/<em> pacakge.json </em>/<br>{<br>    “name”:”node-echo”,<br>    “main”:”./lib/echo.js”<br>}</p>
</blockquote>
<h2 id="八、NPM:包管理工具">八、NPM:包管理工具</h2>
<p>（1）允许用户从NPM服务器下载别人编写的三方包到本地使用。<br>（2）允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。<br>（3）允许用户将自己编写的包或者命令行程序上传到NPM服务器供别人使用。</p>
<ul>
<li><strong>8.1 下载第三方包</strong></li>
</ul>
<p>一般这样使用别人的包(如argv)，<br>在项目目录下，npm install argv@1.1.1，那么argv包就会放到node_modules目录下，直接require(‘argv’)就可以使用了。</p>
<p>依赖的包比较多时，通过package.json字段做了扩展。<br>如：<br>{<br>    “name”: “node-echo”,<br>    “main”: “./lib/echo.js”,<br>    “denpendencies”:{<br>        “argv”: “0.0.2”<br>    }<br>}<br>然后在工程目录，npm install即可。btw，传递的依赖会被自动下载。</p>
<ul>
<li><strong>8.2 安装命令行工具</strong></li>
</ul>
<p>如上面例子的node-echo，只要node-echo自己配置好了对应的package.json字段，对于用户而言，这样安装：</p>
<blockquote>
<p>$ npm install node-echo -g<br>其中-g表示全局安装，node-echo会默认安装到以下位置，并且NPM会自动创建好Linux系统下需要的软链文件。</p>
<ul>
<li>/usr/local/<ul>
<li>lib/node_modules/<ul>
<li>node-echo/<br>…</li>
</ul>
</li>
<li>bin/<br>  node-echo<br>…</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><strong>8.3 发布代码</strong></li>
</ul>
<p>第一次发布npm，需要注册个号码。执行npm adduser，按提示操作。账号完成设置后，编辑需要发布的项目的package.json，加入npm必须字段。<br>如：</p>
<blockquote>
<p>{<br>   “name”: ”node-echo”，#包名，与NPM服务器保持唯一<br>   “version”： “1.0.0”，#当前版本号<br>   “dependencies”：{<br>       “argv”： “0.0.2”<br>   }，<br>   “main”： “./lib/echo.js”,<br>   “bin”: {<br>       “node-echo”: “./bin/node-echo”  #命令行程序名和主模块位置<br>   }<br>}<br>然后，在package.json所在目录下运行npm publish 发布代码。</p>
</blockquote>
<ul>
<li><strong>8.4 版本号</strong></li>
</ul>
<p>使用npm下载或者发布代码都要用到版本号。<br>语义版版本号分为X.Y.Z三位，<br> 分别为主版本号、（大变动，向下不兼容）<br> 次版本号（新增功能，向下兼容）、<br> 补丁版本号（修复bug）。</p>
<h2 id="九、最后npm比较有用的命令行：">九、最后npm比较有用的命令行：</h2>
<ul>
<li>在package.json目录，npm install . -g 可先在本地安装当前命令行程序，用于发布前本地测试。</li>
<li>npm update  <package>当前目录下node_modules子目录下对应模块更新到最新版本。</package></li>
<li>npm update <package> -g 把全局安装的对应命令行程序更新至最新版。</package></li>
<li>npm cache clear 清空NPM本地缓存，用于对于使用相同版本号发布新版本的人。</li>
<li>npm unpublish <package>@<version> 可以撤销自己发布过的某个版本代码。</version></package></li>
</ul>
<hr>
<p>参考：<br>七天学会NodeJS：<a href="http://nqdeng.github.io/7-days-nodejs/\#3.2.1" target="_blank" rel="external">http://nqdeng.github.io/7-days-nodejs/\#3.2.1</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>这是一篇没耐心的nodejs教程，写给希望迅速上手的学习者。基础篇介绍权限，模块，包，工程目录结构，<span class="built_in">npm</span>等，不涉及常用api和中间件等。
</code></pre><h2 id="一、权限问题">]]>
    </summary>
    
      <category term="nodejs" scheme="http://vernonzheng.com/tags/nodejs/"/>
    
      <category term="基础" scheme="http://vernonzheng.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="nodejs" scheme="http://vernonzheng.com/categories/nodejs/"/>
    
  </entry>
  
</feed>
