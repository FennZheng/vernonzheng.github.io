<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Vern Zheng]]></title>
  <subtitle><![CDATA[tech | life | thinking | note]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://vernonzheng.com/"/>
  <updated>2015-06-11T10:53:09.185Z</updated>
  <id>http://vernonzheng.com/</id>
  
  <author>
    <name><![CDATA[Vern Zheng]]></name>
    <email><![CDATA[kevonzheng@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[《快学scala》习题解答-第十九章-解析]]></title>
    <link href="http://vernonzheng.com/2015/03/19/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94-%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0-%E8%A7%A3%E6%9E%90/"/>
    <id>http://vernonzheng.com/2015/03/19/《快学scala》习题解答-第十九章-解析/</id>
    <published>2015-03-19T15:36:42.000Z</published>
    <updated>2015-03-19T15:38:28.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第十九章_解析">第十九章 解析</h2>
<p><strong>19.1</strong><br>为算术表达式求值器添加/和%操作符。</p>
<p><strong>19.2</strong><br>为算术表达式求值器添加^操作符。在数学运算当中，^应该比乘法的优先级更高，并且它应该是右结合的。也就是说，4^2^3应该得到4^(2^3)，即65536。</p>
<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》习题解答-第二十章-Actor]]></title>
    <link href="http://vernonzheng.com/2015/02/15/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94-%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0-Actor/"/>
    <id>http://vernonzheng.com/2015/02/15/《快学scala》习题解答-第二十章-Actor/</id>
    <published>2015-02-15T09:56:42.000Z</published>
    <updated>2015-02-16T07:31:42.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第二十章_Actor">第二十章 Actor</h2>
<p><strong>20.1</strong><br>编写一个程序，生成由n个随机数组成的数组（其中n是一个很大的值，比如1000000），然后通过将工作分发给多个actor的同时计算这些数的平均值，每个actor计算区间内的值之和，将结果发送给一个能组合出结果的actor。<br>如果你在双核或四核处理器上运行这个程序，和单线程的解决方案相比，会快多少？<br>双核上差不多</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.actors.Actor</div><div class="line"><span class="keyword">import</span> scala.actors.Actor._</div><div class="line"><span class="keyword">val</span> taskCount = Runtime.getRuntime().availableProcessors()</div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">SumPart</span><span class="params">(items:Array[Int],partCount:Int)</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">CollectSum</span><span class="params">(sum:Int,partCount:Int)</span></span></div><div class="line"></div><div class="line"><span class="keyword">def</span> randomArray(num:Int):Array[Int] = {</div><div class="line">  <span class="keyword">val</span> result = <span class="keyword">new</span> Array[Int](num)</div><div class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> to num-<span class="number">1</span>) {</div><div class="line">    result(i) = (Math.random() * num).toInt</div><div class="line">  }</div><div class="line">  result</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">val</span> ReduceActor = actor {</div><div class="line">  <span class="keyword">var</span> result = <span class="number">0</span>D</div><div class="line">  <span class="keyword">var</span> receiveCount = <span class="number">0</span></div><div class="line">  loop{</div><div class="line">    receive{</div><div class="line">      <span class="keyword">case</span> CollectSum(sum,partCount)=&gt;</div><div class="line">        receiveCount += <span class="number">1</span></div><div class="line">        result += sum</div><div class="line">        println(sum)</div><div class="line">        <span class="keyword">if</span>(receiveCount&gt;=partCount){</div><div class="line">          result = result/partCount</div><div class="line">          println(<span class="string">"Actor result:"</span>+result)</div><div class="line">          exit()</div><div class="line">        }</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div><div class="line"><span class="keyword">val</span> MapActor = actor{</div><div class="line">  loop{</div><div class="line">    react{</div><div class="line">      <span class="keyword">case</span> SumPart(items,partCount) =&gt;</div><div class="line">        ReduceActor ! CollectSum(items.sum, partCount)</div><div class="line">        exit()</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">def</span> actorMain(num:Int, partCount:Int) = {</div><div class="line">  <span class="keyword">val</span> array = randomArray(num)</div><div class="line">  <span class="keyword">val</span> startTime = System.currentTimeMillis()</div><div class="line">  <span class="keyword">var</span> range = <span class="number">1</span></div><div class="line">  <span class="keyword">if</span>(array.length&gt;=partCount)</div><div class="line">    range = array.length/partCount</div><div class="line">  <span class="keyword">var</span> start = <span class="number">0</span></div><div class="line">  <span class="keyword">var</span> end = <span class="number">0</span></div><div class="line">  <span class="keyword">var</span> flag = <span class="keyword">false</span></div><div class="line">  MapActor.start()</div><div class="line">  <span class="keyword">while</span>(!flag){</div><div class="line">    <span class="keyword">if</span>(end+range&gt;=array.length-<span class="number">1</span>){</div><div class="line">      end = array.length - <span class="number">1</span></div><div class="line">      flag = <span class="keyword">true</span></div><div class="line">    }<span class="keyword">else</span>{</div><div class="line">      end = end+range</div><div class="line">    }</div><div class="line">    MapActor ! SumPart(array.slice(start,end),partCount)</div><div class="line">    start = start+range</div><div class="line">  }</div><div class="line">  println(<span class="string">"Actor cost:"</span>+(System.currentTimeMillis()-startTime))</div><div class="line">}</div><div class="line"><span class="keyword">def</span> main(num:Int)={</div><div class="line">  <span class="keyword">val</span> array = randomArray(num)</div><div class="line">  <span class="keyword">val</span> startTime = System.currentTimeMillis()</div><div class="line">  println(<span class="string">"No-Actor result:"</span>+array.sum/array.length)</div><div class="line">  println(<span class="string">"No-Actor cost:"</span>+(System.currentTimeMillis()-startTime))</div><div class="line">}</div><div class="line"><span class="keyword">for</span>(i&lt;- <span class="number">1</span> to <span class="number">20</span>) {</div><div class="line">  actorMain(<span class="number">100000</span>, taskCount)</div><div class="line">  actorMain(<span class="number">100000</span>, <span class="number">100</span>)</div><div class="line">}</div><div class="line"><span class="keyword">for</span>(i&lt;- <span class="number">1</span> to <span class="number">20</span>) {</div><div class="line">  main(<span class="number">100000</span>)</div><div class="line">  main(<span class="number">100000</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>20.2</strong><br>编写一个程序，读取一个大型图片到BufferedImage对象中，用javax.imageio.ImangeIo.read方法。使用多个actor，每一个actor对图形的某一个条带区域进行反色处理。当所有条带都被反色后，输出结果。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.awt.image.BufferedImage</div><div class="line"><span class="keyword">import</span> java.io.File</div><div class="line"><span class="keyword">import</span> javax.imageio.ImageIO</div><div class="line"><span class="keyword">import</span> scala.actors.Actor</div><div class="line"><span class="keyword">import</span> scala.actors.Actor._</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">InversePart</span><span class="params">(bufImage:BufferedImage, imageRGB:Array[Int], start:Int, end:Int)</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">WriteImage</span><span class="params">(result:BufferedImage, imageRGB:Array[Int])</span></span></div><div class="line"></div><div class="line"><span class="keyword">val</span> inputPng = <span class="keyword">new</span> File(<span class="string">"./pic.png"</span>)</div><div class="line"><span class="keyword">val</span> outPng = <span class="keyword">new</span> File(<span class="string">"./pic_reverse.png"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageActor</span><span class="params">(var count:Int = 0)</span> <span class="keyword">extends</span> <span class="title">Actor</span></span>{</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> act()={</div><div class="line">    loop{</div><div class="line">      react{</div><div class="line">        <span class="keyword">case</span> InversePart(bufImage, imageRGB, start, end) =&gt;</div><div class="line">          <span class="keyword">for</span>(i &lt;- start to end){</div><div class="line">            imageRGB(i) = imageRGB(i)^<span class="number">0xffffffff</span></div><div class="line">          }</div><div class="line">          self ! WriteImage(bufImage, imageRGB)</div><div class="line">        <span class="keyword">case</span> WriteImage(bufImage, imageRGB) =&gt;</div><div class="line">          count -= <span class="number">1</span></div><div class="line">          <span class="keyword">if</span>(count==<span class="number">1</span>) {</div><div class="line">            <span class="keyword">val</span> width = bufImage.getWidth</div><div class="line">            <span class="keyword">val</span> height = bufImage.getHeight</div><div class="line">            <span class="keyword">val</span> resultImage = <span class="keyword">new</span> BufferedImage(bufImage.getWidth, bufImage.getHeight, BufferedImage.TYPE_INT_RGB)</div><div class="line">            resultImage.setRGB(<span class="number">0</span>, <span class="number">0</span>, width, height, imageRGB, <span class="number">0</span>, width)</div><div class="line">            ImageIO.write(resultImage , <span class="string">"png"</span>, outPng)</div><div class="line">            exit()</div><div class="line">          }</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div><div class="line"><span class="keyword">def</span> inverse = {</div><div class="line">  <span class="keyword">val</span> bufImage = ImageIO.read(inputPng)</div><div class="line">  <span class="keyword">if</span> (bufImage != <span class="keyword">null</span>) {</div><div class="line">    <span class="keyword">val</span> width = bufImage.getWidth</div><div class="line">    <span class="keyword">val</span> height = bufImage.getHeight</div><div class="line">    <span class="keyword">val</span> imageRGB = <span class="keyword">new</span> Array[Int](width * height)</div><div class="line">    bufImage.getRGB(<span class="number">0</span>, <span class="number">0</span>, width, height, imageRGB, <span class="number">0</span>, width)</div><div class="line">    <span class="keyword">var</span> step = <span class="number">5</span></div><div class="line">    <span class="keyword">var</span> start = <span class="number">0</span></div><div class="line">    <span class="keyword">var</span> end = <span class="number">0</span></div><div class="line">    <span class="keyword">var</span> flag = <span class="keyword">false</span></div><div class="line">    <span class="keyword">val</span> count = imageRGB.length / step + <span class="number">1</span></div><div class="line">    <span class="keyword">val</span> imageActor = <span class="keyword">new</span> ImageActor(count)</div><div class="line">    imageActor.start()</div><div class="line">    <span class="keyword">while</span> (!flag) {</div><div class="line">      <span class="keyword">if</span> (end + step &gt;= imageRGB.length) {</div><div class="line">        end = imageRGB.length - <span class="number">1</span></div><div class="line">        flag = <span class="keyword">true</span></div><div class="line">      } <span class="keyword">else</span> {</div><div class="line">        end += step</div><div class="line">      }</div><div class="line">      imageActor ! InversePart(bufImage, imageRGB, start, end)</div><div class="line">      start += step</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div><div class="line">inverse</div></pre></td></tr></table></figure>

<p><strong>20.3</strong><br>编写一个程序，对给定目录下所有子目录的所有文件中匹配某个给定的正则表达式的单词进行计数。对每一个文件各采用一个actor，另外再加上一个actor用来遍历所有子目录，还有一个actor将结果汇总到一起。</p>
<p><strong>20.4</strong><br>修改前一个练习的程序，显示所有匹配的单词。</p>
<p><strong>20.5</strong><br>修改前一个练习的程序，显示所有匹配的单词，每一个都带有一个包含它的文件的列表。</p>
<p><strong>20.6</strong><br>编写一个程序，构造100个actor，这些actor使用while(true)/receive循环，当接收到‘Hello消息时，调用println(Thread.currentThread)，同时构造另外100个actor，他们做同样的事，不过采用loop/react。将它们全部启动，给它们全部都发送一个消息。第一种actor占用了多少线程，第二种actor占用了多少线程？</p>
<p><strong>20.7</strong><br>给练习3的程序添加一个监管actor，监控读取文件的actor并记录任何因IOException退出的actor。尝试通过移除那些计划要被处理的文件的方式触发IOException。</p>
<p><strong>20.8</strong><br>展示一个基于actor的程序是如何在发送同步消息时引发死锁的。</p>
<p><strong>20.9</strong><br>做出一个针对练习3的程序的有问题的实现，在这个实现当中，actor将更新一个共享的计数器。你能展现出程序运行是错误的吗？</p>
<p><strong>20.10</strong><br>重写练习1的程序，使用消息通道来进行通信。</p>
<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》习题解答-第十八章-高级类型]]></title>
    <link href="http://vernonzheng.com/2015/02/11/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94-%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0-%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B/"/>
    <id>http://vernonzheng.com/2015/02/11/《快学scala》习题解答-第十八章-高级类型/</id>
    <published>2015-02-11T14:44:42.000Z</published>
    <updated>2015-02-12T15:21:59.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第十八章_高级类型">第十八章 高级类型</h2>
<p><strong>18.1</strong><br>实现一个Bug类，对沿着水平线爬行的虫子建模。move方法向当前方向移动，turn方法让虫子转身，show方法打印出当前的位置。让这些方法可以被串接调用。例如：<br>bugsy.move(4).show().move(6).show().turn().move(5).show()<br>上述代码应显示4 10 5。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> _1801 {</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bug</span><span class="params">(var pos: Int = 0)</span> </span>{</div><div class="line">  <span class="keyword">var</span> forword: Int = <span class="number">1</span></div><div class="line"></div><div class="line">  <span class="keyword">def</span> move(up: Int):<span class="keyword">this</span>.<span class="keyword">type</span> = {</div><div class="line">    pos += forword * up</div><div class="line">    <span class="keyword">this</span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> show():<span class="keyword">this</span>.<span class="keyword">type</span> = {</div><div class="line">    print(pos + <span class="string">" "</span>)</div><div class="line">    <span class="keyword">this</span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> turn():<span class="keyword">this</span>.<span class="keyword">type</span> = {</div><div class="line">    forword = -forword</div><div class="line">    <span class="keyword">this</span></div><div class="line">  }</div><div class="line">}</div><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span> </span>{</div><div class="line">   <span class="keyword">val</span> bugsy = <span class="keyword">new</span> Bug</div><div class="line">   bugsy.move(<span class="number">4</span>).show().move(<span class="number">6</span>).show().turn().move(<span class="number">5</span>).show()</div><div class="line"> }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>18.2</strong><br>为前一个练习中的Bug类提供一个流利接口，达到能编写如下代码的效果：<br>bugsy move 4 and show and then move 6 and show turn around move 5 and show</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> _1802 {</div><div class="line">  <span class="comment">//非动词 non-verb</span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">then</span></span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">show</span></span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">around</span></span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bug</span><span class="params">(var pos: Int = 0)</span> </span>{</div><div class="line">  <span class="keyword">var</span> forword: Int = <span class="number">1</span></div><div class="line"></div><div class="line">  <span class="keyword">def</span> move(num: Int): <span class="keyword">this</span>.<span class="keyword">type</span> = { pos += num; <span class="keyword">this</span> }</div><div class="line">  <span class="keyword">def</span> and(obj: then.<span class="keyword">type</span>): <span class="keyword">this</span>.<span class="keyword">type</span> = <span class="keyword">this</span></div><div class="line">  <span class="keyword">def</span> and(obj: show.<span class="keyword">type</span>): <span class="keyword">this</span>.<span class="keyword">type</span> = { print(pos + <span class="string">" "</span>); <span class="keyword">this</span>}</div><div class="line">  <span class="keyword">def</span> turn(obj: around.<span class="keyword">type</span>): <span class="keyword">this</span>.<span class="keyword">type</span> = { pos = <span class="number">0</span>; <span class="keyword">this</span>}</div><div class="line">}</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span> </span>{</div><div class="line">  <span class="keyword">val</span> bugsy = <span class="keyword">new</span> Bug</div><div class="line">  bugsy move <span class="number">4</span> and show and then move <span class="number">6</span> and show turn around move <span class="number">5</span> and show</div><div class="line">}</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>18.3</strong><br>完成18.1节中的流利接口，以便我们可以做出如下调用：<br>book set Title to “Scala for the Impatient” set Author to “Cay Horstmann”</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Document</span> </span>{</div><div class="line">  <span class="keyword">var</span> title: String = <span class="string">""</span></div><div class="line">  <span class="keyword">var</span> author: String = <span class="string">""</span></div><div class="line">  <span class="keyword">def</span> setTitle(title: String):<span class="keyword">this</span>.<span class="keyword">type</span> = {<span class="keyword">this</span>.title = title; <span class="keyword">this</span>}</div><div class="line">  <span class="keyword">def</span> setAuthor(author: String):<span class="keyword">this</span>.<span class="keyword">type</span> = {<span class="keyword">this</span>.author= author; <span class="keyword">this</span>}</div><div class="line">}</div><div class="line"><span class="comment">//可枚举</span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Title</span></span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Author</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">extends</span> <span class="title">Document</span></span>{</div><div class="line">  <span class="keyword">private</span> <span class="keyword">var</span> useNextArgAs:Any = <span class="keyword">null</span></div><div class="line">  <span class="keyword">def</span> set(obj: Any): <span class="keyword">this</span>.<span class="keyword">type</span> = {useNextArgAs = obj; <span class="keyword">this</span>}</div><div class="line">  <span class="keyword">def</span> to(obj:String) = {</div><div class="line">    useNextArgAs <span class="keyword">match</span>{</div><div class="line">      <span class="keyword">case</span> Title =&gt; setTitle(obj)</div><div class="line">      <span class="keyword">case</span> Author =&gt; setAuthor(obj)</div><div class="line">      <span class="keyword">case</span> _ =&gt;</div><div class="line">    }</div><div class="line">    <span class="keyword">this</span></div><div class="line">  }</div><div class="line">}</div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">App</span> </span>{</div><div class="line">  <span class="keyword">val</span> book = <span class="keyword">new</span> Book</div><div class="line">  book set Title to <span class="string">"Scala for the Impatient"</span> set Author to <span class="string">"Cay Horstmann"</span></div><div class="line">  println(book.title)</div><div class="line">  println(book.author)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>18.4</strong><br>实现18.2节中被嵌套在Network类中的Member类的equals方法。两个成员要想相等，必须属于同一个网络。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.collection.mutable.ArrayBuffer</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Network</span> </span>{</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Member</span><span class="params">(val name: String)</span> </span>{</div><div class="line">    <span class="keyword">val</span> contacts = <span class="keyword">new</span> ArrayBuffer[Member]</div><div class="line"></div><div class="line">    <span class="keyword">def</span> canEqual(other: Any): Boolean = other.isInstanceOf[Member]</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="keyword">def</span> equals(other: Any): Boolean = other <span class="keyword">match</span> {</div><div class="line">      <span class="keyword">case</span> that: Member =&gt;</div><div class="line">        (that canEqual <span class="keyword">this</span>) &&</div><div class="line">          name == that.name</div><div class="line">      <span class="keyword">case</span> _ =&gt; <span class="keyword">false</span></div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keyword">private</span> <span class="keyword">val</span> members = <span class="keyword">new</span> ArrayBuffer[Member]</div><div class="line"></div><div class="line">  <span class="keyword">def</span> join(name: String) = {</div><div class="line">    <span class="keyword">val</span> m = <span class="keyword">new</span> Member(name)</div><div class="line">    members += m</div><div class="line">    m</div><div class="line">  }</div><div class="line"></div><div class="line">}</div><div class="line"><span class="keyword">val</span> network1 = <span class="keyword">new</span> Network().join(<span class="string">"1"</span>)</div><div class="line"><span class="keyword">val</span> network2 = <span class="keyword">new</span> Network().join(<span class="string">"1"</span>)</div><div class="line">println(network1.equals(network2))</div></pre></td></tr></table></figure>

<p><strong>18.5</strong><br>考虑如下类型别名<br>type NetworkMember = n.Member forSome { val n : Network }<br>和函数<br>def process(m1: NetworkMember, m2: NetworkMember) = (m1, m2)<br>这与18.8节中的process函数有什么不同？</p>
<p>与18.8不同，允许不同网络作为参数</p>
<p><strong>18.6</strong><br>Scala类库中的Either类型可以被用于要么返回结果，要么返回某种失败信息的算法。编写一个带有两个参数的函数：一个已排序整数数组和一个整数值。要么返回该整数值在数组中的下标，要么返回最接近该值的元素的下标。使用一个中置类型作为返回类型。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> getIndex(arr: Seq[Int], v: Int): Int Either Int = {</div><div class="line">  <span class="keyword">if</span> (arr.contains(v)) {</div><div class="line">    Left(arr.indexOf(v))</div><div class="line">  } <span class="keyword">else</span> {</div><div class="line">    Right(arr.indexOf(arr.reduce((a,b) =&gt; <span class="keyword">if</span> (math.abs(v - a) &gt; math.abs(v - b)) b <span class="keyword">else</span> a)))</div><div class="line">  }</div><div class="line">}</div><div class="line">println(getIndex(Seq(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,-<span class="number">2</span>,-<span class="number">3</span>),<span class="number">1</span>))</div></pre></td></tr></table></figure>

<p><strong>18.7</strong><br>实现一个方法，接受任何具备如下方法的类的对象和一个处理该对象的函数。<br>调用该函数，并在完成或有任何异常发生时调用close方法。<br>def close(): Unit</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> tryWithClose[T&lt;:{<span class="keyword">def</span> close():Unit}](obj:T,func: T =&gt; Unit)={</div><div class="line">  <span class="keyword">try</span>{</div><div class="line">    func(obj)</div><div class="line">  }<span class="keyword">finally</span> {</div><div class="line">    obj.close()</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>18.8</strong><br>编写一个函数printValues，带有三个参数f、from和to，打印出所有给定区间范围内的输入值经过f计算后的结果。这里的f应该是任何带有接受Int产出Int的apply方法的对象。例如：<br>printValues((x: Int) =&gt; x*x, 3, 6) //将打印 9 16 25 36<br>printValues(Array(1, 1, 2, 3, 5, 8, 13, 21, 34, 55), 3, 6) //将打印 3 5 8 13</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> printValues(f:{<span class="keyword">def</span> apply(param:Int):Int}, from:Int, to:Int)={</div><div class="line">  <span class="keyword">for</span>(i &lt;- from to to) {</div><div class="line">    print(f.apply(i) + <span class="string">" "</span>)</div><div class="line">  }</div><div class="line">}</div><div class="line">printValues((x: Int) =&gt; x*x, <span class="number">3</span>, <span class="number">6</span>) <span class="comment">//将打印 9 16 25 36</span></div><div class="line">printValues(Array(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>), <span class="number">3</span>, <span class="number">6</span>) <span class="comment">//将打印 3 5 8 13</span></div></pre></td></tr></table></figure>

<p><strong>18.9</strong><br>考虑如下对物理度量建模的类：<br>abstract class Dim<a href="val value: Double, val name: String">T</a>{<br>    protected def create(v: Double): T<br>    def + (other: Dim[T]) = create(value + other.value)<br>    override def toString() = value + “ “ + name<br>}<br>以下是具体子类：<br>class Seconds(v: Double) extends Dim<a href="v," title="s">Seconds</a>{<br>    override def create(v: Double) = new Seconds(v)<br>}<br>但现在不清楚状况的人可能会定义<br>class Meters(v: Double) extends Dim<a href="v," title="m">Seconds</a>{<br>    override def create(v: Double) = new Seconds(v)<br>}<br>允许米（Meters）和秒（Seconds）相加。使用自身类型来防止发生这样的情况。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Dim</span>[<span class="title">T</span>]<span class="params">(val value: Double, val name: String)</span></span>{</div><div class="line">  <span class="keyword">this</span>: T =&gt;</div><div class="line">  <span class="keyword">protected</span> <span class="keyword">def</span> create(v: Double): T</div><div class="line">  <span class="keyword">def</span> + (other: Dim[T]) = create(value + other.value)</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> toString() = value + <span class="string">" "</span> + name</div><div class="line">}</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Seconds</span><span class="params">(v: Double)</span> <span class="keyword">extends</span> <span class="title">Dim</span>[<span class="title">Seconds</span>]<span class="params">(v, <span class="string">"s"</span>)</span></span>{</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> create(v: Double) = <span class="keyword">new</span> Seconds(v)</div><div class="line">}</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meters</span><span class="params">(v: Double)</span> <span class="keyword">extends</span> <span class="title">Dim</span>[<span class="title">Seconds</span>]<span class="params">(v, <span class="string">"m"</span>)</span></span>{</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> create(v: Double) = <span class="keyword">new</span> Seconds(v)</div><div class="line">}</div><div class="line"><span class="comment">//Meters can not extends Dim[Seconds] and compile fail</span></div></pre></td></tr></table></figure>

<p><strong>18.10</strong><br>自身类型通常可以被扩展自身的特质替代，但某些情况下使用自身类型会改变初始化和重写的顺序。构造出这样的一个示例。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">A</span> </span>{</div><div class="line">  <span class="keyword">def</span> sing() = <span class="string">"from a"</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">C</span> </span>{</div><div class="line">  <span class="keyword">this</span>: A =&gt;</div><div class="line">  <span class="keyword">val</span> w = sing + <span class="string">"from c"</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>{</div><div class="line">  <span class="keyword">this</span>: C =&gt;</div><div class="line">  <span class="keyword">val</span> k = w</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">val</span> b = <span class="keyword">new</span> B <span class="keyword">with</span> C <span class="keyword">with</span> A</div><div class="line">println(b.k)</div></pre></td></tr></table></figure>

<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》习题解答-第十七章-类型参数]]></title>
    <link href="http://vernonzheng.com/2015/02/10/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94-%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0-%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0/"/>
    <id>http://vernonzheng.com/2015/02/10/《快学scala》习题解答-第十七章-类型参数/</id>
    <published>2015-02-10T15:38:42.000Z</published>
    <updated>2015-02-11T03:47:23.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第十七章_类型参数">第十七章 类型参数</h2>
<p><strong>17.1</strong><br>定义一个不可变类Pair[T,S], 带一个swap方法，返回组件交换过位置的新对偶</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>[<span class="title">T</span>,<span class="title">S</span>]<span class="params">(val t:T,val s:S)</span></span>{</div><div class="line">  <span class="keyword">def</span> swap() = <span class="keyword">new</span> Pair(s,t)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>17.2</strong><br>定义一个可变类Pair[T]，带一个swap方法，交换对偶中组件的位置。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>[<span class="title">T</span>]<span class="params">(val s:T,val t:T)</span></span>{</div><div class="line">  <span class="keyword">def</span> swap() = <span class="keyword">new</span> Pair(t,s)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>17.3</strong><br>给定类Pair[T, S] ，编写一个泛型方法swap，接受对偶作为参数并返回组件交换过位置的新对偶。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>[<span class="title">T</span>,<span class="title">S</span>]<span class="params">(val t:T, val s:S)</span></span>{</div><div class="line">  <span class="keyword">def</span> swap[T,S](t:T,s:S) = <span class="keyword">new</span> Pair(s,t)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>17.4</strong><br>在17.3节中，如果我们想把Pair[Person]的第一个组件替换成Student，为什么不需要给replaceFirst方法定一个下界？</p>
<p>因为Student是Person的子类，是可以转成T类型的，不必定义下界</p>
<p><strong>17.5</strong><br>为什么RichInt实现的是Comparable[Int]而不是Comparable[RichInt]?</p>
<p>T &lt;% Comparable[T] ,是隐含参数转化的，T是Int的时候将自动调用RichInt中的Comparable[RichInt]</p>
<p><strong>17.6</strong><br>编写一个泛型方法middle，返回任何Iterable[T]的中间元素。举例来说，middle(“World”)应得到’r’。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> middle[T](iter:Iterable[T]):T={</div><div class="line">  <span class="keyword">val</span> seq = iter.toArray</div><div class="line">  seq(seq.length/<span class="number">2</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>17.7</strong><br>查看Iterable[+A]特质。哪些方法使用了类型参数A？为什么在这些方法中类型参数位于协变点？</p>
<p>如min, max, last 等。这些方法都会返回A类型，所以位于协变点。</p>
<p><strong>17.8</strong><br>在17.10节中，replaceFirst方法带有一个类型界定。为什么你不能对可变的Pair[T]定义一个等效的方法？<br>def replaceFirst<a href="newFirst: R" target="_blank" rel="external">R &gt;: T</a> { first = newFirst } //错误</p>
<p>因为first是子类，newFirst是超类，超类不能被赋值给子类。</p>
<p><strong>17.9</strong><br>在一个不可变类Pair[+T]中限制方法参数看上去可能有些奇怪。不过，先假定你可以在Pair[+T]定义<br>def replaceFirst(newFirst: T)<br>问题在于，该方法可能会被重写（以某种不可靠的方式）。构造出这样的一个示例。定义一个Pair[Double]的类型NastyDoublePair，重写replaceFirst方法，用newFirst的平方根来做新对偶。然后对实际类型为NastyDoublePair的Pair[Any]调用replaceFirst(“Hello”)。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Anyone resolve this, please contact me</span></div><div class="line"><span class="keyword">package</span> _1709 {</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>[+<span class="title">T</span>]<span class="params">(val t:T, val s:T)</span> </span>{</div><div class="line">  <span class="keyword">def</span> replaceFirst[T](newFirst: T) {}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NastyDoublePair</span>[<span class="title">Double</span>]<span class="params">(t1:Double, s1:Double)</span> <span class="keyword">extends</span> <span class="title">Pair</span>[<span class="title">Double</span>]<span class="params">(t1,s1)</span> </span>{</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> replaceFirst(newFirst: Double) ={</div><div class="line">    <span class="javadoc">/**</span></div><div class="line">     *  error: type mismatch;</div><div class="line">       found   : Double(in class NastyDoublePair)</div><div class="line">       required: scala.Double</div><div class="line">                 new NastyDoublePair(newFirst,math.sqrt(newFirst))</div><div class="line">     */</div><div class="line">    <span class="keyword">new</span> NastyDoublePair(newFirst,math.sqrt(newFirst))</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">test</span> <span class="keyword">extends</span> <span class="title">App</span> </span>{</div><div class="line">  <span class="keyword">val</span> p: Pair[Any] = <span class="keyword">new</span> NastyDoublePair(<span class="number">1.0</span>, <span class="number">2.0</span>)</div><div class="line">  p.replaceFirst(<span class="string">"Hello"</span>)</div><div class="line">}</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>17.10</strong><br>给定可变类Pair[S,T]，使用类型约束定义一个swap方法，当类型参数相同时可以被调用。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>[<span class="title">S</span>,<span class="title">T</span>]<span class="params">(val s:S, val t:T)</span></span>{</div><div class="line">  <span class="keyword">def</span> swap(implicit env: S =:= T) = <span class="keyword">new</span> Pair(t,s)</div><div class="line">}</div></pre></td></tr></table></figure>

<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开源分布式配置中心选型]]></title>
    <link href="http://vernonzheng.com/2015/02/09/%E5%BC%80%E6%BA%90%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E9%80%89%E5%9E%8B/"/>
    <id>http://vernonzheng.com/2015/02/09/开源分布式配置中心选型/</id>
    <published>2015-02-09T10:23:08.000Z</published>
    <updated>2015-02-10T10:41:20.000Z</updated>
    <content type="html"><![CDATA[<h1 id="一、目标">一、目标</h1>
<p>实现分布式配置中心：<br>（1）集中管理外部依赖的服务配置和服务内部配置<br>（2）提供web管理平台进行配置和查询<br>（3）支持服务注册与发现<br>（4）支持客户端拉取配置<br>（5）支持订阅与发布，配置变更主动通知到client，实时变更配置</p>
<p>备注：client为nodeJS，java等</p>
<h1 id="二、开源解决方案调研">二、开源解决方案调研</h1>
<h2 id="2-1_disconf">2.1 disconf</h2>
<p>百度开源<br>与spring集成的很好，有web管理，client只支持java。</p>
<h3 id="2-1-1_介绍">2.1.1 介绍</h3>
<p><a href="https://github.com/knightliao/disconf/wiki" target="_blank" rel="external">https://github.com/knightliao/disconf/wiki</a></p>
<h3 id="2-1-2_源码">2.1.2 源码</h3>
<p><a href="https://github.com/knightliao/disconf" target="_blank" rel="external">https://github.com/knightliao/disconf</a></p>
<h2 id="2-2_diamond">2.2 diamond</h2>
<p>阿里开源<br>阿里内部应用广泛，由http server(nameservers), diamond-server ，web组成，diamond-server连接同一个mysql，数据同步通过mysql dump文件同步（同步效率？），支持订阅发布，client只支持java。</p>
<h3 id="2-2-1_介绍">2.2.1 介绍</h3>
<p><a href="http://code.taobao.org/p/diamond/wiki/index/" target="_blank" rel="external">http://code.taobao.org/p/diamond/wiki/index/</a></p>
<h3 id="2-2-2_源码">2.2.2 源码</h3>
<p><a href="http://code.taobao.org/svn/diamond/trunk" target="_blank" rel="external">http://code.taobao.org/svn/diamond/trunk</a> </p>
<h2 id="2-3_doozer">2.3 doozer</h2>
<p>已停止更新，设计倾向于实时的数据变更通知，数据全部放于内存，不会持久化文件。（有独立工具支持，不知支持性怎样？）</p>
<h2 id="2-4_etcd">2.4 etcd</h2>
<p>CoreOS开源。<br>轻量级分布式key-value数据库，同时为集群环境的服务发现和注册而设计。<br>它提供了数据TTL失效（通过TTL更新来判断机器下线，来避免一定的网络分区问题）、数据改变监视、多值、目录监听、分布式锁原子操作等功能，来管理节点状态。</p>
<h3 id="2-4-1_特性">2.4.1 特性</h3>
<ul>
<li>简单: curl可访问的用户的API（HTTP+JSON）</li>
<li>安全: 可选的SSL客户端证书认证</li>
<li>快速: 单实例每秒 1000 次写操作</li>
<li>可靠: 使用Raft保证一致性<br>注：zookeeper使用的比较复杂基于Paxos的Zab协议，etcd使用的Standford新的一致性算法Raft，概念上会简单些，0.4.6版本依赖于go-raft，0.5.0以上重新设计。</li>
</ul>
<h3 id="2-4-2_目前版本">2.4.2 目前版本</h3>
<p>网上的介绍文章基本停留到稳定版0.4.6上。目前版本已从0.x直接跳到了2.0版本。（2015-1-28）<br><a href="https://coreos.com/blog/etcd-2.0-release-first-major-stable-release/" target="_blank" rel="external">https://coreos.com/blog/etcd-2.0-release-first-major-stable-release/</a><br>2.0介绍（需要翻墙）：<br><a href="https://www.youtube.com/watch?v=z6tjawXZ71E" target="_blank" rel="external">https://www.youtube.com/watch?v=z6tjawXZ71E</a></p>
<p>使用go语言，部署简单，同时项目较年轻。</p>
<h3 id="2-4-3_介绍">2.4.3 介绍</h3>
<p>从实现原理到应用场景多方位解读（2015-1-30）<br><a href="http://www.infoq.com/cn/articles/etcd-interpretation-application-scenario-implement-principle" target="_blank" rel="external">http://www.infoq.com/cn/articles/etcd-interpretation-application-scenario-implement-principle</a></p>
<h3 id="2-4-4_源码">2.4.4 源码</h3>
<p><a href="https://github.com/coreos/etcd" target="_blank" rel="external">https://github.com/coreos/etcd</a></p>
<h2 id="2-5_zookeeper">2.5 zookeeper</h2>
<p>成熟的分布式配置解决方案，待续。。</p>
<h2 id="2-6_比较etcd和zookeeper">2.6 比较etcd和zookeeper</h2>
<p>Jason Wilder的一篇博客分别对常见的服务发现开源项目Zookeeper、Doozer、etcd进行了总结。<br><a href="http://jasonwilder.com/blog/2014/02/04/service-discovery-in-the-cloud/" target="_blank" rel="external">http://jasonwilder.com/blog/2014/02/04/service-discovery-in-the-cloud/</a></p>
<p>重点关注etcd是否能取代zookeeper。</p>
<h3 id="2-6-1_性能">2.6.1 性能</h3>
<p>只从实现语言上考虑，golang性能近c，java在大型集群的多线程能力较好，总体相差不多。都能支持上千节点。</p>
<h3 id="2-6-2_功能性：关注订阅发布、ttl特性">2.6.2 功能性：关注订阅发布、ttl特性</h3>
<h4 id="2-6-2-1_订阅发布">2.6.2.1 订阅发布</h4>
<p>etcd 可以使用递归的Watcher，递归式的监控应用（主题）目录下所有信息的变动。这样就实现了机器IP（消息）变动的时候，能够实时通知到收集器调整任务分配。</p>
<p><strong>递归订阅</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">etcd递归 watcher</div><div class="line">$ etcdctl watch /foo-service --recursive</div><div class="line">$ curl -L http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">4001</span>/v2/keys/foo-service?wait=<span class="literal">true</span>\&recursive=<span class="literal">true</span></div></pre></td></tr></table></figure>

<p><strong>订阅通知</strong>，在/foo-service增加container2，返回：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">etcd 递归监听 返回</div><div class="line">$ etcdctl watch /foo-service --recursive</div><div class="line">localhost:<span class="number">2222</span></div><div class="line">$ curl -L http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">4001</span>/v2/keys/foo-service?wait=<span class="literal">true</span>\&recursive=<span class="literal">true</span></div><div class="line">{<span class="string">"action"</span>:<span class="string">"set"</span>,<span class="string">"node"</span>:{<span class="string">"key"</span>:<span class="string">"/foo-service/container2"</span>,<span class="string">"value"</span>:<span class="string">"localhost:2222"</span>,<span class="string">"modifiedIndex"</span>:<span class="number">23</span>,<span class="string">"createdIndex"</span>:<span class="number">23</span>}}</div></pre></td></tr></table></figure>

<h4 id="2-6-2-2_TTL机制">2.6.2.2 TTL机制</h4>
<p><strong>更新方式</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">etcd ttl更新</div><div class="line">$ etcdctl <span class="keyword">set</span> /foo <span class="string">"Expiring Soon"</span> --ttl <span class="number">20</span></div><div class="line">Expiring Soon</div><div class="line">$ curl -L -X PUT http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">4001</span>/v2/keys/foo?ttl=<span class="number">20</span> <span class="operator">-d</span> value=bar</div><div class="line">{<span class="string">"action"</span>:<span class="string">"set"</span>,<span class="string">"node"</span>:{<span class="string">"key"</span>:<span class="string">"/foo"</span>,<span class="string">"value"</span>:<span class="string">"bar"</span>,<span class="string">"expiration"</span>:<span class="string">"2014-02-10T19:54:49.357382223Z"</span>,<span class="string">"ttl"</span>:<span class="number">20</span>,<span class="string">"modifiedIndex"</span>:<span class="number">31</span>,<span class="string">"createdIndex"</span>:<span class="number">31</span>}}</div></pre></td></tr></table></figure>

<p><strong>get ttl过期的数据</strong>，返回errorCode：100</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">etcd ttl 过期数据返回</div><div class="line">$ etcdctl get /foo</div><div class="line">Error: <span class="number">100</span>: Key not found (/foo) [<span class="number">32</span>]</div><div class="line">$ curl -L http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">4001</span>/v2/keys/foo</div><div class="line">{<span class="string">"errorCode"</span>:<span class="number">100</span>,<span class="string">"message"</span>:<span class="string">"Key not found"</span>,<span class="string">"cause"</span>:<span class="string">"/foo"</span>,<span class="string">"index"</span>:<span class="number">32</span>}</div></pre></td></tr></table></figure>

<h3 id="2-6-3_部署结构">2.6.3 部署结构</h3>
<p>etcd支持<strong>普通节点</strong>模式和<strong>proxy模式</strong>两种：<br>启动设置集群大小，超过集群大小的etcd节点自动转化为proxy模式。</p>
<h4 id="2-6-3-1_proxy模式">2.6.3.1 proxy模式</h4>
<p>etcd作为一个反向代理把客户的请求转发给可用的etcd集群。这样，你就可以在每一台机器都部署一个Proxy模式的etcd作为本地服务，如果这些etcd Proxy都能正常运行，那么你的服务发现必然是稳定可靠的。<br>如图：</p>
<p><img src="http://7te9ul.com1.z0.glb.clouddn.com/etcd_proxy" alt="etcd-proxy"> </p>
<h3 id="2-6-4_总结">2.6.4 总结</h3>
<p>etcd特性略胜于zookeeper两点：<br>（1）etcd在订阅发布机制上能提供的功能与zookeeper相似。但是更轻量级，使用api更简单，依赖少，可直接使用curl/http+json或etcdctl的方式。<br>（2）etcd的TTL机制能避免一定的网络分区问题（如网络间断误认为注册服务下线）</p>
<p>zookeeper胜于etcd两点：<br>（1）成熟，稳定性高，多数坑已被踩过。<br>（2）配套工具：etcd没有web监控平台，client有node-etcd 3.0，较年轻。zookeeper有简单易用的exhibitor监控，java client的curator替代zkclient，非常成熟易用，避免掉坑。</p>
<h4 id="2-6-4-1_综合实际情况">2.6.4.1 综合实际情况</h4>
<p>线上已有zookeeper集群，考虑部署成本，避免踩坑，和zookeeper稳定和成熟配套工具，风险等，建议基于zookeeper进行封装开发。<br>如果小型集群，也是可以尝试etcd，毕竟架构部署简单省事。</p>
<hr>
<p>参考：</p>
<ul>
<li>Open-Source Service Discovery：<a href="http://jasonwilder.com/blog/2014/02/04/service-discovery-in-the-cloud/" target="_blank" rel="external">http://jasonwilder.com/blog/2014/02/04/service-discovery-in-the-cloud/</a></li>
<li>etcd：从应用场景到实现原理的全方位解读：<a href="http://www.infoq.com/cn/articles/etcd-interpretation-application-scenario-implement-principle" target="_blank" rel="external">http://www.infoq.com/cn/articles/etcd-interpretation-application-scenario-implement-principle</a></li>
<li>etcd：用于服务发现的键值存储系统：<a href="http://www.infoq.com/cn/news/2014/07/etcd-cluster-discovery" target="_blank" rel="external">http://www.infoq.com/cn/news/2014/07/etcd-cluster-discovery</a></li>
<li>构建一个高可用及自动发现的Docker基础架构-HECD[原创]：<a href="http://blog.liuts.com/post/242/" target="_blank" rel="external">http://blog.liuts.com/post/242/</a></li>
<li>CoreOS 实战：剖析 etcd：<a href="http://www.infoq.com/cn/articles/coreos-analyse-etcd/" target="_blank" rel="external">http://www.infoq.com/cn/articles/coreos-analyse-etcd/</a></li>
<li>diamond wiki：<a href="http://code.taobao.org/p/diamond/wiki/index/" target="_blank" rel="external">http://code.taobao.org/p/diamond/wiki/index/</a></li>
<li>disconf github：<a href="https://github.com/knightliao/disconf/wiki" target="_blank" rel="external">https://github.com/knightliao/disconf/wiki</a></li>
<li>etcd github：<a href="https://github.com/coreos/etcd" target="_blank" rel="external">https://github.com/coreos/etcd</a></li>
<li>Paxos在大型系统中常见的应用场景：<a href="http://timyang.net/distributed/paxos-scenarios/" target="_blank" rel="external">http://timyang.net/distributed/paxos-scenarios/</a></li>
<li>The Raft Consensus Algorithm：<a href="http://raftconsensus.github.io/" target="_blank" rel="external">http://raftconsensus.github.io/</a></li>
</ul>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="一、目标">一、目标</h1>
<p>实现分布式配置中心：<br>（1）集中管理外部依赖的服务配置和服务内部配置<br>（2）提供web管理平台进行配置和查询<br>（3）支持服务注册与发现<br>（4）支持客户端拉取配置<br>（5）支持订阅与发布，配置变更主动]]>
    </summary>
    
      <category term="etcd" scheme="http://vernonzheng.com/tags/etcd/"/>
    
      <category term="zookeeper" scheme="http://vernonzheng.com/tags/zookeeper/"/>
    
      <category term="diamond" scheme="http://vernonzheng.com/tags/diamond/"/>
    
      <category term="中间件" scheme="http://vernonzheng.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》习题解答-第十六章-XML处理]]></title>
    <link href="http://vernonzheng.com/2015/02/08/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94-%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-XML%E5%A4%84%E7%90%86/"/>
    <id>http://vernonzheng.com/2015/02/08/《快学scala》习题解答-第十六章-XML处理/</id>
    <published>2015-02-08T09:51:42.000Z</published>
    <updated>2015-02-10T15:31:20.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第十六章_XML处理">第十六章 XML处理</h2>
<p><strong>16.1</strong></p>
<p><fred>(0)得到什么？<fred>(0)(0)呢？为什么？</fred></fred></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">scala&gt; println(&lt;fred/&gt;(<span class="number">0</span>))</div><div class="line">&lt;fred/&gt;</div><div class="line"></div><div class="line">scala&gt; println(&lt;fred/&gt;(<span class="number">0</span>)(<span class="number">0</span>))</div><div class="line">&lt;fred/&gt;</div></pre></td></tr></table></figure>

<p>因为都是scala.xml.Node，是NodeSeq的子类，等同于长度为1的序列。</p>
<p><strong>16.2</strong><br>如下代码的值是什么？</p>
<p><ul><br>  <li>Opening bracket:[</li><br>  <li>Closing bracket:]</li><br>  <li>Opening bracket:{</li><br>  <li>Closing bracket:}</li><br></ul><br>你如何修复它？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">scala&gt; &lt;ul&gt;</div><div class="line">     |   &lt;li&gt;Opening bracket:[&lt;/li&gt;</div><div class="line">     |   &lt;li&gt;Closing bracket:]&lt;/li&gt;</div><div class="line">     |   &lt;li&gt;Opening bracket:\{\{&lt;/li&gt;</div><div class="line">     |   &lt;li&gt;Closing bracket:\}\}&lt;/li&gt;</div><div class="line">     | &lt;/ul&gt;</div><div class="line">res9: scala.xml.Elem =</div><div class="line">&lt;ul&gt;</div><div class="line">  &lt;li&gt;Opening bracket:[&lt;/li&gt;</div><div class="line">  &lt;li&gt;Closing bracket:]&lt;/li&gt;</div><div class="line">  &lt;li&gt;Opening bracket:{&lt;/li&gt;</div><div class="line">  &lt;li&gt;Closing bracket:}&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure>

<p>花括号作为字面量，需要连写两个</p>
<p><strong>16.3</strong><br>对比<br>  <li>Fred</li> match { case <li>{Text(t)}</li> =&gt; t }<br>和<br>  <li>{“Fred”}</li> match { case <li>{Text(t)}</li> =&gt; t}<br>为什么它们的行为不同？</p>
<p>scala 2.11.4查不到Text api。。略</p>
<p><strong>16.4</strong><br>读取一个XHTML文件并打印所有不带alt属性的img元素</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.xml.XML</div><div class="line"></div><div class="line"><span class="keyword">var</span> html = <span class="string">"&lt;html&gt;&lt;head&gt;&lt;title&gt;第一个网页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;img alt='a'&gt;&lt;img src='1'&gt;&lt;/img&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"</span></div><div class="line"><span class="keyword">val</span> images = (html \\ <span class="string">"img"</span>).filterNot(_.attributes(<span class="string">"alt"</span>).isDefined)</div><div class="line"><span class="keyword">val</span> images1 = html <span class="keyword">match</span>{</div><div class="line">  <span class="keyword">case</span> n @ &lt;img/&gt; <span class="keyword">if</span> (!n.attributes(<span class="string">"alt"</span>)) =&gt; n</div><div class="line">}</div><div class="line"></div><div class="line">println(images.mkString(<span class="string">"\n"</span>));</div><div class="line">println(images1.mkString(<span class="string">"\n"</span>));</div></pre></td></tr></table></figure>

<p><strong>16.5</strong><br>打印XHTML文件中所有图像的名称，即打印所有位于img元素内的src属性值</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.xml.XML</div><div class="line"></div><div class="line"><span class="keyword">var</span> html = <span class="string">"&lt;html&gt;&lt;head&gt;&lt;title&gt;第一个网页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;img alt='a'&gt;&lt;img src='1'&gt;&lt;/img&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"</span></div><div class="line"><span class="keyword">val</span> images = (html \\ <span class="string">"img"</span>).flatMap(_.attributes(<span class="string">"src"</span>))</div><div class="line"><span class="keyword">val</span> images1 = html <span class="keyword">match</span>{</div><div class="line">  <span class="keyword">case</span> n @ &lt;img/&gt; =&gt; Some(n.attributes(<span class="string">"src"</span>))</div><div class="line">}</div><div class="line"></div><div class="line">println(images.mkString(<span class="string">"\n"</span>));</div><div class="line">println(images1.mkString(<span class="string">"\n"</span>));</div></pre></td></tr></table></figure>

<p><strong>16.6</strong><br>读取XHTML文件并打印一个包含了文件中给出的所有超链接及其url的表格。即，打印所有a元素的child文本和href属性。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.xml._</div><div class="line"></div><div class="line"><span class="keyword">val</span> html = <span class="string">""</span></div><div class="line"><span class="keyword">val</span> links = (html \\ <span class="string">"a"</span>) map { (x: Node) =&gt; (x.attribute(<span class="string">"href"</span>).getOrElse(<span class="string">""</span>).toString, x.text) } filter {_._1.startsWith(<span class="string">"http"</span>)}</div><div class="line"></div><div class="line">println(links.mkString(<span class="string">"\n"</span>));</div></pre></td></tr></table></figure>

<p><strong>16.7</strong><br>编写一个函数，带一个类型为Map[String,String]的参数，返回一个dl元素，其中针对映射中每个键对应有一个dt，每个值对应有一个dd，例如：<br>Map(“A”-&gt;”1”,”B”-&gt;”2”)<br>应产出<dl><dt>A</dt><dd>1</dd><dt>B</dt><dd>2</dd></dl></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> mapToHTML(map: Map[String, String]) = {</div><div class="line">  &lt;dl&gt;{<span class="keyword">for</span> ((k,v) &lt;- map) <span class="keyword">yield</span> &lt;dt&gt;{k}&lt;/dt&gt;&lt;dd&gt;{v}&lt;/dd&gt;}&lt;/dl&gt;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">val</span> x = Map(<span class="string">"A"</span> -&gt; <span class="string">"1"</span>, <span class="string">"B"</span> -&gt; <span class="string">"2"</span>)</div><div class="line"></div><div class="line">println(mapToHTML(x))</div></pre></td></tr></table></figure>

<p><strong>16.8</strong><br>编写一个函数，接受dl元素，将它转成Map[String,String]。该函数应该是前一个练习中的<br>反向处理，前提是所有dt后代都是唯一的。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> htmlToMap(str:String):Map[String,String] = {</div><div class="line">  <span class="keyword">val</span> dtMap = (str \\ <span class="string">"dt"</span>).toMap</div><div class="line">  <span class="keyword">val</span> ddMap = (str \\ <span class="string">"dd"</span>).toMap</div><div class="line">  dtMap.zip(ddMap)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">val</span> html = &lt;dl&gt;&lt;dt&gt;A&lt;/dt&gt;&lt;dd&gt;<span class="number">1</span>&lt;/dd&gt;&lt;dt&gt;B&lt;/dt&gt;&lt;dd&gt;<span class="number">2</span>&lt;/dd&gt;&lt;/dl&gt;</div><div class="line">println(htmlToMap(html).mkString(<span class="string">","</span>))</div></pre></td></tr></table></figure>

<p><strong>16.9</strong><br>对一个XHTML文档进行变换，对所有不带alt属性的img元素添加一个alt=”TODO”属性，其他内容完全不变。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.xml._</div><div class="line"><span class="keyword">val</span> html = <span class="string">""</span></div><div class="line"><span class="keyword">val</span> replaceNoneAlt = html <span class="keyword">match</span>{</div><div class="line">  <span class="keyword">case</span> img @ &lt;img/&gt; <span class="keyword">if</span>(_.attribute(alt)==<span class="string">"NONE"</span>) =&gt; img % Attribute(<span class="keyword">null</span>,<span class="string">"alt"</span>,<span class="string">"TODO"</span>,<span class="keyword">null</span>)</div><div class="line">  <span class="keyword">case</span> _ =&gt; html</div><div class="line">}</div><div class="line">println(replaceNoneAlt)</div></pre></td></tr></table></figure>

<p><strong>16.10</strong><br>编写一个函数，读取XHTML文档，执行前一个练习中的变换，并保存结果。确保保留了DTD以及所有CDATA内容。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> xml._</div><div class="line"><span class="keyword">import</span> xml.transform._</div><div class="line"><span class="keyword">import</span> xml.parsing.ConstructingParser</div><div class="line"><span class="keyword">import</span> xml.dtd.DocType</div><div class="line"><span class="keyword">import</span> java.io.File</div><div class="line"></div><div class="line"><span class="keyword">val</span> doc = ConstructingParser.fromFile(<span class="keyword">new</span> File(<span class="string">"./test.xml"</span>),</div><div class="line">  <span class="keyword">true</span>).document</div><div class="line"><span class="keyword">val</span> a = doc.docElem</div><div class="line"></div><div class="line"><span class="keyword">val</span> imgRule = <span class="keyword">new</span> RewriteRule {</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> transform(n:Node) = n <span class="keyword">match</span> {</div><div class="line">    <span class="keyword">case</span> i @ &lt;img&gt;{_*}&lt;/img&gt; <span class="keyword">if</span>(i.attribute(<span class="string">"alt"</span>) == None) =&gt;</div><div class="line">      i % Attribute(<span class="keyword">null</span>, <span class="string">"alt"</span>, <span class="string">"TODO"</span>, Null)</div><div class="line">    <span class="keyword">case</span> _ =&gt; n</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">val</span> result = <span class="keyword">new</span> RuleTransformer(imgRule).transform(a)</div><div class="line">XML.save(<span class="string">"./test.xml"</span>, result(<span class="number">0</span>), <span class="string">"UTF-8"</span>, <span class="keyword">false</span>,</div><div class="line">  DocType(<span class="string">"html"</span>, doc.dtd.externalID, Nil))</div></pre></td></tr></table></figure>

<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》习题解答-第十五章-注解]]></title>
    <link href="http://vernonzheng.com/2015/02/08/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94-%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E6%B3%A8%E8%A7%A3/"/>
    <id>http://vernonzheng.com/2015/02/08/《快学scala》习题解答-第十五章-注解/</id>
    <published>2015-02-08T09:51:42.000Z</published>
    <updated>2015-02-08T10:30:56.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第十五章_注解">第十五章 注解</h2>
<p><strong>15.1</strong><br>编写四个JUnit测试用例，分别使用带或不带某个参数的@Test注解。用JUnit执行这些测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.junit.Test</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScalaTest</span> </span>{</div><div class="line"></div><div class="line">  <span class="annotation">@Test</span></div><div class="line">  <span class="keyword">def</span> test1(){</div><div class="line">    print(<span class="string">"test1"</span>)</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="annotation">@Test</span>(timeout = <span class="number">1</span>L)</div><div class="line">  <span class="keyword">def</span> test2(){</div><div class="line">    print(<span class="string">"test2"</span>)</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>15.2</strong><br>创建一个类的示例，展示注解可以出现的所有位置。用@deprecated作为你的示例注解。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@deprecated</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>{</div><div class="line"></div><div class="line">  <span class="annotation">@deprecated</span></div><div class="line">  <span class="keyword">val</span> t = _;</div><div class="line"></div><div class="line">  <span class="annotation">@deprecated</span>(message = <span class="string">"unuse"</span>)</div><div class="line">  <span class="keyword">def</span> hello(){</div><div class="line">    println(<span class="string">"hello"</span>)</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="annotation">@deprecated</span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>{</div><div class="line">  <span class="keyword">val</span> t = <span class="keyword">new</span> Test()</div><div class="line">  t.hello()</div><div class="line">  t.t</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>15.3</strong><br>Scala类库中的哪些注解用到了元注解@param,@field,@getter,@setter,@beanGetter或@beanSetter?</p>
<p>略</p>
<p><strong>15.4</strong><br>编写一个Scala方法sum,带有可变长度的整型参数，返回所有参数之和。从Java调用该方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.annotation.varargs</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</div><div class="line">  <span class="annotation">@varargs</span> <span class="keyword">def</span> sum(nums: Int*): Int = {</div><div class="line">    nums.sum</div><div class="line">  }</div><div class="line">}</div><div class="line"><span class="javadoc">/** Test2.java</span></div><div class="line">class Test2 {</div><div class="line"></div><div class="line">  public static void main(String[] args){</div><div class="line">    Test t = new Test();</div><div class="line">    System.out.println(t.sum(1,2,3));</div><div class="line">  }</div><div class="line">}</div><div class="line">  **/</div></pre></td></tr></table></figure>

<p><strong>15.5</strong><br>编写一个返回包含某文件所有行的字符串的方法。从Java调用该方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> io.Source</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test5</span></span>{</div><div class="line"></div><div class="line">  <span class="keyword">def</span> read()={</div><div class="line">    Source.fromFile(<span class="string">"test.txt"</span>).mkString</div><div class="line">  }</div><div class="line">}</div><div class="line"><span class="javadoc">/*** Test2.java</span></div><div class="line">public class Hello {</div><div class="line">  public static void main(String[] args){</div><div class="line">    Test5 t = new Test5();</div><div class="line">    System.out.println(t.read());</div><div class="line">  }</div><div class="line">}</div><div class="line">  ***/</div></pre></td></tr></table></figure>

<p><strong>15.6</strong><br>编写一个Scala对象，该对象带有一个易失(volatile)的Boolean字段。让某一个线程睡眠一段时间，之后将该字段设为true，打印消息，然后退出。而另一个线程不停的检查该字段是否为true。如果是，它将打印一个消息并退出。如果不是，则它将短暂睡眠，然后重试。如果变量不是易失的，会发生什么？</p>
<p>没区别</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> concurrent.ops.spawn</div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test06</span></span>{</div><div class="line">  <span class="annotation">@volatile</span> <span class="keyword">var</span> value = <span class="keyword">false</span></div><div class="line">}</div><div class="line"></div><div class="line">spawn {</div><div class="line">  Thread.sleep(<span class="number">100</span>);</div><div class="line">  Test06.value = <span class="keyword">true</span></div><div class="line">  println(<span class="string">"Thread1: setting value to TRUE!"</span>)</div><div class="line">}</div><div class="line"></div><div class="line">spawn {</div><div class="line">  <span class="keyword">while</span>(!Test06.value) Thread.sleep(<span class="number">20</span>);</div><div class="line">  println(<span class="string">"Thread2: value is TRUE!"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>15.7</strong><br>给出一个示例，展示如果方法可被重写，则尾递归优化为非法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> annotation.tailrec</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>{</div><div class="line">  <span class="annotation">@tailrec</span></div><div class="line">  <span class="keyword">def</span> sum2(xs : Seq[Int],partial : BigInt) : BigInt = {</div><div class="line">    <span class="keyword">if</span> (xs.isEmpty) partial <span class="keyword">else</span> sum2(xs.tail,xs.head + partial)</div><div class="line">  }</div><div class="line"></div><div class="line">  println(sum2(<span class="number">1</span> to <span class="number">1000000</span>,<span class="number">0</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>15.8</strong><br>将allDifferent方法添加到对象，编译并检查字节码。@specialized注解产生了哪些方法?</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span></span>{</div><div class="line">  <span class="keyword">def</span> allDifferent[<span class="annotation">@specialized</span> T](x:T,y:T,z:T) = x != y && x!= z && y != z</div><div class="line">}</div></pre></td></tr></table></figure>

<p>javap Test$得到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>$ <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span></span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Test$ MODULE$;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> {};</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allDifferent</span>(java.lang.Object, java.lang.Object, java.lang.Ob</div><div class="line">ject);</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> allDifferent$mZc$<span class="title">sp</span>(<span class="keyword">boolean</span>, <span class="keyword">boolean</span>, <span class="keyword">boolean</span>);</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> allDifferent$mBc$<span class="title">sp</span>(<span class="keyword">byte</span>, <span class="keyword">byte</span>, <span class="keyword">byte</span>);</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> allDifferent$mCc$<span class="title">sp</span>(<span class="keyword">char</span>, <span class="keyword">char</span>, <span class="keyword">char</span>);</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> allDifferent$mDc$<span class="title">sp</span>(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>);</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> allDifferent$mFc$<span class="title">sp</span>(<span class="keyword">float</span>, <span class="keyword">float</span>, <span class="keyword">float</span>);</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> allDifferent$mIc$<span class="title">sp</span>(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>);</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> allDifferent$mJc$<span class="title">sp</span>(<span class="keyword">long</span>, <span class="keyword">long</span>, <span class="keyword">long</span>);</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> allDifferent$mSc$<span class="title">sp</span>(<span class="keyword">short</span>, <span class="keyword">short</span>, <span class="keyword">short</span>);</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> allDifferent$mVc$<span class="title">sp</span>(scala.runtime.BoxedUnit, scala.runtime.Bo</div><div class="line">xedUnit, scala.runtime.BoxedUnit);</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>15.9</strong><br>Range.foreach方法被注解为@specialized(Unit)。为什么？通过以下命令检查字节码:<br>javap -classpath /path/to/scala/lib/scala-library.jar scala.collection.immutable.Range<br>并考虑Function1上的@specialized注解。点击Scaladoc中的Function1.scala链接进行查看</p>
<p>首先来看Function1的源码</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">......</div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Function1</span>[@<span class="title">specialized</span><span class="params">(scala.Int, scala.Long, scala.Float, scala.Double/*, scala.AnyRef*/)</span> -<span class="title">T1</span>, @<span class="title">specialized</span><span class="params">(scala.Unit, scala.Boolean, scala.Int, scala.Float, scala.Long, scala.Double/*, scala.AnyRef*/)</span> +<span class="title">R</span>] <span class="keyword">extends</span> <span class="title">AnyRef</span> </span>{ self =&gt;</div><div class="line">  <span class="javadoc">/** Apply the body of this function to the argument.</span></div><div class="line">   *  <span class="javadoctag">@return</span>   the result of function application.</div><div class="line">   */</div><div class="line">  <span class="keyword">def</span> apply(v1: T1): R</div><div class="line">......</div></pre></td></tr></table></figure>

<p>可以看到Function1参数可以是scala.Int,scala.Long,scala.Float,scala.Double，返回值可以是scala.Unit,scala.Boolean,scala.Int,scala.Float,scala.Long,scala.Double 再来看Range.foreach的源码</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">...... </div><div class="line"><span class="annotation">@inline</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">def</span> foreach[<span class="annotation">@specialized</span>(Unit) U](f: Int =&gt; U) {</div><div class="line">    <span class="keyword">if</span> (validateRangeBoundaries(f)) {</div><div class="line">      <span class="keyword">var</span> i = start</div><div class="line">      <span class="keyword">val</span> terminal = terminalElement</div><div class="line">      <span class="keyword">val</span> step = <span class="keyword">this</span>.step</div><div class="line">      <span class="keyword">while</span> (i != terminal) {</div><div class="line">        f(i)</div><div class="line">        i += step</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div><div class="line">......</div></pre></td></tr></table></figure>

<p>首先此方法是没有返回值的，也就是Unit。而Function1的返回值可以是scala.Unit,scala.Boolean,scala.Int,scala.Float,scala.Long,scala.Double 如果不限定@specialized(Unit),则Function1可能返回其他类型，但是此方法体根本就不返回，即使设置了也无法获得返回值</p>
<p><strong>15.10</strong><br>添加assert(n &gt;= 0)到factorial方法。在启用断言的情况下编译并校验factorial(-1)会抛异常。在禁用断言的情况下编译。会发生什么？用javap检查该断言调用</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>{</div><div class="line">  <span class="keyword">def</span> factorial(n: Int): Int = {</div><div class="line">    assert(n &gt; <span class="number">0</span>)</div><div class="line">    n</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> main(args: Array[String]) {</div><div class="line">    factorial(-<span class="number">1</span>)</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>编译报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Exception in thread <span class="string">"main"</span> java.lang.AssertionError: assertion failed</div><div class="line">        at scala.Predef$.<span class="keyword">assert</span>(Predef.scala:<span class="number">165</span>)</div><div class="line">        at Test$.factorial(Test.scala:<span class="number">6</span>)</div><div class="line">        at Test$.main(Test.scala:<span class="number">11</span>)</div><div class="line">        at Test.main(Test.scala)</div><div class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</div><div class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">39</span>)</div><div class="line">        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">25</span>)</div><div class="line">        at java.lang.reflect.Method.invoke(Method.java:<span class="number">597</span>)</div><div class="line">        at com.intellij.rt.execution.application.AppMain.main(AppMain.java:<span class="number">120</span>)</div></pre></td></tr></table></figure>

<p>禁用assert<br>-Xelide-below 2011<br>反编译此类javap -c Test$ 得到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">......</div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">factorial</span>(<span class="keyword">int</span>);</div><div class="line">  Code:</div><div class="line">   <span class="number">0</span>:   getstatic       #<span class="number">19</span>; <span class="comment">//Field scala/Predef$.MODULE$:Lscala/Predef$;</span></div><div class="line">   <span class="number">3</span>:   iload_1</div><div class="line">   <span class="number">4</span>:   iconst_0</div><div class="line">   <span class="number">5</span>:   if_icmple       <span class="number">12</span></div><div class="line">   <span class="number">8</span>:   iconst_1</div><div class="line">   <span class="number">9</span>:   goto    <span class="number">13</span></div><div class="line">   <span class="number">12</span>:  iconst_0</div><div class="line">   <span class="number">13</span>:  invokevirtual   #<span class="number">23</span>; <span class="comment">//Method scala/Predef$.assert:(Z)V</span></div><div class="line">   <span class="number">16</span>:  iload_1</div><div class="line">   <span class="number">17</span>:  ireturn</div><div class="line">......</div></pre></td></tr></table></figure>

<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》习题解答-第十四章-模式匹配和样例集合]]></title>
    <link href="http://vernonzheng.com/2015/02/08/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94-%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%92%8C%E6%A0%B7%E4%BE%8B%E9%9B%86%E5%90%88/"/>
    <id>http://vernonzheng.com/2015/02/08/《快学scala》习题解答-第十四章-模式匹配和样例集合/</id>
    <published>2015-02-08T05:15:42.000Z</published>
    <updated>2015-02-08T07:16:17.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第十四章_模式匹配和样例类">第十四章 模式匹配和样例类</h2>
<p><strong>14.1</strong><br>JDK发行包有一个src.zip文件包含了JDK的大多数源代码。解压并搜索样例标签(用正则表达式case [^:]+:)。然后查找以//开头并包含[Ff]alls?thr的注释，捕获类似// Falls through或// just fall thru这样的注释。假定JDK的程序员们遵守Java编码习惯，在该写注释的地方写下了这些注释，有多少百分比的样例是会掉入到下一个分支的？</p>
<p>略</p>
<p><strong>14.2</strong><br>利用模式匹配，编写一个swap函数，接受一个整数的对偶，返回对偶的两个组成部件互换位置的新对偶</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> swap[S,T](tup: (S,T))={</div><div class="line">  tup <span class="keyword">match</span>{</div><div class="line">    <span class="keyword">case</span> (a,b) =&gt; (b,a)</div><div class="line">  }</div><div class="line">}</div><div class="line">println(swap[String,Int]((<span class="string">"1"</span>,<span class="number">2</span>)))</div></pre></td></tr></table></figure>

<p><strong>14.3</strong><br>利用模式匹配，编写一个swap函数，交换数组中的前两个元素的位置，前提条件是数组长度至少为2</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> swap(array:Array[Any])={</div><div class="line">  array <span class="keyword">match</span>{</div><div class="line">    <span class="keyword">case</span> Array(first,second,rest @_*)=&gt; Array(second,first)++rest</div><div class="line">    <span class="keyword">case</span> _ =&gt; array</div><div class="line">  }</div><div class="line">}</div><div class="line">println(swap(Array(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>)).mkString)</div></pre></td></tr></table></figure>

<p><strong>14.4</strong><br>添加一个样例类Multiple，作为Item的子类。举例来说，Multiple(10,Article(“Blackwell Toster”,29.95))描述的是10个烤面包机。当然了，你应该可以在第二个参数的位置接受任何Item，无论是Bundle还是另一个Multiple。扩展price函数以应对新的样例。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Multiple</span><span class="params">(num : Int,item : Item)</span> <span class="keyword">extends</span> <span class="title">Item</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Article</span><span class="params">(description : String , price : Double)</span> <span class="keyword">extends</span> <span class="title">Item</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Bundle</span><span class="params">(description : String , discount : Double , item : Item*)</span> <span class="keyword">extends</span> <span class="title">Item</span></span></div><div class="line"></div><div class="line"><span class="keyword">def</span> price(it : Item) : Double = it <span class="keyword">match</span> {</div><div class="line">  <span class="keyword">case</span> Article(_,p) =&gt; p</div><div class="line">  <span class="keyword">case</span> Bundle(_,disc,its @ _*) =&gt; its.map(price _).sum - disc</div><div class="line">  <span class="keyword">case</span> Multiple(n,it) =&gt; n * price(it)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">val</span> p = price(Multiple(<span class="number">10</span>,Article(<span class="string">"Blackwell Toster"</span>,<span class="number">29.95</span>)))</div><div class="line">println(p)</div></pre></td></tr></table></figure>

<p><strong>14.5</strong><br>我们可以用列表制作只在叶子节点存放值的树。举例来说，列表((3 8) 2 (5))描述的是如下这样一棵树:<br>      *<br>    / | \</p>
<ul>
<li>2  *<br>/  \    |<br>3   8    5<br>不过，有些列表元素是数字，而另一些是列表。在Scala中，你不能拥有异构的列表，因此你必须使用List[Any]。编写一个leafSum函数，计算所有叶子节点中的元素之和，用模式匹配来区分数字和列表。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> leafSum(list:List[Any]):Int={</div><div class="line">  <span class="keyword">var</span> total = <span class="number">0</span></div><div class="line">  list.foreach {</div><div class="line">    lst =&gt;</div><div class="line">      lst <span class="keyword">match</span> {</div><div class="line">        <span class="keyword">case</span> l: List[Any] =&gt; total += leafSum(l)</div><div class="line">        <span class="keyword">case</span> i: Int =&gt; total += i</div><div class="line">      }</div><div class="line">  }</div><div class="line">  total</div><div class="line">}</div><div class="line"><span class="keyword">val</span> l: List[Any] = List(List(<span class="number">3</span>, <span class="number">8</span>), <span class="number">2</span>, List(<span class="number">5</span>))</div><div class="line"></div><div class="line">println(leafSum(l))</div></pre></td></tr></table></figure>

<p><strong>14.6</strong><br>制作这样的树更好的做法是使用样例类。我们不妨从二叉树开始。<br>sealed abstract class BinaryTree<br>case class Leaf(value : Int) extends BinaryTree<br>case class Node(left : BinaryTree,right : BinaryTree) extends BinaryTree<br>编写一个函数计算所有叶子节点中的元素之和。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Leaf</span><span class="params">(value : Int)</span> <span class="keyword">extends</span> <span class="title">BinaryTree</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Node</span><span class="params">(left: BinaryTree, right:BinaryTree)</span> <span class="keyword">extends</span> <span class="title">BinaryTree</span></span></div><div class="line"></div><div class="line"><span class="keyword">def</span> leafSum(tree:BinaryTree):Int={</div><div class="line">  tree <span class="keyword">match</span> {</div><div class="line">    <span class="keyword">case</span> Node(a,b) =&gt; leafSum(a) + leafSum(b)</div><div class="line">    <span class="keyword">case</span> Leaf(v) =&gt; v</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">val</span> r = Node(Leaf(<span class="number">3</span>),Node(Leaf(<span class="number">3</span>),Leaf(<span class="number">9</span>)))</div><div class="line"></div><div class="line">println(leafSum(r))</div></pre></td></tr></table></figure>

<p><strong>13.7</strong><br>扩展前一个练习中的树，使得每个节点可以有任意多的后代，并重新实现leafSum函数。第五题中的树应该能够通过下述代码表示：<br>Node(Node(Leaf(3),Leaf(8)),Leaf(2),Node(Leaf(5)))</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Leaf</span><span class="params">(value: Int)</span> <span class="keyword">extends</span> <span class="title">BinaryTree</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Node</span><span class="params">(tr: BinaryTree*)</span> <span class="keyword">extends</span> <span class="title">BinaryTree</span></span></div><div class="line"></div><div class="line"><span class="keyword">def</span> leafSum(tree:BinaryTree):Int={</div><div class="line">  tree <span class="keyword">match</span> {</div><div class="line">    <span class="keyword">case</span> Node(r @_*) =&gt; r.map(leafSum).sum</div><div class="line">    <span class="keyword">case</span> Leaf(v) =&gt; v</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">val</span> r = Node(Node(Leaf(<span class="number">3</span>), Leaf(<span class="number">8</span>)), Leaf(<span class="number">2</span>), Node(Leaf(<span class="number">5</span>)))</div><div class="line"></div><div class="line">println(leafSum(r))</div></pre></td></tr></table></figure>

<p><strong>13.8</strong><br>扩展前一个练习中的树，使得每个非叶子节点除了后代之外，能够存放一个操作符。然后编写一个eval函数来计算它的值。举例来说：<br>      +<br>    / | \</p>
<ul>
<li>2  -<br>/  \    |<br>3   8    5<br>上面这棵树的值为(3 * 8) + 2 + (-5) = 21</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Leaf</span><span class="params">(value: Int)</span> <span class="keyword">extends</span> <span class="title">BinaryTree</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Node</span><span class="params">(op: Char, leafs: BinaryTree*)</span> <span class="keyword">extends</span> <span class="title">BinaryTree</span></span></div><div class="line"></div><div class="line"><span class="keyword">def</span> eval(tree:BinaryTree):Int= {</div><div class="line">  tree <span class="keyword">match</span> {</div><div class="line">    <span class="keyword">case</span> Node(op, leafs@_*) =&gt; op <span class="keyword">match</span> {</div><div class="line">      <span class="keyword">case</span> '+' =&gt; leafs.map(eval _).sum</div><div class="line">      <span class="keyword">case</span> '-' =&gt; -leafs.map(eval _).sum</div><div class="line">      <span class="keyword">case</span> '*' =&gt; leafs.map(eval _).product</div><div class="line">    }</div><div class="line">    <span class="keyword">case</span> Leaf(x) =&gt; x</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line">  <span class="keyword">val</span> x = Node('+', Node('*', Leaf(<span class="number">3</span>), Leaf(<span class="number">8</span>)), Leaf(<span class="number">2</span>),  Node('-', Leaf(<span class="number">5</span>)))</div><div class="line"></div><div class="line">  println(x)</div><div class="line">  println(eval(x))</div></pre></td></tr></table></figure>

<p><strong>14.9</strong><br>编写一个函数，计算List[Option[Int]]中所有非None值之和。不得使用match语句。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> sum(lst: List[Option[Int]]) = lst.map(_.getOrElse(<span class="number">0</span>)).sum</div><div class="line"></div><div class="line"><span class="keyword">val</span> x = List(Some(<span class="number">1</span>), None, Some(<span class="number">2</span>), None, Some(<span class="number">3</span>))</div><div class="line"></div><div class="line">println(sum(x))</div></pre></td></tr></table></figure>

<p><strong>14.10</strong><br>编写一个函数，将两个类型为Double=&gt;Option[Double]的函数组合在一起，产生另一个同样类型的函数。如果其中一个函数返回None，则组合函数也应返回None。例如：<br>def f(x : Double) = if ( x &gt;= 0) Some(sqrt(x)) else None<br>def g(x : Double) = if ( x != 1) Some( 1 / ( x - 1)) else None<br>val h = compose(f,g)<br>h(2)将得到Some(1)，而h(1)和h(0)将得到None</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> compose(f:Double=&gt;Option[Double],g:Double=&gt;Option[Double])={</div><div class="line">  (x : Double) =&gt;</div><div class="line">    <span class="keyword">if</span> (f(x) == None || g(x) == None) None</div><div class="line">    <span class="keyword">else</span> g(x)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">import</span> scala.math.sqrt</div><div class="line"></div><div class="line"><span class="keyword">def</span> f(x : Double) = <span class="keyword">if</span> ( x &gt;= <span class="number">0</span>) Some(sqrt(x)) <span class="keyword">else</span> None</div><div class="line"><span class="keyword">def</span> g(x : Double) = <span class="keyword">if</span> ( x != <span class="number">1</span>) Some( <span class="number">1</span> / ( x - <span class="number">1</span>)) <span class="keyword">else</span> None</div><div class="line"><span class="keyword">val</span> h = compose(f,g)</div><div class="line"></div><div class="line">println(h(<span class="number">2</span>))</div></pre></td></tr></table></figure>

<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》习题解答-第十三章-集合]]></title>
    <link href="http://vernonzheng.com/2015/02/07/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E9%9B%86%E5%90%88/"/>
    <id>http://vernonzheng.com/2015/02/07/《快学scala》习题解答-第十三章-集合/</id>
    <published>2015-02-07T07:36:42.000Z</published>
    <updated>2015-02-08T07:16:02.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第十三章_集合">第十三章 集合</h2>
<p><strong>13.1</strong><br>编写一个函数，给定字符串，产出一个包含所有字符的下标的映射。举例来说：indexes(“Mississippi”)应返回一个映射，让’M’对应集{0}，’i’对应集{1,4,7,10}，依此类推。使用字符到可变集的映射。另外，你如何保证集是经过排序的？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> mapStrIndex(str:String)={</div><div class="line">  <span class="keyword">var</span> indexMap = <span class="keyword">new</span> HashMap[Char,SortedSet[Int]]()</div><div class="line">  <span class="keyword">var</span> i = <span class="number">0</span></div><div class="line">  str.toCharArray.foreach {</div><div class="line">    c =&gt;</div><div class="line">      indexMap.get(c) <span class="keyword">match</span> {</div><div class="line">        <span class="keyword">case</span> Some(result) =&gt; indexMap(c) = result + i</div><div class="line">        <span class="keyword">case</span> None =&gt; indexMap += (c -&gt; SortedSet {</div><div class="line">          i</div><div class="line">        })</div><div class="line">      }</div><div class="line">      i += <span class="number">1</span></div><div class="line">  }</div><div class="line">  indexMap</div><div class="line"></div><div class="line">}</div><div class="line">println(mapStrIndex(<span class="string">"Mississippi"</span>))</div></pre></td></tr></table></figure>

<p><strong>13.2</strong><br>重复前一个练习，这次用字符到列表的不可变映射。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">mport scala.collection.mutable.{ListBuffer, HashMap}</div><div class="line"><span class="keyword">def</span> mapStrIndex(str:String)={</div><div class="line">  <span class="keyword">var</span> indexMap = <span class="keyword">new</span> HashMap[Char,ListBuffer[Int]]()</div><div class="line">  <span class="keyword">var</span> i = <span class="number">0</span></div><div class="line">  str.toCharArray.foreach {</div><div class="line">    c =&gt;</div><div class="line">      indexMap.get(c) <span class="keyword">match</span> {</div><div class="line">        <span class="keyword">case</span> Some(result) =&gt; result += i</div><div class="line">        <span class="keyword">case</span> None =&gt; indexMap += (c -&gt; ListBuffer {</div><div class="line">          i</div><div class="line">        })</div><div class="line">      }</div><div class="line">      i += <span class="number">1</span></div><div class="line">  }</div><div class="line">  indexMap</div><div class="line"></div><div class="line">}</div><div class="line">println(mapStrIndex(<span class="string">"Mississippi"</span>))</div></pre></td></tr></table></figure>

<p><strong>13.3</strong><br>编写一个函数，从一个整型链表中去除所有的零值。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> removeZero(list:List[Int]):List[Int]={</div><div class="line">  list.filter(_!=<span class="number">0</span>)</div><div class="line">}</div><div class="line">println(removeZero(List(<span class="number">3</span>,<span class="number">25</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>)))</div></pre></td></tr></table></figure>

<p><strong>13.4</strong><br>编写一个函数，接受一个字符串的集合，以及一个从字符串到整数值的映射。返回整型的集合，其值为能和集合中某个字符串相对应的映射的值。举例来说，给定Array(“Tom”,”Fred”,”Harry”)和Map(“Tom”-&gt;3,”Dick”-&gt;4,”Harry”-&gt;5)，返回Array(3,5)。提示：用flatMap将get返回的Option值组合在一起</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> filterMap(array:Array[String],map:Map[String,Int]):Array[Int]={</div><div class="line">  array.flatMap(map.get(_))</div><div class="line">}</div><div class="line">println(filterMap(Array(<span class="string">"Tom"</span>,<span class="string">"Fred"</span>,<span class="string">"Harry"</span>),Map(<span class="string">"Tom"</span>-&gt;<span class="number">3</span>,<span class="string">"Dick"</span>-&gt;<span class="number">4</span>,<span class="string">"Harry"</span>-&gt;<span class="number">5</span>)).mkString(<span class="string">","</span>))</div></pre></td></tr></table></figure>

<p><strong>13.5</strong><br>实现一个函数，作用与mkString相同，使用reduceLeft。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> collection.mutable</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">MktString</span></span>{</div><div class="line">  <span class="keyword">this</span>:mutable.Iterable[String]=&gt;</div><div class="line">  <span class="keyword">def</span> mktString(split:String=<span class="string">""</span>) = <span class="keyword">if</span>( <span class="keyword">this</span> != Nil) <span class="keyword">this</span>.reduceLeft(_ + split + _)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> mutable.HashSet[String] <span class="keyword">with</span> MktString</div><div class="line">test += <span class="string">"1"</span></div><div class="line">test += <span class="string">"2"</span></div><div class="line">test += <span class="string">"3"</span></div><div class="line">println(test.mktString(<span class="string">","</span>))</div></pre></td></tr></table></figure>

<p><strong>13.6</strong><br>给定整型列表lst,(lst :\ List<a href="">Int</a>)(<em> :: </em> )得到什么?(List<a href="">Int</a> /: lst)(<em> :+ </em>)又得到什么？如何修改它们中的一个，以对原列表进行反向排序？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> lst = List(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</div><div class="line">println((lst :\ List[Int]())(_ :: _))</div><div class="line">println((List[Int]() /: lst)(_ :+ _))</div><div class="line">println((List[Int]() /: lst)((a,b) =&gt; b :: a))</div></pre></td></tr></table></figure>

<p><strong>13.7</strong><br>在13.11节中，表达式(prices zip quantities) map { p =&gt; p.<em>1 * p._2}有些不够优雅。我们不能用(prices zip quantities) map { </em> <em> <em>}，因为 </em> </em> _ 是一个带两个参数的函数，而我们需要的是一个带单个类型为元组的参数的函数，Function对象的tupled方法可以将带两个参数的函数改为以元俎为参数的函数。将tupled应用于乘法函数，以使我们可以用它来映射由对偶组成的列表。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> prices = List(<span class="number">5.0</span>,<span class="number">20.0</span>,<span class="number">9.95</span>)</div><div class="line"><span class="keyword">val</span> quantities = List(<span class="number">10</span>,<span class="number">2</span>,<span class="number">1</span>)</div><div class="line">println((prices zip quantities) map { Function.tupled(_ * _) })</div></pre></td></tr></table></figure>

<p><strong>13.8</strong><br>编写一个函数。将Double数组转换成二维数组。传入列数作为参数。举例来说，Array(1,2,3,4,5,6)和三列，返回Array(Array(1,2,3),Array(4,5,6))。用grouped方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> divArr(arr:Array[Double],i:Int)={</div><div class="line">  arr.grouped(i).toArray</div><div class="line">}</div><div class="line"><span class="keyword">val</span> arr = Array(<span class="number">1.0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</div><div class="line">divArr(arr,<span class="number">3</span>).foreach(a =&gt; println(a.mkString(<span class="string">","</span>)))</div></pre></td></tr></table></figure>

<p><strong>13.9</strong><br>Harry Hacker写了一个从命令行接受一系列文件名的程序。对每个文件名，他都启动一个新的线程来读取文件内容并更新一个字母出现频率映射，声明为：<br>val frequencies = new scala.collection.multable.HashMap[Char,Int] with scala.collection.mutable.SynchronizedMap[Char,Int]<br>当读到字母c时，他调用<br>frequencies(c) = frequencies.getOrElse(c,0) + 1<br>为什么这样做得不到正确答案？如果他用如下方式实现呢：<br>import scala.collection.JavaConversions.asScalaConcurrentMap<br>val frequencies:scala.collection.mutable.ConcurrentMap[Char,Int] = new java.util.concurrent.ConcurrentHashMap[Char,Int]</p>
<p>并发问题，并发修改集合不安全。</p>
<p><strong>13.10</strong><br>Harry Hacker把文件读取到字符串中，然后想对字符串的不同部分用并行集合来并发地更新字母出现频率映射。他用了如下代码：<br>val frequencies = new scala.collection.mutable.HashMap[Char,Int]<br>for(c &lt;- str.par) frequencies(c) = frequencies.getOrElse(c,0) + 1<br>为什么说这个想法很糟糕？要真正地并行化这个计算，他应该怎么做呢？（提示：用aggregate） 并行修改共享变量，结果无法估计。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.collection.immutable.HashMap</div><div class="line"></div><div class="line"><span class="keyword">val</span> str = <span class="string">"abdcsdcd"</span></div><div class="line"><span class="keyword">val</span> frequencies = str.par.aggregate(HashMap[Char,Int]())(</div><div class="line">  {</div><div class="line">    (a,b) =&gt;</div><div class="line">      a + (b -&gt; (a.getOrElse(b,<span class="number">0</span>) + <span class="number">1</span>))</div><div class="line">  }</div><div class="line">  ,</div><div class="line">  {</div><div class="line">    (map1,map2) =&gt;</div><div class="line">      (map1.keySet ++ map2.keySet).foldLeft( HashMap[Char,Int]() ) {</div><div class="line">        (result,k) =&gt;</div><div class="line">          result + ( k -&gt; ( map1.getOrElse(k,<span class="number">0</span> ) + map2.getOrElse(k,<span class="number">0</span>) ) )</div><div class="line">      }</div><div class="line">  }</div><div class="line">)</div></pre></td></tr></table></figure>

<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》习题解答-第十二章-高阶函数]]></title>
    <link href="http://vernonzheng.com/2015/02/04/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    <id>http://vernonzheng.com/2015/02/04/《快学scala》习题解答-第十二章-高阶函数/</id>
    <published>2015-02-04T14:11:42.000Z</published>
    <updated>2015-02-08T07:15:47.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第十二章_高阶函数">第十二章 高阶函数</h2>
<p><strong>12.1</strong><br>编写函数values(fun:(Int)=&gt;Int,low:Int,high:Int),该函数输出一个集合，对应给定区间内给定函数的输入和输出。比如，values(x=&gt;x*x,-5,5)应该产出一个对偶的集合(-5,25),(-4,16),(-3,9),…,(5,25)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> values(fun:(Int)=&gt;Int,low:Int,high:Int) ={</div><div class="line">  <span class="keyword">var</span> array = List[(Int,Int)]()</div><div class="line">  low to high foreach {</div><div class="line">    x =&gt;</div><div class="line">      array = (x, fun(x)) :: array</div><div class="line">  }</div><div class="line">  array</div><div class="line">}</div><div class="line">println(values(x =&gt; x * x, -<span class="number">5</span>, <span class="number">5</span>).mkString)</div></pre></td></tr></table></figure>

<p><strong>12.2</strong><br>如何用reduceLeft得到数组中的最大元素?</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> arr = Array(<span class="number">1</span>,<span class="number">333</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">32</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">2</span>)</div><div class="line">print(arr.reduceLeft((l,r)=&gt;<span class="keyword">if</span>(l&gt;=r) l <span class="keyword">else</span> r))</div></pre></td></tr></table></figure>

<p><strong>12.3</strong><br>用to和reduceLeft实现阶乘函数,不得使用循环或递归 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> factorial(n:Int): Unit ={</div><div class="line">  <span class="number">1</span> to n reduceLeft(_ * _)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>12.4</strong><br>前一个实现需要处理一个特殊情况，即n&lt;1的情况。展示如何用foldLeft来避免这个需要。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> factorial(n:Int) = (<span class="number">1</span> to n).foldLeft(<span class="number">1</span>)(_ * _)</div><div class="line"></div><div class="line">factorial(-<span class="number">3</span>)</div><div class="line">factorial(<span class="number">3</span>)</div></pre></td></tr></table></figure>

<p><strong>12.5</strong><br>编写函数largest(fun:(Int)=&gt;Int,inputs:Seq[Int]),输出在给定输入序列中给定函数的最大值。举例来说，largest(x=&gt;10<em>x-x</em>x,1 to 10)应该返回25.不得使用循环或递归 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> largest1(fun:(Int)=&gt;Int, inputs:Seq[Int]) = inputs.foldLeft(<span class="number">1</span>)((a,b)=&gt; <span class="keyword">if</span>(fun(b)&gt;a) fun(b) <span class="keyword">else</span> a)</div><div class="line"></div><div class="line"><span class="keyword">def</span> largest2(fun:(Int)=&gt;Int, inputs:Seq[Int]) = inputs.map(fun(_)).max</div><div class="line"></div><div class="line">println(largest1(x =&gt; <span class="number">10</span> * x - x * x, <span class="number">1</span> to <span class="number">10</span>))</div><div class="line">println(largest2(x =&gt; <span class="number">10</span> * x - x * x, <span class="number">1</span> to <span class="number">10</span>))</div></pre></td></tr></table></figure>

<p><strong>12.6</strong><br>修改前一个函数，返回最大的输出对应的输入。举例来说,largestAt(fun:(Int)=&gt;Int,inputs:Seq[Int])应该返回5。不得使用循环或递归 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> largestAt1(fun:(Int)=&gt;Int, inputs:Seq[Int]) = inputs.reduce((a,b)=&gt; <span class="keyword">if</span>(fun(b)&gt;fun(a)) b <span class="keyword">else</span> a)</div><div class="line"></div><div class="line"><span class="keyword">def</span> largestAt2(fun: (Int) =&gt; Int, inputs: Seq[Int]) = inputs.map(x =&gt; (x, fun(x))).reduceLeft((x,y) =&gt; <span class="keyword">if</span> (x._2 &gt; y._2) x <span class="keyword">else</span> y)._1</div><div class="line"></div><div class="line">println(largestAt1(x =&gt; <span class="number">10</span> * x - x * x, <span class="number">1</span> to <span class="number">10</span>))</div><div class="line">println(largestAt2(x =&gt; <span class="number">10</span> * x - x * x, <span class="number">1</span> to <span class="number">10</span>))</div></pre></td></tr></table></figure>

<p><strong>12.7</strong><br>要得到一个序列的对偶很容易，比如:<br>val pairs = (1 to 10) zip (11 to 20)<br>假定你想要对这个序列做某中操作—比如，给对偶中的值求和，但是你不能直接使用:</p>
<p>pairs.map(<em> + </em>)<br>函数<em> + </em> 接受两个Int作为参数，而不是(Int,Int)对偶。编写函数adjustToPair,该函数接受一个类型为(Int,Int)=&gt;Int的函数作为参数，并返回一个等效的, 可以以对偶作为参数的函数。举例来说就是:adjustToPair(<em> * </em>)((6,7))应得到42。然后用这个函数通过map计算出各个对偶的元素之和</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> ajustToPair(fun: (Int, Int) =&gt; Int) = (x: (Int, Int)) =&gt; fun(x._1, x._2)</div><div class="line"></div><div class="line"><span class="keyword">val</span> x = ajustToPair(_ * _)((<span class="number">6</span>, <span class="number">7</span>))</div><div class="line">println(x)</div><div class="line"></div><div class="line"><span class="keyword">val</span> pairs = (<span class="number">1</span> to <span class="number">10</span>) zip (<span class="number">11</span> to <span class="number">20</span>)</div><div class="line">println(pairs)</div><div class="line"></div><div class="line"><span class="keyword">val</span> y = pairs.map(ajustToPair(_ + _))</div><div class="line">println(y)</div></pre></td></tr></table></figure>

<p><strong>12.8</strong><br>在12.8节中，你看到了用于两组字符串数组的corresponds方法。做出一个对该方法的调用，让它帮我们判断某个字符串数组里的所有元素的长度是否和某个给定的整数数组相对应 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = Array(<span class="string">"asd"</span>,<span class="string">"df"</span>,<span class="string">"abcd"</span>)</div><div class="line"><span class="keyword">val</span> b = Array(<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>)</div><div class="line"><span class="keyword">val</span> c = Array(<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)</div><div class="line"></div><div class="line">println(a.corresponds(b)(_.length == _))</div><div class="line">println(a.corresponds(c)(_.length == _))</div></pre></td></tr></table></figure>

<p><strong>12.9</strong><br>不使用柯里化实现corresponds。然后尝试从前一个练习的代码来调用。你遇到了什么问题？</p>
<p>没有柯里化则不能使用前一个练习里的代码方式来调用</p>
<p><strong>12.10</strong><br>实现一个unless控制抽象，工作机制类似if,但条件是反过来的。第一个参数需要是换名调用的参数吗？你需要柯里化吗？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> unless(condition: =&gt; Boolean)(block: =&gt; Unit) { <span class="keyword">if</span> (!condition) { block } }</div><div class="line"></div><div class="line">unless (<span class="number">0</span> &gt; <span class="number">1</span>) { println(<span class="string">"Unless!"</span>) }</div></pre></td></tr></table></figure>

<p>需要换名和柯里化</p>
<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》习题解答-第十一章-操作符]]></title>
    <link href="http://vernonzheng.com/2015/02/03/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://vernonzheng.com/2015/02/03/《快学scala》习题解答-第十一章-操作符/</id>
    <published>2015-02-03T10:40:42.000Z</published>
    <updated>2015-02-08T07:15:29.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第十一章_操作符">第十一章 操作符</h2>
<p><strong>11.1</strong><br>根据优先级规则,3 + 4 -&gt; 5和3 -&gt; 4 + 5是如何被求值的？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="number">3</span>+<span class="number">4</span>-&gt;<span class="number">5</span></div><div class="line">res0: (Int, Int) = (<span class="number">7</span>,<span class="number">5</span>)</div><div class="line"></div><div class="line">scala&gt; <span class="number">3</span>-&gt;<span class="number">4</span>+<span class="number">5</span></div><div class="line">&lt;console&gt;:<span class="number">8</span>: error: <span class="keyword">type</span> mismatch;</div><div class="line"> found   : Int(<span class="number">5</span>)</div><div class="line"> required: String</div><div class="line">              <span class="number">3</span>-&gt;<span class="number">4</span>+<span class="number">5</span></div><div class="line">                   ^</div></pre></td></tr></table></figure>

<p><strong>11.2</strong><br>BigInt类有一个pow方法,但没有用操作符字符。Scala类库的设计者为什么没有选用**(像Fortran那样)或者^(像Pascal那样)作为乘方操作符呢？</p>
<p>Scala中的操作符就是方法，其优先级是根据首字母来判断的，优先级如下<br>最高优先级:除以下字符外的操作符字符</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">* / % </div><div class="line">+ - </div><div class="line">: </div><div class="line">= ! </div><div class="line">&lt; &gt; </div><div class="line">& </div><div class="line">ˆ </div><div class="line">| </div><div class="line">非操作符</div><div class="line">最低优先级:赋值操作符</div></pre></td></tr></table></figure>

<p>一般乘方的操作符是优于乘法操作的，如果使用<em>*作为乘方的话，那么其优先级则与</em>相同，而如果使用^的话，则优先级低于*操作。优先级都是有问题的。故没有使用这两种操作符</p>
<p><strong>11.3</strong><br>实现Fraction类，支持+<em>/操作。支持约分，例如将15/-6变为-5/2。除以最大公约数,像这样:<br>class Fraction(n:Int,d:Int){<br>    private val num:Int = if(d==0) 1 else n </em> sign(d)/gcd(n,d);<br>    private val den:Int = if(d==0) 0 else d * sign(d)/gcd(n,d);<br>    override def toString = num + “/“ + den<br>    def sign(a:Int) = if(a &gt; 0) 1 else if (a &lt; 0) -1 else 0<br>    def gcd(a:Int,b:Int):Int = if(b==0) abs(a) else gcd(b,a%b)<br>    …<br>}</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">mport scala.math.abs</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fraction</span><span class="params">(n: Int, d: Int)</span> </span>{</div><div class="line">  <span class="keyword">private</span> <span class="keyword">val</span> num: Int = <span class="keyword">if</span> (d == <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> n * sign(d) / gcd(n, d);</div><div class="line">  <span class="keyword">private</span> <span class="keyword">val</span> den: Int = <span class="keyword">if</span> (d == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> d * sign(d) / gcd(n, d);</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> toString = num + <span class="string">"/"</span> + den</div><div class="line"></div><div class="line">  <span class="keyword">def</span> sign(a: Int) = <span class="keyword">if</span> (a &gt; <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="keyword">if</span> (a &lt; <span class="number">0</span>) -<span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></div><div class="line"></div><div class="line">  <span class="keyword">def</span> gcd(a: Int, b: Int): Int = <span class="keyword">if</span> (b == <span class="number">0</span>) abs(a) <span class="keyword">else</span> gcd(b, a % b)</div><div class="line"></div><div class="line">  <span class="keyword">def</span> +(other:Fraction):Fraction={</div><div class="line">    newFraction((<span class="keyword">this</span>.num * other.den) + (other.num * <span class="keyword">this</span>.den),<span class="keyword">this</span>.den * other.den)</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> -(other:Fraction):Fraction={</div><div class="line">    newFraction((<span class="keyword">this</span>.num * other.den) - (other.num * <span class="keyword">this</span>.den),<span class="keyword">this</span>.den * other.den)</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> *(other:Fraction):Fraction={</div><div class="line">    newFraction(<span class="keyword">this</span>.num * other.num,<span class="keyword">this</span>.den * other.den)</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> /(other:Fraction):Fraction={</div><div class="line">    newFraction(<span class="keyword">this</span>.num * other.den,<span class="keyword">this</span>.den * other.num)</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">def</span> newFraction(a:Int,b:Int):Fraction={</div><div class="line">    <span class="keyword">val</span> x:Int = <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> a * sign(b) / gcd(a, b)</div><div class="line">    <span class="keyword">val</span> y:Int = <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> b * sign(b) / gcd(a, b)</div><div class="line">    <span class="keyword">new</span> Fraction(x,y)</div><div class="line">  }</div><div class="line">}</div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>{</div><div class="line">  <span class="keyword">val</span> f = <span class="keyword">new</span> Fraction(<span class="number">15</span>,-<span class="number">6</span>)</div><div class="line">  <span class="keyword">val</span> p = <span class="keyword">new</span> Fraction(<span class="number">20</span>,<span class="number">60</span>)</div><div class="line">  println(f)</div><div class="line">  println(p)</div><div class="line">  println(f + p)</div><div class="line">  println(f - p)</div><div class="line">  println(f * p)</div><div class="line">  println(f / p)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>11.4</strong><br>实现一个Money类,加入美元和美分字段。提供+,-操作符以及比较操作符==和&lt;。举例来说，Money(1,75)+Money(0,50)==Money(2,25)应为true。你应该同时提供*和/操作符吗？为什么？</p>
<p>不需要提供，金额的乘除没有实际意义。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Money</span><span class="params">(dollar:Int,cent:Int)</span></span>{</div><div class="line">  <span class="keyword">def</span> + (other:Money):Money = {</div><div class="line">    <span class="keyword">val</span> (a,b) = (<span class="keyword">this</span>.cent + other.cent) % <span class="number">100</span></div><div class="line">    <span class="keyword">new</span> Money(<span class="keyword">this</span>.dollar + other.dollar + a,b)</div><div class="line">  }</div><div class="line">  <span class="keyword">def</span> -(other:Money):Money={</div><div class="line">    <span class="keyword">val</span> (d,c) = (<span class="keyword">this</span>.toCent() - other.toCent()) % <span class="number">100</span></div><div class="line">    <span class="keyword">new</span> Money(d,c)</div><div class="line">  }</div><div class="line">  <span class="keyword">def</span> ==(other:Money):Boolean = <span class="keyword">this</span>.dollar == other.dollar && <span class="keyword">this</span>.cent == other.cent</div><div class="line"></div><div class="line">  <span class="keyword">def</span> &lt;(other:Money):Boolean = <span class="keyword">this</span>.dollar &lt; other.dollar || (<span class="keyword">this</span>.dollar == other.dollar && <span class="keyword">this</span>.cent &lt; other.cent)</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> toString = <span class="string">"dollar = "</span> + dollar + <span class="string">" cent = "</span> + cent</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">def</span> toCent()={</div><div class="line">    <span class="keyword">this</span>.dollar * <span class="number">100</span> + <span class="keyword">this</span>.cent</div><div class="line">  }</div><div class="line">}</div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Money</span></span>{</div><div class="line">  <span class="keyword">def</span> apply(dollar:Int, cent:Int): Money ={</div><div class="line">    <span class="keyword">new</span> Money(dollar,cent)</div><div class="line">  }</div><div class="line">  <span class="keyword">def</span> main(args:Array[String]){</div><div class="line"></div><div class="line">    <span class="keyword">val</span> m1 = Money(<span class="number">1</span>,<span class="number">200</span>)</div><div class="line">    <span class="keyword">val</span> m2 = Money(<span class="number">2</span>,<span class="number">2</span>)</div><div class="line">    println(m1 + m2)</div><div class="line">    println(m1 - m2)</div><div class="line">    println(m1 == m2)</div><div class="line">    println(m1 &lt; m2)</div><div class="line">    println(Money(<span class="number">1</span>,<span class="number">75</span>)+Money(<span class="number">0</span>,<span class="number">50</span>))</div><div class="line">    println(Money(<span class="number">1</span>,<span class="number">75</span>)+Money(<span class="number">0</span>,<span class="number">50</span>)==Money(<span class="number">2</span>,<span class="number">25</span>))</div><div class="line"></div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>11.5</strong><br>提供操作符用于构造HTML表格。例如:Table() | “Java” | “Scala” || “Gosling” | “Odersky” || “JVM” | “JVM,.NET”应产出:<table><tr><td>Java</td></tr><td>Scala</td><tr><td>Gosling…</td></tr></table></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Table</span></span>{</div><div class="line"></div><div class="line">  <span class="keyword">var</span> s:String = <span class="string">""</span></div><div class="line"></div><div class="line">  <span class="keyword">def</span> |(str:String):Table={</div><div class="line">    <span class="keyword">val</span> t = Table()</div><div class="line">    t.s = <span class="keyword">this</span>.s + <span class="string">"&lt;td&gt;"</span> + str + <span class="string">"&lt;/td&gt;"</span></div><div class="line">    t</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> ||(str:String):Table={</div><div class="line">    <span class="keyword">val</span> t = Table()</div><div class="line">    t.s = <span class="keyword">this</span>.s + <span class="string">"&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;"</span> + str + <span class="string">"&lt;/td&gt;"</span></div><div class="line">    t</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> toString():String={</div><div class="line">    <span class="string">"&lt;table&gt;&lt;tr&gt;"</span> + <span class="keyword">this</span>.s + <span class="string">"&lt;/tr&gt;&lt;/table&gt;"</span></div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Table</span></span>{</div><div class="line"></div><div class="line">  <span class="keyword">def</span> apply():Table={</div><div class="line">    <span class="keyword">new</span> Table()</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> main(args: Array[String]) {</div><div class="line">    println(Table() | <span class="string">"Java"</span> | <span class="string">"Scala"</span> || <span class="string">"Gosling"</span> | <span class="string">"Odersky"</span> || <span class="string">"JVM"</span> | <span class="string">"JVM,.NET"</span>)</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>11.6</strong><br>提供一个ASCIIArt类，其对象包含类似这样的图形:<br> /_/\<br>( ‘ ‘ )<br>(  -  )<br> | | |<br>(<strong>|</strong>)<br>提供将两个ASCIIArt图形横向或纵向结合的操作符。选用适当优先级的操作符命名。纵向结合的实例<br> /_/\     ——-<br>( ‘ ‘ )  / Hello \<br>(  -  ) &lt;  Scala |<br> | | |   \ Coder /<br>(<strong>|</strong>)    ——-</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> collection.mutable.ArrayBuffer</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ASCIIArt</span><span class="params">(str:String)</span></span>{</div><div class="line">  <span class="keyword">val</span> arr:ArrayBuffer[ArrayBuffer[String]] = <span class="keyword">new</span> ArrayBuffer[ArrayBuffer[String]]()</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (str != <span class="keyword">null</span> && !str.trim.eq(<span class="string">""</span>)){</div><div class="line">    str.split(<span class="string">"[\r\n]+"</span>).foreach{</div><div class="line">      line =&gt;</div><div class="line">        <span class="keyword">val</span> s = <span class="keyword">new</span> ArrayBuffer[String]()</div><div class="line">        s += line</div><div class="line">        arr += s</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> <span class="keyword">this</span>(){</div><div class="line">    <span class="keyword">this</span>(<span class="string">""</span>)</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> +(other:ASCIIArt):ASCIIArt={</div><div class="line">    <span class="keyword">val</span> art = <span class="keyword">new</span> ASCIIArt()</div><div class="line">    <span class="keyword">val</span> length = <span class="keyword">if</span> (<span class="keyword">this</span>.arr.length &gt;= other.arr.length) <span class="keyword">this</span>.arr.length <span class="keyword">else</span> other.arr.length</div><div class="line">    <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until length){</div><div class="line">      <span class="keyword">val</span> s = <span class="keyword">new</span> ArrayBuffer[String]()</div><div class="line">      <span class="keyword">val</span> thisArr:ArrayBuffer[String] = <span class="keyword">if</span> (i &lt; <span class="keyword">this</span>.arr.length) <span class="keyword">this</span>.arr(i) <span class="keyword">else</span> <span class="keyword">new</span> ArrayBuffer[String]()</div><div class="line">      <span class="keyword">val</span> otherArr:ArrayBuffer[String] = <span class="keyword">if</span> (i &lt; other.arr.length) other.arr(i) <span class="keyword">else</span> <span class="keyword">new</span> ArrayBuffer[String]()</div><div class="line">      thisArr.foreach(s += _)</div><div class="line">      otherArr.foreach(s += _)</div><div class="line">      art.arr += s</div><div class="line">    }</div><div class="line">    art</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> *(other:ASCIIArt):ASCIIArt={</div><div class="line">    <span class="keyword">val</span> art = <span class="keyword">new</span> ASCIIArt()</div><div class="line">    <span class="keyword">this</span>.arr.foreach(art.arr += _)</div><div class="line">    other.arr.foreach(art.arr += _)</div><div class="line">    art</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> toString()={</div><div class="line">    <span class="keyword">var</span> ss:String = <span class="string">""</span></div><div class="line">    arr.foreach{</div><div class="line">      ss += _.mkString(<span class="string">" "</span>) + <span class="string">"\n"</span></div><div class="line">    }</div><div class="line">    ss</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>{</div><div class="line">  <span class="keyword">val</span> a = <span class="keyword">new</span> ASCIIArt(<span class="string">""" /\_/\</span></div><div class="line">                         |( ' ' )</div><div class="line">                         |(  -  )</div><div class="line">                         | | | |</div><div class="line">                         |(__|__)</div><div class="line">                         |""".stripMargin)</div><div class="line">  <span class="keyword">val</span> b = <span class="keyword">new</span> ASCIIArt( <span class="string">"""    -----</span></div><div class="line">                          |  / Hello \</div><div class="line">                          | &lt;  Scala |</div><div class="line">                          |  \ Coder /</div><div class="line">                          |    -----</div><div class="line">                          |""".stripMargin)</div><div class="line">  println(a + b * b)</div><div class="line">  println((a + b) * b)</div><div class="line">  println(a * b)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>11.7</strong><br>实现一个BigSequence类,将64个bit的序列打包在一个Long值中。提供apply和update操作来获取和设置某个具体的bit</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitSequence</span><span class="params">(private var value: Long = 0)</span> </span>{</div><div class="line"></div><div class="line">  implicit <span class="keyword">def</span> bool2int(b: Boolean) = <span class="keyword">if</span> (b) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></div><div class="line"></div><div class="line">  <span class="keyword">def</span> update(bit: Int, state: Int) = value |= (state & <span class="number">1</span>L) &lt;&lt; bit % <span class="number">64</span></div><div class="line">  <span class="keyword">def</span> apply(bit: Int): Int = <span class="keyword">if</span> ((value & <span class="number">1</span>L &lt;&lt; bit % <span class="number">64</span>) &gt; <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> toString = <span class="string">"%64s"</span>.format(value.toBinaryString).replace(<span class="string">" "</span>, <span class="string">"0"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">val</span> x = <span class="keyword">new</span> BitSequence()</div><div class="line"></div><div class="line">x(<span class="number">5</span>) = <span class="number">1</span></div><div class="line">x(<span class="number">63</span>) = <span class="number">1</span></div><div class="line">x(<span class="number">64</span>) = <span class="number">1</span></div><div class="line"></div><div class="line">println(x(<span class="number">5</span>))</div><div class="line"></div><div class="line">println(x)</div></pre></td></tr></table></figure>

<p><strong>11.8</strong><br>提供一个Matrix类—你可以选择需要的是一个2<em>2的矩阵，任意大小的正方形矩阵，或m</em>n的矩阵。支持+和<em>操作。</em>操作应同样适用于单值，例如mat*2。单个元素可以通过mat(row,col)得到</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span><span class="params">(val m: Int, val n: Int=m)</span> </span>{</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">val</span> value = Array.ofDim[Double](m, n)</div><div class="line"></div><div class="line">	<span class="keyword">def</span> update(x: Int, y: Int, v: Double) = value(x)(y) = v</div><div class="line">	<span class="keyword">def</span> apply(x: Int, y: Int) = value(x)(y)</div><div class="line"></div><div class="line">	<span class="keyword">def</span> +(other: Matrix) = {</div><div class="line">		require (n == other.n)</div><div class="line">		require (m == other.m)</div><div class="line"></div><div class="line">		<span class="keyword">var</span> res = <span class="keyword">new</span> Matrix(m, n)</div><div class="line">		<span class="keyword">for</span>(i &lt;- <span class="number">0</span> until m; j &lt;- <span class="number">0</span> until n) {</div><div class="line">			res(i, j) = <span class="keyword">this</span>.value(i)(j) + other.value(i)(j)</div><div class="line">		}</div><div class="line">		res </div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">def</span> -(other: Matrix) = <span class="keyword">this</span> + other * -<span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">	<span class="keyword">def</span> *(factor: Double) = {</div><div class="line">		<span class="keyword">var</span> res = <span class="keyword">new</span> Matrix(m, n)</div><div class="line">		<span class="keyword">for</span>(i &lt;- <span class="number">0</span> until m; j &lt;- <span class="number">0</span> until n) {</div><div class="line">			res(i, j) = <span class="keyword">this</span>.value(i)(j) * factor</div><div class="line">		}</div><div class="line">		res </div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">def</span> prod(other: Matrix, i: Int, j: Int) = {</div><div class="line">		(<span class="keyword">for</span> (k &lt;- <span class="number">0</span> until n) <span class="keyword">yield</span> value(i)(k) * other.value(j)(k)).sum</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">def</span> *(other: Matrix) = {</div><div class="line">		require(n == other.m)</div><div class="line">		<span class="keyword">var</span> res = <span class="keyword">new</span> Matrix(m, n)</div><div class="line">		<span class="keyword">for</span>(i &lt;- <span class="number">0</span> until m; j &lt;- <span class="number">0</span> until n) {</div><div class="line">			res(i, j) = prod(other, i, j)</div><div class="line">		}</div><div class="line">		res </div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">override</span> <span class="keyword">def</span> toString = value.map(_.mkString(<span class="string">" "</span>)).mkString(<span class="string">"\n"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">val</span> x = <span class="keyword">new</span> Matrix(<span class="number">2</span>, <span class="number">2</span>)</div><div class="line">x(<span class="number">0</span>, <span class="number">0</span>) = <span class="number">1</span></div><div class="line">x(<span class="number">0</span>, <span class="number">1</span>) = <span class="number">2</span></div><div class="line">x(<span class="number">1</span>, <span class="number">0</span>) = <span class="number">3</span></div><div class="line">x(<span class="number">1</span>, <span class="number">1</span>) = <span class="number">4</span></div><div class="line"></div><div class="line">println(x)</div><div class="line">println()</div><div class="line">println(x * <span class="number">2</span>)</div><div class="line">println()</div><div class="line">println(x * <span class="number">2</span> - x)</div><div class="line">println()</div><div class="line"></div><div class="line">println((x * <span class="number">2</span>) * (x * <span class="number">3</span>))</div></pre></td></tr></table></figure>

<p><strong>11.9</strong><br>为RichFile类定义unapply操作，提取文件路径，名称和扩展名。举例来说，文件/home/cay/readme.txt的路径为/home/cay,名称为readme,扩展名为txt</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RichFile</span><span class="params">(val path:String)</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">File</span><span class="params">(path)</span></span>{</div><div class="line"></div><div class="line">}</div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">RichFile</span></span>{</div><div class="line">  <span class="keyword">def</span> unapply(richFile:RichFile): Unit ={</div><div class="line">    <span class="keyword">val</span> path = richFile.path</div><div class="line">    <span class="keyword">val</span> pos = path.lastIndexOf(<span class="string">"/"</span>)</div><div class="line">    <span class="keyword">if</span> (pos == -<span class="number">1</span>) None <span class="keyword">else</span> Some((path.substring(<span class="number">0</span>, pos), path.substring(pos + <span class="number">1</span>)))</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>11.10</strong><br>为RichFile类定义一个unapplySeq，提取所有路径段。举例来说，对于/home/cay/readme.txt，你应该产出三个路径段的序列:home,cay和readme.txt</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">RichFile</span> </span>{</div><div class="line">  <span class="keyword">def</span> unapplySeq(s: String): Option[Seq[String]] = {</div><div class="line">    <span class="keyword">if</span> (s.trim == <span class="string">""</span>) None <span class="keyword">else</span> Some(s.trim.split(<span class="string">"/"</span>))</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》习题解答-第十章-特质]]></title>
    <link href="http://vernonzheng.com/2015/02/02/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E7%89%B9%E8%B4%A8/"/>
    <id>http://vernonzheng.com/2015/02/02/《快学scala》习题解答-第十章-特质/</id>
    <published>2015-02-01T16:30:42.000Z</published>
    <updated>2015-02-08T07:15:13.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第十章_特质">第十章 特质</h2>
<p><strong>10.1</strong><br>java.awt.Rectangle类有两个很有用的方法translate和grow,但可惜的是像java.awt.geom.Ellipse2D这样的类没有。在Scala中，你可以解决掉这个问题。定义一个RenctangleLike特质,加入具体的translate和grow方法。提供任何你需要用来实现的抽象方法,以便你可以像如下代码这样混入该特质:<br>val egg = new java.awt.geom.Ellipse2D.Double(5,10,20,30) with RectangleLike<br>egg.translate(10,-10)<br>egg.grow(10,20)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.awt.geom.Ellipse2D</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">RectangleLike</span></span>{</div><div class="line">  <span class="keyword">this</span>:Ellipse2D.Double=&gt;</div><div class="line">  <span class="keyword">def</span> translate(x:Double,y:Double){</div><div class="line">    <span class="keyword">this</span>.x = x</div><div class="line">    <span class="keyword">this</span>.y = y</div><div class="line">  }</div><div class="line">  <span class="keyword">def</span> grow(x:Double,y:Double){</div><div class="line">    <span class="keyword">this</span>.x += x</div><div class="line">    <span class="keyword">this</span>.y += y</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>{</div><div class="line">  <span class="keyword">val</span> egg = <span class="keyword">new</span> Ellipse2D.Double(<span class="number">5</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>) <span class="keyword">with</span> RectangleLike</div><div class="line">  println(<span class="string">"x = "</span> + egg.getX + <span class="string">" y = "</span> + egg.getY)</div><div class="line">  egg.translate(<span class="number">10</span>,-<span class="number">10</span>)</div><div class="line">  println(<span class="string">"x = "</span> + egg.getX + <span class="string">" y = "</span> + egg.getY)</div><div class="line">  egg.grow(<span class="number">10</span>,<span class="number">20</span>)</div><div class="line">  println(<span class="string">"x = "</span> + egg.getX + <span class="string">" y = "</span> + egg.getY)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>10.2</strong><br>通过把scala.math.Ordered[Point]混入java.awt.Point的方式，定义OrderedPoint类。按辞典编辑方式排序，也就是说，如果x&lt;x’或者x=x’且y&lt;y’则(x,y)&lt;(x’,y’)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.awt.Point</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderedPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> <span class="keyword">with</span> <span class="title">Ordered</span>[<span class="title">Point</span>]</span>{</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> compare(that: Point): Int = {</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.x &lt;= that.x && <span class="keyword">this</span>.y &lt; that.y) -<span class="number">1</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.x == that.x && <span class="keyword">this</span>.y == that.y) <span class="number">0</span></div><div class="line">    <span class="keyword">else</span> <span class="number">1</span></div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>10.3</strong><br>查看BitSet类,将它的所有超类和特质绘制成一张图。忽略类型参数([…]中的所有内容)。然后给出该特质的线性化规格说明 </p>
<p>略</p>
<p><strong>10.4</strong><br>提供一个CryptoLogger类，将日志消息以凯撒密码加密。缺省情况下密匙为3，不过使用者也可以重写它。提供缺省密匙和-3作为密匙是的使用示例 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Logger</span></span>{</div><div class="line">  <span class="keyword">def</span> log(str:String,key:Int = <span class="number">3</span>):String</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CryptoLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span></span>{</div><div class="line"></div><div class="line">  <span class="keyword">def</span> log(str: String, key:Int): String = {</div><div class="line">    <span class="keyword">for</span> ( i &lt;- str) <span class="keyword">yield</span> <span class="keyword">if</span> (key &gt;= <span class="number">0</span>) (<span class="number">97</span> + ((i - <span class="number">97</span> + key)%<span class="number">26</span>)).toChar <span class="keyword">else</span> (<span class="number">97</span> + ((i - <span class="number">97</span> + <span class="number">26</span> + key)%<span class="number">26</span>)).toChar</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>{</div><div class="line">    <span class="keyword">val</span> plain = <span class="string">"chenzhen"</span>;</div><div class="line">    println(<span class="string">"明文为："</span> + plain);</div><div class="line">    println(<span class="string">"加密后为："</span> + <span class="keyword">new</span> CryptoLogger().log(plain));</div><div class="line">    println(<span class="string">"加密后为："</span> + <span class="keyword">new</span> CryptoLogger().log(plain,-<span class="number">3</span>));</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>10.5</strong><br>JavaBean规范里有一种提法叫做属性变更监听器(property change listener)，这是bean用来通知其属性变更的标准方式。PropertyChangeSupport类对于任何想要支持属性变更通知其属性变更监听器的bean而言是个便捷的超类。但可惜已有其他超类的类—比如JComponent—必须重新实现相应的方法。将PropertyChangeSupport重新实现为一个特质,然后将它混入到java.awt.Point类中 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.awt.Point</div><div class="line"><span class="keyword">import</span> java.beans.PropertyChangeSupport</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PropertyChange</span> <span class="keyword">extends</span> <span class="title">PropertyChangeSupport</span></span></div><div class="line"></div><div class="line"><span class="keyword">val</span> p = <span class="keyword">new</span> Point() <span class="keyword">with</span> PropertyChange</div></pre></td></tr></table></figure>

<p><strong>10.6</strong><br>在Java AWT类库中,我们有一个Container类，一个可以用于各种组件的Component子类。举例来说,Button是一个Component,但Panel是Container。这是一个运转中的组合模式。Swing有JComponent和JContainer,但如果你仔细看的话，你会发现一些奇怪的细节。尽管把其他组件添加到比如JButton中毫无意义,JComponent依然扩展自Container。Swing的设计者们理想情况下应该会更倾向于图10-4中的设计。但在Java中那是不可能的。请解释这是为什么？Scala中如何用特质来设计出这样的效果? </p>
<p>Java只能单继承。</p>
<p><strong>10.7</strong><br>市面上有不下数十种关于Scala特质的教程,用的都是些”在叫的狗”啦，”讲哲学的青蛙”啦之类的傻乎乎的例子。阅读和理解这些机巧的继承层级很乏味且对于理解问题没什么帮助,但自己设计一套继承层级就不同了,会很有启发。做一个你自己的关于特质的继承层级，要求体现出叠加在一起的特质,具体的和抽象的方法，以及具体的和抽象的字段 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Fly</span></span>{</div><div class="line">  <span class="keyword">def</span> fly(){</div><div class="line">    println(<span class="string">"flying"</span>)</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> flywithnowing()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Walk</span></span>{</div><div class="line">  <span class="keyword">def</span> walk(){</div><div class="line">    println(<span class="string">"walk"</span>)</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>{</div><div class="line">  <span class="keyword">var</span> name:String = _</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlueBird</span> <span class="keyword">extends</span> <span class="title">Bird</span> <span class="keyword">with</span> <span class="title">Fly</span> <span class="keyword">with</span> <span class="title">Walk</span></span>{</div><div class="line">  <span class="keyword">def</span> flywithnowing() {</div><div class="line">    println(<span class="string">"BlueBird flywithnowing"</span>)</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>{</div><div class="line">  <span class="keyword">val</span> b = <span class="keyword">new</span> BlueBird()</div><div class="line">  b.walk()</div><div class="line">  b.flywithnowing()</div><div class="line">  b.fly()</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>10.8</strong><br>在java.io类库中，你可以通过BufferedInputStream修饰器来给输入流增加缓冲机制。用特质来重新实现缓冲。简单起见，重写read方法 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.{InputStream, FileInputStream}</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Buffering</span> </span>{</div><div class="line">	<span class="keyword">this</span>: InputStream =&gt;</div><div class="line"></div><div class="line">	<span class="keyword">val</span> BUF_SIZE: Int = <span class="number">5</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">val</span> buf = <span class="keyword">new</span> Array[Byte](BUF_SIZE)</div><div class="line">	<span class="keyword">private</span> <span class="keyword">var</span> bufsize: Int = <span class="number">0</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">var</span> pos: Int = <span class="number">0</span></div><div class="line"></div><div class="line">	<span class="keyword">override</span> <span class="keyword">def</span> read(): Int = {</div><div class="line">		<span class="keyword">if</span> (pos &gt;= bufsize) {</div><div class="line">			bufsize = <span class="keyword">this</span>.read(buf, <span class="number">0</span>, BUF_SIZE)</div><div class="line">			<span class="keyword">if</span> (bufsize &gt; <span class="number">0</span>) -<span class="number">1</span></div><div class="line">			pos = <span class="number">0</span></div><div class="line">		}</div><div class="line">		pos += <span class="number">1</span></div><div class="line">		buf(pos-<span class="number">1</span>)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">val</span> f = <span class="keyword">new</span> FileInputStream(<span class="string">"08.txt"</span>) <span class="keyword">with</span> Buffering</div><div class="line"></div><div class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">10</span>) println(f.read())</div></pre></td></tr></table></figure>

<p><strong>10.9</strong><br>使用本章的日志生成器特质,给前一个练习中的方案增加日志功能，要求体现缓冲的效果</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.{InputStream, FileInputStream}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Logger</span> </span>{</div><div class="line">  <span class="keyword">def</span> log(msg: String)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">NoneLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>{</div><div class="line">  <span class="keyword">def</span> log(msg: String) = {}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PrintLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>{</div><div class="line">  <span class="keyword">def</span> log(msg: String) = println(msg)</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Buffering</span> </span>{</div><div class="line">  <span class="keyword">this</span>: InputStream <span class="keyword">with</span> Logger =&gt;</div><div class="line"></div><div class="line">  <span class="keyword">val</span> BUF_SIZE: Int = <span class="number">5</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">val</span> buf = <span class="keyword">new</span> Array[Byte](BUF_SIZE)</div><div class="line">  <span class="keyword">private</span> <span class="keyword">var</span> bufsize: Int = <span class="number">0</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">var</span> pos: Int = <span class="number">0</span></div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> read(): Int = {</div><div class="line">    <span class="keyword">if</span> (pos &gt;= bufsize) {</div><div class="line">      bufsize = <span class="keyword">this</span>.read(buf, <span class="number">0</span>, BUF_SIZE)</div><div class="line">      log(<span class="string">"buffered %d bytes: %s"</span>.format(bufsize, buf.mkString(<span class="string">", "</span>)))</div><div class="line">      <span class="keyword">if</span> (bufsize &gt; <span class="number">0</span>) -<span class="number">1</span></div><div class="line">      pos = <span class="number">0</span></div><div class="line">    }</div><div class="line">    pos += <span class="number">1</span></div><div class="line">    buf(pos-<span class="number">1</span>)</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">val</span> f = <span class="keyword">new</span> FileInputStream(<span class="string">"exercise08.txt"</span>) <span class="keyword">with</span> Buffering <span class="keyword">with</span> PrintLogger</div><div class="line"></div><div class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">10</span>) println(f.read())</div></pre></td></tr></table></figure>

<p><strong>10.10</strong><br>实现一个IterableInputStream类，扩展java.io.InputStream并混入Iterable[Byte]特质 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IterableInputStream</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">InputStream</span> <span class="keyword">with</span> <span class="title">Iterable</span>[<span class="title">Byte</span>]</span>{</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">InputStreamIterator</span><span class="params">(outer: IterableInputStream)</span> <span class="keyword">extends</span> <span class="title">Iterator</span>[<span class="title">Byte</span>] </span>{</div><div class="line">    <span class="keyword">def</span> hasNext: Boolean = outer.available() &gt; <span class="number">0</span></div><div class="line">    <span class="keyword">def</span> next: Byte = outer.read().toByte</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> iterator: Iterator[Byte] = <span class="keyword">new</span> InputStreamIterator(<span class="keyword">this</span>)</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> read(): Int = <span class="number">0</span></div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》习题解答-第九章-文件和正则表达式]]></title>
    <link href="http://vernonzheng.com/2015/02/01/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%96%87%E4%BB%B6%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://vernonzheng.com/2015/02/01/《快学scala》习题解答-第九章-文件和正则表达式/</id>
    <published>2015-02-01T02:30:42.000Z</published>
    <updated>2015-02-08T07:14:57.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第九章_文件和正则表达式">第九章 文件和正则表达式</h2>
<p><strong>9.1</strong><br>编写一小段Scala代码，将某个文件中的行倒转顺序(将最后一行作为第一行,依此类推)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> path = <span class="string">"./exercise01.txt"</span></div><div class="line"><span class="keyword">val</span> file = Source.fromFile(path)</div><div class="line"><span class="keyword">val</span> reverseLines = file.getLines().toArray.reverse</div><div class="line"><span class="keyword">val</span> pw = <span class="keyword">new</span> PrintWriter(path)</div><div class="line">reverseLines.foreach (line =&gt; pw.write(line+<span class="string">"\n"</span>))</div><div class="line">pw.close()</div></pre></td></tr></table></figure>

<p><strong>9.2</strong><br>编写Scala程序,从一个带有制表符的文件读取内容,将每个制表符替换成一组空格,使得制表符隔开的n列仍然保持纵向对齐,并将结果写入同一个文件</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> io.Source</div><div class="line"><span class="keyword">import</span> java.io.PrintWriter</div><div class="line"></div><div class="line"><span class="keyword">val</span> path = <span class="string">"test.txt"</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> reader = Source.fromFile(path).getLines()</div><div class="line"></div><div class="line"><span class="keyword">val</span> result = <span class="keyword">for</span> ( t &lt;- reader) <span class="keyword">yield</span> t.replaceAll(<span class="string">"\\t"</span>,<span class="string">"    "</span>)</div><div class="line"></div><div class="line"><span class="keyword">val</span> pw = <span class="keyword">new</span> PrintWriter(path)</div><div class="line"></div><div class="line">result.foreach(line =&gt; pw.write(line + <span class="string">"\n"</span>))</div><div class="line"></div><div class="line">pw.close()</div></pre></td></tr></table></figure>

<p><strong>9.3</strong><br>编写一小段Scala代码,从一个文件读取内容并把所有字符数大于12的单词打印到控制台。如果你能用单行代码完成会有额外奖励</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scala.io.Source.fromFile(<span class="string">"./exercise01.txt"</span>).mkString.split(<span class="string">"\\s+"</span>).foreach(line=&gt; <span class="keyword">if</span>(line.length&gt;<span class="number">12</span>) println(line))</div></pre></td></tr></table></figure>

<p><strong>9.4</strong><br>编写Scala程序，从包含浮点数的文本文件读取内容，打印出文件中所有浮点数之和，平均值，最大值和最小值</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.io.Source</div><div class="line"><span class="keyword">val</span> nums = Source.fromFile(<span class="string">"exercise01.txt"</span>).mkString.split(<span class="string">"\\s+"</span>)</div><div class="line"></div><div class="line"><span class="keyword">var</span> total = <span class="number">0</span>d</div><div class="line"></div><div class="line">nums.foreach(total += _.toDouble)</div><div class="line"></div><div class="line">println(total)</div><div class="line">println(total/nums.length)</div><div class="line">println(nums.max)</div><div class="line">println(nums.min)</div></pre></td></tr></table></figure>

<p><strong>9.5</strong><br>编写Scala程序，向文件中写入2的n次方及其倒数，指数n从0到20。对齐各列:<br>  1         1<br>  2         0.5<br>  4         0.25<br>…         …</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.PrintWriter</div><div class="line"></div><div class="line"><span class="keyword">val</span> pw = <span class="keyword">new</span> PrintWriter(<span class="string">"exercise01.txt"</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> ( n &lt;- <span class="number">0</span> to <span class="number">20</span>){</div><div class="line">  <span class="keyword">val</span> t = BigDecimal(<span class="number">2</span>).pow(n)</div><div class="line">  pw.write(t.toString())</div><div class="line">  pw.write(<span class="string">"\t\t"</span>)</div><div class="line">  pw.write((<span class="number">1</span>/t).toString())</div><div class="line">  pw.write(<span class="string">"\n"</span>)</div><div class="line">}</div><div class="line"></div><div class="line">pw.close()</div></pre></td></tr></table></figure>

<p><strong>9.6</strong><br>编写正则表达式,匹配Java或C++程序代码中类似”like this,maybe with \” or\“这样的带引号的字符串。编写Scala程序将某个源文件中所有类似的字符串打印出来</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">val source = scala.io.Source.fromFile("test.txt").mkString</div><div class="line"></div><div class="line">val pattern = """"([^"\\]*([\\]+"[^"\\]*)*)"""".r</div><div class="line"></div><div class="line">pattern.findAllIn(source).foreach(println)</div></pre></td></tr></table></figure>

<p><strong>9.7</strong><br>编写Scala程序，从文本文件读取内容，并打印出所有的非浮点数的词法单位。要求使用正则表达式</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> io.Source</div><div class="line"></div><div class="line"><span class="keyword">val</span> source = Source.fromFile(<span class="string">"test.txt"</span>).mkString</div><div class="line"></div><div class="line"><span class="keyword">val</span> pattern = <span class="string">"""[^((\d+\.){0,1}\d+)^\s+]+"""</span>.r</div><div class="line"></div><div class="line">pattern.findAllIn(source).foreach(println)</div></pre></td></tr></table></figure>

<p><strong>9.8</strong><br>编写Scala程序打印出某个网页中所有img标签的src属性。使用正则表达式和分组</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> pattern = <span class="string">"""&lt;img[^&gt;]+(src\s*=\s*"[^&gt;^"]+")[^&gt;]*&gt;"""</span>.r</div><div class="line"><span class="keyword">val</span> source = scala.io.Source.fromURL(<span class="string">"http://www.vernonzheng.com"</span>,<span class="string">"utf-8"</span>).mkString</div><div class="line"></div><div class="line"><span class="keyword">for</span> (pattern(str) &lt;- pattern.findAllIn(source)) println(str)</div></pre></td></tr></table></figure>

<p><strong>9.9</strong><br>编写Scala程序，盘点给定目录及其子目录中总共有多少以.class为扩展名的文件</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> countClass(dir:java.io.File): Int = {</div><div class="line">  <span class="keyword">var</span> num:Int = <span class="number">0</span></div><div class="line">  <span class="keyword">val</span> files = dir.listFiles()</div><div class="line">  num += files.filter(_.isFile).count(_.getName.endsWith(<span class="string">".class"</span>))</div><div class="line">  files.filter(_.isDirectory).foreach(num += countClass(_))</div><div class="line">  num</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>9.10</strong><br>扩展那个可序列化的Person类，让它能以一个集合保存某个人的朋友信息。构造出一些Person对象，让他们中的一些人成为朋友，然后将Array[Person]保存到文件。将这个数组从文件中重新读出来，校验朋友关系是否完好</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">mport collection.mutable.ArrayBuffer</div><div class="line"><span class="keyword">import</span> java.io.{ObjectInputStream, FileOutputStream, FileInputStream, ObjectOutputStream}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(var name:String)</span> <span class="keyword">extends</span> <span class="title">Serializable</span></span>{</div><div class="line"></div><div class="line">  <span class="keyword">val</span> friends = <span class="keyword">new</span> ArrayBuffer[Person]()</div><div class="line"></div><div class="line">  <span class="keyword">def</span> addFriend(friend : Person){</div><div class="line">    friends += friend</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> toString() = {</div><div class="line">    <span class="keyword">var</span> str = <span class="string">"My name is "</span> + name + <span class="string">" and my friends name is "</span></div><div class="line">    friends.foreach(str += _.name + <span class="string">","</span>)</div><div class="line">    str</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>{</div><div class="line">  <span class="keyword">val</span> p1 = <span class="keyword">new</span> Person(<span class="string">"Ivan"</span>)</div><div class="line">  <span class="keyword">val</span> p2 = <span class="keyword">new</span> Person(<span class="string">"F2"</span>)</div><div class="line">  <span class="keyword">val</span> p3 = <span class="keyword">new</span> Person(<span class="string">"F3"</span>)</div><div class="line"></div><div class="line">  p1.addFriend(p2)</div><div class="line">  p1.addFriend(p3)</div><div class="line">  println(p1)</div><div class="line"></div><div class="line">  <span class="keyword">val</span> out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"person.obj"</span>))</div><div class="line">  out.writeObject(p1)</div><div class="line">  out.close()</div><div class="line"></div><div class="line">  <span class="keyword">val</span> in =  <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"person.obj"</span>))</div><div class="line">  <span class="keyword">val</span> p = in.readObject().asInstanceOf[Person]</div><div class="line">  println(p)</div><div class="line">}</div></pre></td></tr></table></figure>

<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》习题解答-第八章-继承]]></title>
    <link href="http://vernonzheng.com/2015/02/01/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%BB%A7%E6%89%BF/"/>
    <id>http://vernonzheng.com/2015/02/01/《快学scala》习题解答-第八章-继承/</id>
    <published>2015-02-01T00:10:42.000Z</published>
    <updated>2015-02-08T07:14:45.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第八章_继承">第八章 继承</h2>
<p><strong>8.1</strong><br>扩展如下的BankAccount类，新类CheckingAccount对每次存款和取款都收取1美元的手续费<br>class BankAccount(initialBalance:Double){<br>    private var balance = initialBalance<br>    def deposit(amount:Double) = { balance += amount; balance}<br>    def withdraw(amount:Double) = {balance -= amount; balance}<br>}</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankAccount</span><span class="params">(initialBalance:Double)</span></span>{</div><div class="line">  <span class="keyword">private</span> <span class="keyword">var</span> balance = initialBalance</div><div class="line">  <span class="keyword">def</span> deposit(amount:Double) = { balance += amount; balance}</div><div class="line">  <span class="keyword">def</span> withdraw(amount:Double) = {balance -= amount; balance}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckingAccount</span><span class="params">(initialBanlance:Double)</span> <span class="keyword">extends</span> <span class="title">BankAccount</span><span class="params">(initialBanlance)</span></span>{</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> deposit(amount:Double) = <span class="keyword">super</span>.deposit(amount-<span class="number">1</span>)</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> withdraw(amount:Double) = <span class="keyword">super</span>.withdraw(amount+<span class="number">1</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>8.2</strong><br>扩展前一个练习的BankAccount类，新类SavingsAccount每个月都有利息产生(earnMonthlyInterest方法被调用)，并且有每月三次免手续费的存款或取款。在earnMonthlyInterest方法中重置交易计数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankAccount</span><span class="params">(initialBalance:Double)</span></span>{</div><div class="line">  <span class="keyword">private</span> <span class="keyword">var</span> balance = initialBalance</div><div class="line">  <span class="keyword">def</span> deposit(amount:Double) = { balance += amount; balance}</div><div class="line">  <span class="keyword">def</span> withdraw(amount:Double) = {balance -= amount; balance}</div><div class="line">}</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SavingsAccount</span><span class="params">(initialBalance:Double)</span> <span class="keyword">extends</span> <span class="title">BankAccount</span><span class="params">(initialBalance)</span></span>{</div><div class="line">  <span class="keyword">private</span> <span class="keyword">var</span> num:Int = _</div><div class="line">  <span class="keyword">def</span> earnMonthlyInterest()={</div><div class="line">    num = <span class="number">3</span></div><div class="line">    <span class="keyword">super</span>.deposit(<span class="number">1</span>)</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> deposit(amount: Double): Double = {</div><div class="line">    num -= <span class="number">1</span></div><div class="line">    <span class="keyword">if</span>(num &lt; <span class="number">0</span>) <span class="keyword">super</span>.deposit(amount - <span class="number">1</span>) <span class="keyword">else</span> <span class="keyword">super</span>.deposit(amount)</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> withdraw(amount: Double): Double = {</div><div class="line">    num -= <span class="number">1</span></div><div class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) <span class="keyword">super</span>.withdraw(amount + <span class="number">1</span>) <span class="keyword">else</span> <span class="keyword">super</span>.withdraw(amount)</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>8.3</strong><br>翻开你喜欢的Java或C++教科书，一定会找到用来讲解继承层级的实例，可能是员工，宠物，图形或类似的东西。用Scala来实现这个示例。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**</span></div><div class="line"> * java</div><div class="line"> * class Art{</div><div class="line">    Art(){System.out.println("Art constructor");}</div><div class="line">  }</div><div class="line"></div><div class="line">  class Drawing extends Art{</div><div class="line">    Drawing() {System.out.println("Drawing constructor");}</div><div class="line">  }</div><div class="line"></div><div class="line">  public class Cartoon extends Drawing{</div><div class="line">    public Cartoon() { System.out.println("Cartoon constructor");}</div><div class="line">  }</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Art</span></span>{</div><div class="line">  println(<span class="string">"Art constructor"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drawing</span> <span class="keyword">extends</span> <span class="title">Art</span></span>{</div><div class="line">  println(<span class="string">"Drawing constructor"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cartoon</span> <span class="keyword">extends</span> <span class="title">Drawing</span></span>{</div><div class="line">  println(<span class="string">"Cartoon constructor"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>8.4</strong><br>定义一个抽象类Item,加入方法price和description。SimpleItem是一个在构造器中给出价格和描述的物件。利用val可以重写def这个事实。Bundle是一个可以包含其他物件的物件。其价格是打包中所有物件的价格之和。同时提供一个将物件添加到打包当中的机制，以及一个适合的description方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> collection.mutable.ArrayBuffer</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span></span>{</div><div class="line">  <span class="keyword">def</span> price():Double</div><div class="line">  <span class="keyword">def</span> description():String</div><div class="line"></div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> toString():String={</div><div class="line">    <span class="string">"description:"</span> + description() + <span class="string">"  price:"</span> + price()</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleItem</span><span class="params">(val price:Double,val description:String)</span> <span class="keyword">extends</span> <span class="title">Item</span></span>{</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bundle</span> <span class="keyword">extends</span> <span class="title">Item</span></span>{</div><div class="line"></div><div class="line">  <span class="keyword">val</span> items = <span class="keyword">new</span> ArrayBuffer[Item]()</div><div class="line"></div><div class="line">  <span class="keyword">def</span> addItem(item:Item){</div><div class="line">    items += item</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> price(): Double = {</div><div class="line">    <span class="keyword">var</span> total = <span class="number">0</span>d</div><div class="line">    items.foreach(total += _.price())</div><div class="line">    total</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> description(): String = {</div><div class="line">    items.mkString(<span class="string">" "</span>)</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>8.5</strong><br>设计一个Point类，其x和y坐标可以通过构造器提供。提供一个子类LabeledPoint，其构造器接受一个标签值和x,y坐标,比如:new LabeledPoint(“Black Thursday”,1929,230.07)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span><span class="params">(x:Double, y:Double)</span></span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LabeledPoint</span><span class="params">(x:Double, y:Double, tag:String)</span> <span class="keyword">extends</span> <span class="title">Point</span><span class="params">(x,y)</span></span></div></pre></td></tr></table></figure>

<p><strong>8.6</strong><br>定义一个抽象类Shape，一个抽象方法centerPoint，以及该抽象类的子类Rectangle和Circle。为子类提供合适的构造器，并重写centerPoint方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>{</div><div class="line">  <span class="keyword">def</span> centerPoint()</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span><span class="params">(startX:Int,startY:Int,endX:Int,endY:Int)</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>{</div><div class="line">  <span class="keyword">def</span> centerPoint() {}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span><span class="params">(x:Int,y:Int,radius:Double)</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>{</div><div class="line">  <span class="keyword">def</span> centerPoint() {}</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>8.7</strong><br>提供一个Square类，扩展自java.awt.Rectangle并且是三个构造器：一个以给定的端点和宽度构造正方形，一个以(0,0)为端点和给定的宽度构造正方形，一个以(0,0)为端点,0为宽度构造正方形</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.awt.{Point, Rectangle}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span><span class="params">(point:Point,width:Int)</span> <span class="keyword">extends</span> <span class="title">Rectangle</span><span class="params">(point.x,point.y,width,width)</span></span>{</div><div class="line"></div><div class="line">  <span class="keyword">def</span> <span class="keyword">this</span>(){</div><div class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> Point(<span class="number">0</span>,<span class="number">0</span>),<span class="number">0</span>)</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> <span class="keyword">this</span>(width:Int){</div><div class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> Point(<span class="number">0</span>,<span class="number">0</span>),width)</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>8.8</strong><br>编译8.6节中的Person和SecretAgent类并使用javap分析类文件。总共有多少name的getter方法？它们分别取什么值？(提示：可以使用-c和-private选项)</p>
<p>总共两个。Person中取得的是传入的name,而SecretAgent中取得的是默认的”secret”</p>
<p><strong>8.9</strong><br>在8.10节的Creature类中，将val range替换成一个def。如果你在Ant子类中也用def的话会有什么效果？如果在子类中使用val又会有什么效果？为什么？</p>
<p>在Ant中使用def没有问题。但是如果使用val则无法编译。因为val只能重写不带参数的def。这里的def是带参数的</p>
<p><strong>8.10</strong><br>文件scala/collection/immutable/Stack.scala包含如下定义:<br>class Stack[A] protected (protected val elems: List[A])<br>请解释protected关键字的含义。(提示：回顾我们在第5章中关于私有构造器的讨论) 此构造方法只能被其子类来调用,而不能被外界直接调用</p>
<p>此构造方法只能被其子类来调用,而不能被外界直接调用</p>
<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》习题解答-第七章-包和引入]]></title>
    <link href="http://vernonzheng.com/2015/01/31/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%8C%85%E5%92%8C%E5%BC%95%E5%85%A5/"/>
    <id>http://vernonzheng.com/2015/01/31/《快学scala》习题解答-第七章-包和引入/</id>
    <published>2015-01-31T11:32:42.000Z</published>
    <updated>2015-02-08T07:14:28.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第七章_包和引用">第七章 包和引用</h2>
<p><strong>7.1</strong><br>编写示例程序，展示为什么<br>package com.horstmann.impatient<br>不同于<br>package com<br>package horstmann<br>package impatient </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com {</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">T1</span><span class="params">()</span> </span>{}</div><div class="line"></div><div class="line">  <span class="keyword">package</span> horstmann {</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">T2</span><span class="params">(t: T1)</span> </span>{}</div><div class="line"></div><div class="line">    <span class="keyword">package</span> impatient {</div><div class="line">      <span class="class"><span class="keyword">class</span> <span class="title">T3</span><span class="params">(t1: T1, t2: T2)</span> </span>{}</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div><div class="line"><span class="keyword">package</span> com.horstmann.impatient{</div><div class="line">  <span class="comment">//class T4(t1:T1,t3:T3)      //can not find type T1</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>7.2</strong><br>编写一段让你的Scala朋友们感到困惑的代码，使用一个不在顶部的com包</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> vernon {</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">T1</span><span class="params">()</span> </span>{}</div><div class="line"></div><div class="line">  <span class="keyword">package</span> com {</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">T2</span><span class="params">(t: T1)</span> </span>{}</div><div class="line">  }</div><div class="line">  </div><div class="line"></div><div class="line">  <span class="keyword">package</span> impatient {</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">T3</span><span class="params">(t1: T1, t2: com.T2)</span> </span>{}</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>7.3</strong><br>编写一个包random,加入函数nextInt():Int,nextDouble():Double,setSeed(seed:Int):Unit。生成随机数的算法采用线性同余生成器</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">object</span> <span class="title">random</span></span>{</div><div class="line"></div><div class="line">  <span class="keyword">var</span> seed:Int = _</div><div class="line">  <span class="keyword">val</span> a = BigDecimal(<span class="number">1664525</span>)</div><div class="line">  <span class="keyword">val</span> b = BigDecimal(<span class="number">1013904223</span>)</div><div class="line">  <span class="keyword">val</span> n = <span class="number">32</span></div><div class="line"></div><div class="line">  <span class="keyword">def</span> nextInt():Int={</div><div class="line">    <span class="keyword">val</span> temp = (seed * a + b) % BigDecimal(<span class="number">2</span>).pow(n)</div><div class="line">    seed = temp.toInt</div><div class="line">    seed</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> nextDouble():Double={</div><div class="line">    <span class="keyword">val</span> temp = (seed * a + b) % BigDecimal(<span class="number">2</span>).pow(n)</div><div class="line">    seed = temp.toInt</div><div class="line">    temp.toDouble</div><div class="line">  }</div><div class="line">}</div><div class="line"><span class="keyword">import</span> random._</div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Q3</span> <span class="keyword">extends</span> <span class="title">App</span> </span>{</div><div class="line">  (<span class="number">1</span> to <span class="number">10</span>).foreach(x =&gt; println(nextInt()))</div><div class="line">  (<span class="number">1</span> to <span class="number">10</span>).foreach(x =&gt; println(nextDouble()))</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>7.4</strong><br>在你看来Scala的设计者为什么要提供package object语法而不是简单的让你将函数和变量添加到包中呢？</p>
<p>JVM不支持</p>
<p><strong>7.5</strong><br>private[com] def giveRaise(rate:Double)的含义是什么？有用吗？</p>
<p>除了com包可访问giveRaise，其他包都不能访问。有用。</p>
<p><strong>7.6</strong><br>编写一段程序,将Java哈希映射中的所有元素拷贝到Scala哈希映射。用引入语句重命名这两个类。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Q6</span> <span class="keyword">extends</span> <span class="title">App</span></span>{</div><div class="line"></div><div class="line">  <span class="keyword">import</span> java.util.{HashMap =&gt; JavaHashMap}</div><div class="line">  <span class="keyword">import</span> collection.mutable.{HashMap =&gt; ScalaHashMap, Map =&gt; ScalaMap}</div><div class="line"></div><div class="line">  <span class="keyword">val</span> javaMap = <span class="keyword">new</span> JavaHashMap[Int,String]</div><div class="line"></div><div class="line">  javaMap.put(<span class="number">1</span>, <span class="string">"One"</span>);</div><div class="line">  javaMap.put(<span class="number">2</span>, <span class="string">"Two"</span>);</div><div class="line">  javaMap.put(<span class="number">3</span>, <span class="string">"Three"</span>);</div><div class="line">  javaMap.put(<span class="number">4</span>, <span class="string">"Four"</span>);</div><div class="line"></div><div class="line">  <span class="keyword">val</span> scalaMap = <span class="keyword">new</span> ScalaHashMap[Int,String]</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(key &lt;- javaMap.keySet().toArray){</div><div class="line">    scalaMap += (key.asInstanceOf[Int] -&gt; javaMap.get(key))</div><div class="line">  }</div><div class="line"></div><div class="line">  println(scalaMap.mkString(<span class="string">" "</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>7.7</strong><br>在前一个练习中，将所有引入语句移动到尽可能小的作用域里</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Q7</span> <span class="keyword">extends</span> <span class="title">App</span></span>{</div><div class="line"></div><div class="line">  <span class="keyword">import</span> java.util.{HashMap =&gt; JavaHashMap}</div><div class="line">  </div><div class="line">  <span class="keyword">val</span> javaMap = <span class="keyword">new</span> JavaHashMap[Int,String]</div><div class="line"></div><div class="line">  javaMap.put(<span class="number">1</span>, <span class="string">"One"</span>);</div><div class="line">  javaMap.put(<span class="number">2</span>, <span class="string">"Two"</span>);</div><div class="line">  javaMap.put(<span class="number">3</span>, <span class="string">"Three"</span>);</div><div class="line">  javaMap.put(<span class="number">4</span>, <span class="string">"Four"</span>);</div><div class="line">  </div><div class="line">  <span class="keyword">import</span> collection.mutable.{HashMap =&gt; ScalaHashMap, Map =&gt; ScalaMap}</div><div class="line">  </div><div class="line">  <span class="keyword">val</span> scalaMap = <span class="keyword">new</span> ScalaHashMap[Int,String]</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(key &lt;- javaMap.keySet().toArray()){</div><div class="line">    scalaMap += (key.asInstanceOf[Int] -&gt; javaMap.get(key))</div><div class="line">  }</div><div class="line"></div><div class="line">  println(scalaMap.mkString(<span class="string">" "</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>7.8</strong><br>以下代码的作用是什么？这是个好主意吗？<br>import java.<em><br>import javax.</em></p>
<p>导入java和javax下的所有类。而java和javax下是没有类的。所以此代码无用</p>
<p><strong>7.9</strong><br>编写一段程序，引入java.lang.System类，从user.name系统属性读取用户名，从Console对象读取一个密码,如果密码不是”secret”，则在标准错误流中打印一个消息；如果密码是”secret”，则在标准输出流中打印一个问候消息。不要使用任何其他引入，也不要使用任何限定词(带句点的那种)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Q9</span> <span class="keyword">extends</span> <span class="title">App</span></span>{</div><div class="line">  <span class="keyword">import</span> java.lang.System._</div><div class="line">  <span class="keyword">var</span> password = Console.readLine()</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (password equals <span class="string">"secret"</span>)</div><div class="line">    System.out.println(<span class="string">"Hello "</span> + getProperty(<span class="string">"user.name"</span>))</div><div class="line">  <span class="keyword">else</span></div><div class="line">    System.err.println(<span class="string">"password error!"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>7.10</strong><br>除了StringBuilder,还有哪些java.lang的成员是被scala包覆盖的？</p>
<p>比对java.lang下的类和scala包下的类，略</p>
<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》习题解答-第六章-对象]]></title>
    <link href="http://vernonzheng.com/2015/01/31/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AF%B9%E8%B1%A1/"/>
    <id>http://vernonzheng.com/2015/01/31/《快学scala》习题解答-第六章-对象/</id>
    <published>2015-01-31T08:32:42.000Z</published>
    <updated>2015-02-08T07:18:08.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第六章_对象">第六章 对象</h2>
<p><strong>6.1</strong><br>编写一个 Conversions 对象，加入 inchesToCentimeters,gallonsToLiters 和 milesToKilometers 方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Conversions</span></span>{</div><div class="line">  <span class="keyword">def</span> inchesToSantimeters(value: Double) = value * <span class="number">2.54</span></div><div class="line">  <span class="keyword">def</span> gallonsToLiters(value: Double) = value * <span class="number">3.78541178</span></div><div class="line">  <span class="keyword">def</span> milesToKilometers(value: Double) = value * <span class="number">1.609344</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>6.2</strong><br>前一个练习不是很面向对象。提供一个通用的超类 UnitConversion并定义扩展该超类的 InchesToCentimeters,GallonsToLiters 和 MilesToKilometers 对象</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnitConversion</span><span class="params">(val factor: Double)</span> </span>{</div><div class="line">	<span class="keyword">def</span> convert(value: Double): Double = factor * value</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">InchesToSantimeters</span> <span class="keyword">extends</span> <span class="title">UnitConversion</span><span class="params">(2.54)</span></span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">GallonsToLiters</span> <span class="keyword">extends</span> <span class="title">UnitConversion</span><span class="params">(3.78541178)</span></span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">MilesToKilometers</span> <span class="keyword">extends</span> <span class="title">UnitConversion</span><span class="params">(1.609344)</span></span></div></pre></td></tr></table></figure>

<p><strong>6.3</strong><br>定义一个扩展自 java.awt.Point 的 Origin 对象。为什么说这实际上不是个好主意？(仔细看 Point 类的方法)Point 中的 getLocation 方法返回的是 Point 对象，如果想返回 Origin 对象，需要 Origin 类才行</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.awt.Point</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Origin</span> <span class="keyword">extends</span> <span class="title">Point</span></span>{</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> getLocation : Point = <span class="keyword">super</span>.getLocation</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>6.4</strong><br>定义一个 Point 类和一个伴生对象,使得我们可以不用 new 而直接用 Point(3,4)来构造 Point 实例 apply 方法的使用</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span><span class="params">(x: Int = 0, y: Int = 0)</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">awt</span>.<span class="title">Point</span><span class="params">(x, y)</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Point</span> </span>{</div><div class="line">	<span class="keyword">def</span> apply(x: Int = <span class="number">0</span>, y: Int = <span class="number">0</span>) = <span class="keyword">new</span> Point(x, y)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>6.5</strong><br>编写一个 Scala 应用程序,使用 App 特质,以反序打印命令行参数,用空格隔开。举例来说,scala Reverse Hello World 应该打印 World Hello</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Reverse</span> <span class="keyword">extends</span> <span class="title">App</span></span>{</div><div class="line">  args.reverse.mkString(<span class="string">" "</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>6.6</strong><br>编写一个扑克牌 4 种花色的枚举,让其 toString 方法分别返回♣,♦,♥,♠</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Suits</span> <span class="keyword">extends</span> <span class="title">Enumeration</span></span>{</div><div class="line">  <span class="keyword">type</span> Suits = Value</div><div class="line">  <span class="keyword">val</span> Spade = Value(<span class="string">"♠"</span>)</div><div class="line">  <span class="keyword">val</span> Club = Value(<span class="string">"♣"</span>)</div><div class="line">  <span class="keyword">val</span> Heart = Value(<span class="string">"♥"</span>)</div><div class="line">  <span class="keyword">val</span> Diamond = Value(<span class="string">"♦"</span>)</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> toString():String={</div><div class="line">    Suits.values.mkString(<span class="string">","</span>)</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>6.7</strong><br>实现一个函数,检查某张牌的花色是否为红色</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Suits</span> <span class="keyword">extends</span> <span class="title">Enumeration</span> </span>{</div><div class="line">  <span class="keyword">type</span> Suits = Value</div><div class="line">  <span class="keyword">val</span> Spade = Value(<span class="string">"♠"</span>)</div><div class="line">  <span class="keyword">val</span> Club = Value(<span class="string">"♣"</span>)</div><div class="line">  <span class="keyword">val</span> Heart = Value(<span class="string">"♥"</span>)</div><div class="line">  <span class="keyword">val</span> Diamond = Value(<span class="string">"♦"</span>)</div><div class="line">  <span class="keyword">def</span> isRed(card: Suits) = card == Heart || card == Diamond</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>6.8</strong><br>编写一个枚举,描述 RGB 立方体的 8 个角。ID 使用颜色值(例如 :红色是 0xff0000)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">RGBCube</span> <span class="keyword">extends</span> <span class="title">Enumeration</span> </span>{</div><div class="line">	<span class="keyword">val</span> black = Value(<span class="number">0x000000</span>, <span class="string">"Black"</span>)</div><div class="line">	<span class="keyword">val</span> red = Value(<span class="number">0xff0000</span>, <span class="string">"Red"</span>)</div><div class="line">	<span class="keyword">val</span> green = Value(<span class="number">0x00ff00</span>, <span class="string">"Green"</span>)</div><div class="line">	<span class="keyword">val</span> blue = Value(<span class="number">0x0000ff</span>, <span class="string">"Blue"</span>)</div><div class="line">	<span class="keyword">val</span> yellow = Value(<span class="number">0xffff00</span>, <span class="string">"Yellow"</span>)</div><div class="line">	<span class="keyword">val</span> magenta = Value(<span class="number">0xff00ff</span>, <span class="string">"Magenta"</span>)</div><div class="line">	<span class="keyword">val</span> cyan = Value(<span class="number">0x00ffff</span>, <span class="string">"Cyan"</span>)</div><div class="line">	<span class="keyword">val</span> white = Value(<span class="number">0xffffff</span>, <span class="string">"White"</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">for</span>( c &lt;- RGBCube.values ) println(<span class="string">"0x%06x: %s"</span>.format(c.id, c))</div></pre></td></tr></table></figure>

<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》习题解答-第五章-类]]></title>
    <link href="http://vernonzheng.com/2015/01/25/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%B1%BB/"/>
    <id>http://vernonzheng.com/2015/01/25/《快学scala》习题解答-第五章-类/</id>
    <published>2015-01-25T11:27:42.000Z</published>
    <updated>2015-02-08T07:13:21.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第五章_类">第五章 类</h2>
<p><strong>5.1</strong><br>改进5.1节的Counter类,让它不要在Int.MaxValue时变成负数</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span><span class="params">()</span></span>{</div><div class="line">  <span class="keyword">private</span> <span class="keyword">var</span> value = <span class="number">0</span></div><div class="line">  <span class="keyword">def</span> increment(){ <span class="keyword">if</span>(value&lt;Int.MaxValue) value += <span class="number">1</span> }</div><div class="line">  <span class="keyword">def</span> current() = value</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>5.2</strong><br>编写一个BankAccount类，加入deposit和withdraw方法，和一个只读的balance属性</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankAccount</span></span>{</div><div class="line">  <span class="keyword">private</span> <span class="keyword">val</span> banlance = <span class="number">0</span></div><div class="line">  <span class="keyword">def</span> deposit(){}</div><div class="line">  <span class="keyword">def</span> withdraw(){}</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>5.3</strong><br>编写一个Time类，加入只读属性hours和minutes，和一个检查某一时刻是否早于另一时刻的方法before(other:Time):Boolean。Time对象应该以new Time(hrs,min)方式构建。其中hrs以军用时间格式呈现(介于0和23之间)</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span><span class="params">(private[this] val hrs:Int,private[this] val min:Int)</span></span>{</div><div class="line">  <span class="keyword">val</span> hours = hrs</div><div class="line">  <span class="keyword">val</span> minutes = min</div><div class="line">  <span class="keyword">def</span> before(other:Time):Boolean = {</div><div class="line">    <span class="keyword">if</span>(hours&lt;other.hours)</div><div class="line">      <span class="keyword">true</span></div><div class="line">    <span class="keyword">if</span>(hours==other.hours)</div><div class="line">      <span class="keyword">if</span>(minutes&lt;other.minutes)</div><div class="line">        <span class="keyword">true</span></div><div class="line">    <span class="keyword">false</span></div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>5.4</strong><br>重新实现前一个类中的Time类，将内部呈现改成午夜起的分钟数(介于0到24*60-1之间)。不要改变公有接口。也就是说，客户端代码不应因你的修改而受影响</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span><span class="params">(private[this] val hrs:Int,private[this] val min:Int)</span></span>{</div><div class="line">  <span class="keyword">val</span> minutesInDay = hrs*<span class="number">24</span>+min</div><div class="line">  <span class="keyword">def</span> before(other:Time):Boolean = {</div><div class="line">    <span class="keyword">if</span>(minutesInDay&lt;other.minutesInDay)</div><div class="line">      <span class="keyword">true</span></div><div class="line">    <span class="keyword">false</span></div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>5.5</strong><br>创建一个Student类，加入可读写的JavaBeans属性name(类型为String)和id(类型为Long)。有哪些方法被生产？(用javap查看。)你可以在Scala中调用JavaBeans的getter和setter方法吗？应该这样做吗？</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.beans.BeanProperty</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>{</div><div class="line">  <span class="annotation">@BeanProperty</span> <span class="keyword">var</span> name:String = _</div><div class="line">  <span class="annotation">@BeanProperty</span> <span class="keyword">var</span> id:Long = _</div><div class="line">}</div><div class="line"><span class="javadoc">/**</span></div><div class="line">javap -c Student 后显示如下</div><div class="line"></div><div class="line">Compiled from "Student.scala"</div><div class="line">public class Student extends java.lang.Object implements scala.ScalaObject{</div><div class="line">  public java.lang.String name();</div><div class="line">  Code:</div><div class="line">  0:   aload_0</div><div class="line">  1:   getfield        #13; //Field name:Ljava/lang/String;</div><div class="line">  4:   areturn</div><div class="line"></div><div class="line">  public void name_$eq(java.lang.String);</div><div class="line">  Code:</div><div class="line">  0:   aload_0</div><div class="line">  1:   aload_1</div><div class="line">  2:   putfield        #13; //Field name:Ljava/lang/String;</div><div class="line">  5:   return</div><div class="line"></div><div class="line">  public void setName(java.lang.String);</div><div class="line">  Code:</div><div class="line">  0:   aload_0</div><div class="line">  1:   aload_1</div><div class="line">  2:   putfield        #13; //Field name:Ljava/lang/String;</div><div class="line">  5:   return</div><div class="line"></div><div class="line">  public long id();</div><div class="line">  Code:</div><div class="line">  0:   aload_0</div><div class="line">  1:   getfield        #19; //Field id:J</div><div class="line">  4:   lreturn</div><div class="line"></div><div class="line">  public void id_$eq(long);</div><div class="line">  Code:</div><div class="line">  0:   aload_0</div><div class="line">  1:   lload_1</div><div class="line">  2:   putfield        #19; //Field id:J</div><div class="line">  5:   return</div><div class="line"></div><div class="line">  public void setId(long);</div><div class="line">  Code:</div><div class="line">  0:   aload_0</div><div class="line">  1:   lload_1</div><div class="line">  2:   putfield        #19; //Field id:J</div><div class="line">  5:   return</div><div class="line"></div><div class="line">  public long getId();</div><div class="line">  Code:</div><div class="line">  0:   aload_0</div><div class="line">  1:   invokevirtual   #25; //Method id:()J</div><div class="line">  4:   lreturn</div><div class="line"></div><div class="line">  public java.lang.String getName();</div><div class="line">  Code:</div><div class="line">  0:   aload_0</div><div class="line">  1:   invokevirtual   #28; //Method name:()Ljava/lang/String;</div><div class="line">  4:   areturn</div><div class="line"></div><div class="line">  public Student();</div><div class="line">  Code:</div><div class="line">  0:   aload_0</div><div class="line">  1:   invokespecial   #34; //Method java/lang/Object."&lt;init&gt;":()V</div><div class="line">  4:   return</div><div class="line"></div><div class="line">}</div><div class="line">  **/</div></pre></td></tr></table></figure>

<p><strong>5.6</strong><br>在5.2节的Person类中提供一个主构造器,将负年龄转换为0</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(var age:Int)</span></span>{</div><div class="line">  age = <span class="keyword">if</span>(age &lt; <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> age</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>5.7</strong><br>编写一个Person类，其主构造器接受一个字符串，该字符串包含名字，空格和姓，如new Person(“Fred Smith”)。提供只读属性firstName和lastName。主构造器参数应该是var,val还是普通参数？为什么？</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(private[this] val name:String)</span></span>{</div><div class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> tmp = name.split(<span class="string">"\\s+"</span>)</div><div class="line">  <span class="keyword">val</span> firstName = tmp(<span class="number">0</span>)</div><div class="line">  <span class="keyword">val</span> lastName = tmp(<span class="number">1</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>5.8</strong><br>创建一个Car类，以只读属性对应制造商，型号名称，型号年份以及一个可读写的属性用于车牌。提供四组构造器。每个构造器fc都要求制造商和型号为必填。型号年份和车牌可选，如果未填，则型号年份为-1，车牌为空串。你会选择哪一个作为你的主构造器？为什么？</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">(val manufactuer:String, val model: String, val year: Int = -1, var license: String = <span class="string">""</span>)</span></span></div></pre></td></tr></table></figure>

<p><strong>5.9</strong><br>在Java,C#或C++重做前一个练习。Scala相比之下精简多少？</p>
<p>答：<br>略</p>
<p><strong>5.10</strong><br>考虑如下的类</p>
<p>class Employ(val name:String,var salary:Double){<br>    def this(){this(“John Q. Public”,0.0)}<br>}<br>重写该类,使用显示的字段定义，和一个缺省主构造器。你更倾向于使用哪种形式？为什么？</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employ</span><span class="params">()</span></span>{</div><div class="line">  <span class="keyword">val</span> name:String = <span class="string">"John Q. Public"</span></div><div class="line">  <span class="keyword">var</span> salary:Double = <span class="number">0.0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》习题解答-第四章-映射与元组]]></title>
    <link href="http://vernonzheng.com/2015/01/25/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%83%E7%BB%84/"/>
    <id>http://vernonzheng.com/2015/01/25/《快学scala》习题解答-第四章-映射与元组/</id>
    <published>2015-01-25T09:27:42.000Z</published>
    <updated>2015-02-08T07:17:55.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第四章_映射和元组">第四章 映射和元组</h2>
<p><strong>4.1</strong><br>设置一个映射,其中包含你想要的一些装备，以及它们的价格。然后构建另一个映射，采用同一组键，但是价格上打9折</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> buildEquipMap() :Map[String,Double] = {</div><div class="line">  <span class="keyword">val</span> equipMap:Map[String,Double] = Map(<span class="string">"eq1"</span>-&gt;<span class="number">11.1</span>,<span class="string">"eq2"</span>-&gt;<span class="number">12.2</span>,<span class="string">"eq3"</span>-&gt;<span class="number">14</span>)</div><div class="line">  <span class="keyword">for</span> ((k,v) &lt;- equipMap) <span class="keyword">yield</span> (k,v*<span class="number">0.9</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>4.2</strong><br>编写一段程序，从文件中读取单词。用一个可变映射来清点每个单词出现的频率。读取这些单词的操作可以使用java.util.Scanner</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.collection.mutable</div><div class="line"><span class="keyword">import</span> scala.io.Source</div><div class="line"></div><div class="line"><span class="keyword">def</span> countWord() : Unit = {</div><div class="line">  <span class="keyword">val</span> wordMap = <span class="keyword">new</span> mutable.HashMap[String,Int]</div><div class="line">  <span class="keyword">val</span> in = <span class="keyword">new</span> java.util.Scanner(<span class="keyword">new</span> java.io.File(<span class="string">"exercise02.txt"</span>))</div><div class="line">  <span class="keyword">while</span>(in.hasNext){</div><div class="line">    <span class="keyword">val</span> word = in.next()</div><div class="line">    wordMap(word) = wordMap.getOrElse(word,<span class="number">0</span>) + <span class="number">1</span></div><div class="line">  }</div><div class="line">  println(wordMap.mkString(<span class="string">","</span>))</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">def</span> countWord2() : Unit = {</div><div class="line">  <span class="keyword">val</span> source = Source.fromFile(<span class="string">"exercise02.txt"</span>).mkString</div><div class="line">  <span class="keyword">val</span> tokens = source.split(<span class="string">"\\s+"</span>)</div><div class="line">  <span class="keyword">val</span> wordMap = <span class="keyword">new</span> mutable.HashMap[String,Int]</div><div class="line">  <span class="keyword">for</span>(word &lt;- tokens){</div><div class="line">    wordMap(word) = wordMap.getOrElse(word,<span class="number">0</span>) + <span class="number">1</span></div><div class="line">  }</div><div class="line">  println(wordMap.mkString(<span class="string">","</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>4.3</strong><br>重复前一个练习，这次用不可变的映射</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">mport scala.collection.{mutable, immutable}</div><div class="line"><span class="keyword">import</span> scala.io.Source</div><div class="line"></div><div class="line"><span class="keyword">def</span> countWord() : Unit = {</div><div class="line">  <span class="keyword">val</span> source = Source.fromFile(<span class="string">"exercise02.txt"</span>).mkString</div><div class="line">  <span class="keyword">val</span> tokens = source.split(<span class="string">"\\s+"</span>)</div><div class="line">  <span class="keyword">var</span> wordMap = <span class="keyword">new</span> immutable.HashMap[String,Int]</div><div class="line">  <span class="keyword">for</span>(key &lt;- tokens){</div><div class="line">    wordMap += (key -&gt; (wordMap.getOrElse(key,<span class="number">0</span>) + <span class="number">1</span>))</div><div class="line">  }</div><div class="line">  println(wordMap.mkString(<span class="string">","</span>))</div><div class="line">}</div><div class="line"></div><div class="line"><span class="javadoc">/**</span></div><div class="line"> * 书中:immutable map += 不断生成新的map，由于都是immutable，共享大部分数据结构，</div><div class="line"> * 测试下性能</div><div class="line"> */</div><div class="line"><span class="keyword">def</span> countWord1(tokens:Array[String]) : Unit = {</div><div class="line">  <span class="keyword">val</span> wordMap = <span class="keyword">new</span> mutable.HashMap[String,Int]</div><div class="line">  <span class="keyword">for</span>(word &lt;- tokens){</div><div class="line">    wordMap(word) = wordMap.getOrElse(word,<span class="number">0</span>) + <span class="number">1</span></div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">def</span> countWord2(tokens:Array[String]) : Unit = {</div><div class="line">  <span class="keyword">val</span> wordMap = <span class="keyword">new</span> mutable.HashMap[String,Int]</div><div class="line">  <span class="keyword">for</span>(word &lt;- tokens){</div><div class="line">    wordMap(word) = wordMap.getOrElse(word,<span class="number">0</span>) + <span class="number">1</span></div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">def</span> performance():Unit={</div><div class="line">  <span class="keyword">val</span> source = Source.fromFile(<span class="string">"exercise02.txt"</span>).mkString</div><div class="line">  <span class="keyword">val</span> tokens = source.split(<span class="string">"\\s+"</span>)</div><div class="line">  <span class="keyword">val</span> startTime1 = System.currentTimeMillis()</div><div class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> to <span class="number">10000</span>) {</div><div class="line">    countWord1(tokens)</div><div class="line">  }</div><div class="line">  <span class="keyword">val</span> endTime1 = System.currentTimeMillis()</div><div class="line">  <span class="keyword">val</span> startTime2 = System.currentTimeMillis()</div><div class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> to <span class="number">10000</span>) {</div><div class="line">    countWord2(tokens)</div><div class="line">  }</div><div class="line">  <span class="keyword">val</span> endTime2 = System.currentTimeMillis()</div><div class="line">  println(<span class="string">"countWord1(mutable map) cost:"</span>+(endTime1-startTime1))</div><div class="line">  println(<span class="string">"countWord2(immutable map) cost:"</span>+(endTime2-startTime2))</div><div class="line"></div><div class="line">  <span class="javadoc">/**</span></div><div class="line">   * scala&gt; performance</div><div class="line">countWord1(mutable map) cost:36</div><div class="line">countWord2(immutable map) cost:34</div><div class="line"></div><div class="line">scala&gt; performance</div><div class="line">countWord1(mutable map) cost:4</div><div class="line">countWord2(immutable map) cost:4</div><div class="line"></div><div class="line">scala&gt; performance</div><div class="line">countWord1(mutable map) cost:8</div><div class="line">countWord2(immutable map) cost:6</div><div class="line"></div><div class="line">scala&gt; performance</div><div class="line">countWord1(mutable map) cost:4</div><div class="line">countWord2(immutable map) cost:8</div><div class="line"></div><div class="line">scala&gt; performance</div><div class="line">countWord1(mutable map) cost:5</div><div class="line">countWord2(immutable map) cost:4</div><div class="line">   */</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>4.4</strong><br>重复前一个练习，这次使用已排序的映射，以便单词可以按顺序打印出来</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.collection.immutable.TreeMap</div><div class="line"><span class="keyword">import</span> scala.io.Source</div><div class="line"></div><div class="line"><span class="keyword">def</span> countWord() : Unit = {</div><div class="line">  <span class="keyword">val</span> source = Source.fromFile(<span class="string">"exercise02.txt"</span>).mkString</div><div class="line">  <span class="keyword">val</span> tokens = source.split(<span class="string">"\\s+"</span>)</div><div class="line">  <span class="keyword">var</span> wordMap = <span class="keyword">new</span> TreeMap[String,Int]</div><div class="line">  <span class="keyword">for</span>(key &lt;- tokens){</div><div class="line">    wordMap += (key -&gt; (wordMap.getOrElse(key,<span class="number">0</span>) + <span class="number">1</span>))</div><div class="line">  }</div><div class="line">  println(wordMap.mkString(<span class="string">","</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>4.5</strong><br>重复前一个练习，这次使用java.util.TreeMap并使之适用于Scala API</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util</div><div class="line"><span class="keyword">import</span> scala.collection.mutable.Map</div><div class="line"><span class="keyword">import</span> scala.collection.JavaConversions.mapAsScalaMap</div><div class="line"><span class="keyword">import</span> scala.io.Source</div><div class="line"></div><div class="line"><span class="keyword">def</span> countWord() : Unit = {</div><div class="line">  <span class="keyword">val</span> source = Source.fromFile(<span class="string">"exercise02.txt"</span>).mkString</div><div class="line">  <span class="keyword">val</span> tokens = source.split(<span class="string">"\\s+"</span>)</div><div class="line">  <span class="keyword">var</span> wordMap:Map[String,Int] = <span class="keyword">new</span> util.TreeMap[String,Int]</div><div class="line">  <span class="keyword">for</span>(key &lt;- tokens){</div><div class="line">    wordMap += (key -&gt; (wordMap.getOrElse(key,<span class="number">0</span>) + <span class="number">1</span>))</div><div class="line">  }</div><div class="line">  println(wordMap.mkString(<span class="string">","</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>4.6</strong><br>定义一个链式哈希映射,将”Monday”映射到java.util.Calendar.MONDAY,依次类推加入其他日期。展示元素是以插入的顺序被访问的</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Calendar</div><div class="line"><span class="keyword">import</span> scala.collection.mutable</div><div class="line"></div><div class="line"><span class="keyword">def</span> calendarDays():Unit = {</div><div class="line">  <span class="keyword">val</span> daysMap = mutable.LinkedHashMap(</div><div class="line">    <span class="string">"Monday"</span> -&gt; Calendar.MONDAY,</div><div class="line">    <span class="string">"Tuesday"</span> -&gt; Calendar.TUESDAY,</div><div class="line">    <span class="string">"Wednesday"</span> -&gt; Calendar.WEDNESDAY,</div><div class="line">    <span class="string">"Thursday"</span> -&gt; Calendar.THURSDAY,</div><div class="line">    <span class="string">"Friday"</span> -&gt; Calendar.FRIDAY,</div><div class="line">    <span class="string">"Saturday"</span> -&gt; Calendar.SATURDAY,</div><div class="line">    <span class="string">"Sunday"</span> -&gt; Calendar.SUNDAY</div><div class="line">  )</div><div class="line">  println(daysMap.mkString(<span class="string">","</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>4.7</strong><br>打印出所有Java系统属性的表格</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.collection.JavaConversions.propertiesAsScalaMap</div><div class="line"></div><div class="line"><span class="keyword">def</span> printJavaSysProps():Unit = {</div><div class="line">  <span class="keyword">val</span> propMap:collection.Map[String,String] = System.getProperties()</div><div class="line">  <span class="keyword">val</span> maxKeyLength = propMap.keySet.map(_.length).max</div><div class="line">  <span class="keyword">for</span>( (k,v) &lt;- propMap ) printf(<span class="string">"%-"</span> + maxKeyLength + <span class="string">"s | %s\n"</span>, k, v)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>4.8</strong><br>编写一个函数minmax(values:Array[Int]),返回数组中最小值和最大值的对偶</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> minmax(values:Array[Int])={</div><div class="line">  (values.max,values.min)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>4.9</strong><br>编写一个函数Iteqgt(values:Array[int],v:Int),返回数组中小于v,等于v和大于v的数量，要求三个值一起返回</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> Iteqgt(values:Array[Int],v:Int){</div><div class="line">  (values.count(_ &lt; v),values.count(_ == v),values.count(_ &gt; v))</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>4.10</strong><br>当你将两个字符串拉链在一起，比如”Hello”.zip(“World”)，会是什么结果？想出一个讲得通的用例</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="string">"Hello"</span>.zip(<span class="string">"hello"</span>).toMap</div><div class="line">res40: scala.collection.immutable.Map[Char,Char] = Map(H -&gt; h, e -&gt; e, l -&gt; l, o -&gt; o)</div></pre></td></tr></table></figure>

<p>StringOps中的zip定义如下:</p>
<p>abstract def zip<a href="that: GenIterable[B]" target="_blank" rel="external">B</a>: StringOps[(A, B)]<br>GenIterable是可遍历对象需要包含的trait，对于String来说，它是可遍历的。但是它的遍历是遍历单个字母。 所以拉链就针对每个字母来进行。</p>
<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》习题解答-第三章-数组相关操作]]></title>
    <link href="http://vernonzheng.com/2015/01/21/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
    <id>http://vernonzheng.com/2015/01/21/《快学scala》习题解答-第三章-数组相关操作/</id>
    <published>2015-01-21T14:40:42.000Z</published>
    <updated>2015-02-08T07:10:32.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第三章_数组相关操作">第三章 数组相关操作</h2>
<p><strong>3.1</strong><br>编写一段代码，将a设置为一个n个随机整数的数组，要求随机数介于0(包含)和n(不包含)之间</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.util.Random</div><div class="line"><span class="keyword">import</span> scala.math.random</div><div class="line"><span class="keyword">def</span> randomArray(n: Int) :Array[Int] = {</div><div class="line">  <span class="keyword">val</span> array = <span class="keyword">for</span>( i&lt;- <span class="number">0</span> to n) <span class="keyword">yield</span> Random.nextInt(n)</div><div class="line">  array.toArray</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">def</span> randomArray2(n: Int) :Array[Int] = {</div><div class="line">  <span class="keyword">val</span> array = <span class="keyword">for</span>( i&lt;- <span class="number">0</span> to n) <span class="keyword">yield</span> (random * n).toInt</div><div class="line">  array.toArray</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>3.2</strong><br>编写一个循环，将整数数组中相邻的元素置换。例如,Array(1,2,3,4,5)经过置换后变为Array(2,1,4,3,5)</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> arrayChange(array: Array[Int]) :Array[Int] = {</div><div class="line">  <span class="keyword">if</span>(array == <span class="keyword">null</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span></div><div class="line"></div><div class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until array.length <span class="keyword">if</span> i % <span class="number">2</span> ==<span class="number">0</span> && i &gt; <span class="number">0</span>){</div><div class="line">    <span class="keyword">val</span> tmp = array(i-<span class="number">1</span>)</div><div class="line">    array(i-<span class="number">1</span>) = array(i)</div><div class="line">    array(i) = tmp</div><div class="line">  }</div><div class="line">  array</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">def</span> arrayChange2(arr: Array[Int]) :Array[Int] = {</div><div class="line">  <span class="keyword">val</span> t = arr.toBuffer</div><div class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until (t.length,<span class="number">2</span>) <span class="keyword">if</span> i + <span class="number">1</span> &lt; t.length){</div><div class="line">    <span class="keyword">val</span> a = t(i)</div><div class="line">    <span class="keyword">val</span> b = t(i + <span class="number">1</span>)</div><div class="line">    t.remove(i,<span class="number">2</span>)</div><div class="line">    t.insert(i,b)</div><div class="line">    t.insert(i + <span class="number">1</span>,a)</div><div class="line">  }</div><div class="line">  t.toArray</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>3.3</strong><br>重复前一个练习，不过这一次生成一个新的值交换过的数组。用for/yield</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> arrayChange(array: Array[Int]) :Array[Int] = {</div><div class="line">  <span class="keyword">if</span>(array == <span class="keyword">null</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span></div><div class="line"></div><div class="line">  <span class="keyword">val</span> length = array.length</div><div class="line">  <span class="keyword">var</span> flag = <span class="keyword">true</span></div><div class="line">  <span class="keyword">val</span> newArray = <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until length <span class="keyword">if</span> flag) <span class="keyword">yield</span>{</div><div class="line">    <span class="keyword">var</span> item = <span class="number">0</span></div><div class="line">    <span class="keyword">if</span>(i+<span class="number">1</span> &gt;= length){</div><div class="line">      flag = <span class="keyword">false</span></div><div class="line">    }</div><div class="line">    <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>){</div><div class="line">      item = array(i+<span class="number">1</span>)</div><div class="line">    }<span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">1</span>){</div><div class="line">      item = array(i-<span class="number">1</span>)</div><div class="line">    }</div><div class="line">    item</div><div class="line">  }</div><div class="line">  newArray.toArray</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>3.4</strong><br>给定一个整数数组，产生一个新的数组，包含元数组中的所有正值，以原有顺序排列，之后的元素是所有零或负值，以原有顺序排列</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> sortArray(array:Array[Int]):Array[Int] = {</div><div class="line">  <span class="keyword">val</span> newArrayBuffer = <span class="keyword">new</span> ArrayBuffer[Int]()</div><div class="line">  <span class="keyword">val</span> positiveIndex = <span class="keyword">for</span>(i &lt;- <span class="number">0</span> to array.length <span class="keyword">if</span> array(i) &gt; <span class="number">0</span> ) <span class="keyword">yield</span> {array(i)}</div><div class="line">  newArrayBuffer ++= positiveIndex.toBuffer</div><div class="line">  newArrayBuffer ++= (<span class="keyword">for</span>(i &lt;- <span class="number">0</span> to array.length <span class="keyword">if</span> !positiveIndex.contains(i)) <span class="keyword">yield</span>{array(i)}).toBuffer</div><div class="line">  newArrayBuffer.toArray</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">def</span> sortArray2(array:Array[Int]):Array[Int] = {</div><div class="line">  <span class="keyword">val</span> a = ArrayBuffer[Int]()</div><div class="line">  <span class="keyword">val</span> b = ArrayBuffer[Int]()</div><div class="line">  array.foreach(arg =&gt; <span class="keyword">if</span>(arg &gt; <span class="number">0</span>) a += arg <span class="keyword">else</span> b += arg)</div><div class="line">  a ++= b</div><div class="line">  a.toArray</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">def</span> sortArray3(array:Array[Int]):Array[Int] = {</div><div class="line">  <span class="keyword">val</span> a = array.filter(_&gt;<span class="number">0</span>).map(_*<span class="number">1</span>)</div><div class="line">  <span class="keyword">val</span> b = array.filter(_&lt;=<span class="number">0</span>).map(_*<span class="number">1</span>)</div><div class="line">  <span class="keyword">var</span> c = a.toBuffer</div><div class="line">  c ++= b.toBuffer</div><div class="line">  c.toArray</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>3.5</strong><br>如何计算Array[Double]的平均值</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> avgArray(array:Array[Double]):Double={</div><div class="line">  array.sum/array.length</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>3.6</strong><br>如何重新组织Array[Int]的元素将他们以反序排列？对于ArrayBuffer[Int]你又会怎么做呢？</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> reverseArray(arr:Array[Int]):Array[Int]={</div><div class="line">  arr.reverse</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>3.7</strong><br>编写一段代码，产出数组中的所有值，去掉重复项。(提示：查看Scaladoc)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> removeArray1(arr:Array[Int]):Array[Int]={</div><div class="line">  <span class="keyword">val</span> t = arr.toBuffer</div><div class="line">  <span class="keyword">val</span> idx =(<span class="keyword">for</span>(i &lt;- <span class="number">0</span> until t.length <span class="keyword">if</span> t(i) &lt; <span class="number">0</span>) <span class="keyword">yield</span> { i }).reverse.toBuffer</div><div class="line">  idx.trimEnd(<span class="number">1</span>)</div><div class="line">  idx.foreach(arg =&gt; t.remove(arg))</div><div class="line">  t.toArray</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">def</span> removeArray2(array:Array[Int]):Array[Int]={</div><div class="line">  <span class="keyword">val</span> arr = array.toBuffer</div><div class="line">  <span class="keyword">var</span> first = <span class="keyword">true</span></div><div class="line">  <span class="keyword">val</span> indexes = <span class="keyword">for</span>(i &lt;- <span class="number">0</span> until arr.length <span class="keyword">if</span> first || arr(i) &gt;= <span class="number">0</span>) <span class="keyword">yield</span>{</div><div class="line">    <span class="keyword">if</span>(arr(i) &lt; <span class="number">0</span>) first = <span class="keyword">false</span>;i</div><div class="line">  }</div><div class="line">  <span class="keyword">for</span>(j &lt;- <span class="number">0</span> until indexes.length) arr(j) = arr(indexes(j))</div><div class="line">  arr.trimEnd(arr.length - indexes.length)</div><div class="line">  arr.toArray</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">def</span> performance():Unit={</div><div class="line">  <span class="keyword">val</span> array = Array(<span class="number">1</span>,-<span class="number">2</span>,<span class="number">3</span>,<span class="number">55</span>,<span class="number">3</span>,-<span class="number">4</span>,-<span class="number">6</span>,-<span class="number">2</span>,-<span class="number">1</span>,<span class="number">55</span>,-<span class="number">3</span>,<span class="number">5</span>)</div><div class="line">  <span class="keyword">val</span> startTime1 = System.currentTimeMillis()</div><div class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> to <span class="number">10000</span>) {</div><div class="line">    removeArray1(array)</div><div class="line">  }</div><div class="line">  <span class="keyword">val</span> endTime1 = System.currentTimeMillis()</div><div class="line">  <span class="keyword">val</span> startTime2 = System.currentTimeMillis()</div><div class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> to <span class="number">10000</span>) {</div><div class="line">    <span class="keyword">val</span> result2 = removeArray2(array)</div><div class="line">  }</div><div class="line">  <span class="keyword">val</span> endTime2 = System.currentTimeMillis()</div><div class="line">  println(<span class="string">"removeArray1 cost:"</span>+(endTime1-startTime1))</div><div class="line">  println(<span class="string">"removeArray2 cost:"</span>+(endTime2-startTime2))</div><div class="line">  <span class="comment">//10000次 201：81</span></div><div class="line">}</div><div class="line"><span class="javadoc">/**</span></div><div class="line">   * scala&gt; performance</div><div class="line">removeArray1 cost:231</div><div class="line">removeArray2 cost:163</div><div class="line"></div><div class="line">scala&gt; performance</div><div class="line">removeArray1 cost:16</div><div class="line">removeArray2 cost:14</div><div class="line"></div><div class="line">scala&gt; performance</div><div class="line">removeArray1 cost:12</div><div class="line">removeArray2 cost:6</div><div class="line"></div><div class="line">scala&gt; performance</div><div class="line">removeArray1 cost:13</div><div class="line">removeArray2 cost:7</div><div class="line"></div><div class="line">scala&gt; performance</div><div class="line">removeArray1 cost:18</div><div class="line">removeArray2 cost:5</div><div class="line">   */</div></pre></td></tr></table></figure>

<p><strong>3.9</strong><br>创建一个由java.util.TimeZone.getAvailableIDs返回ide时区集合，判断条件是它们在美洲。去掉”America/“前缀并排序</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> sortAmericaTimeZone():Unit = {</div><div class="line">  <span class="keyword">val</span> array = java.util.TimeZone.getAvailableIDs</div><div class="line">  <span class="keyword">val</span> result = array.filter(_.startsWith(<span class="string">"America"</span>)).map(_.replace(<span class="string">"America/"</span>,<span class="string">""</span>)).sorted</div><div class="line">  result.foreach(println(_))</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>3.10</strong><br>引入java.awt.datatransfer.并构建一个类型为SystemFlavorMap类型的对象:<br>  val flavors = SystemFlavorMap.getDefaultFlavorMap().asInstanceOf[SystemFlavorMap]<br>  然后以DataFlavor.imageFlavor为参数调用getNativesForFlavor方法，以Scala缓冲保存返回值。<br> (为什么用这样一个晦涩难懂的类？因为在Java标准库中很难找到使用java.util.List的代码)</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.awt.datatransfer.{DataFlavor, SystemFlavorMap}</div><div class="line"><span class="keyword">import</span> collection.JavaConversions.asScalaBuffer</div><div class="line"><span class="keyword">import</span> scala.collection.mutable</div><div class="line"></div><div class="line"><span class="keyword">def</span> test():Unit = {</div><div class="line">  <span class="keyword">val</span> flavors = SystemFlavorMap.getDefaultFlavorMap().asInstanceOf[SystemFlavorMap]</div><div class="line">  <span class="keyword">val</span> res:mutable.Buffer[String] = flavors.getNativesForFlavor(DataFlavor.imageFlavor)</div><div class="line">  println(res)</div><div class="line">}</div></pre></td></tr></table></figure>

<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《快学scala》习题解答-第二章-控制结构和函数]]></title>
    <link href="http://vernonzheng.com/2015/01/20/%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E4%B9%A0%E9%A2%98%E8%A7%A3%E7%AD%94-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84%E5%92%8C%E5%87%BD%E6%95%B0/"/>
    <id>http://vernonzheng.com/2015/01/20/《快学scala》习题解答-第二章-控制结构和函数/</id>
    <published>2015-01-20T14:46:42.000Z</published>
    <updated>2015-02-08T07:10:00.000Z</updated>
    <content type="html"><![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第二章_控制结构与函数">第二章 控制结构与函数</h2>
<p><strong>2.1</strong><br>一个数字如果为正数，则它的signum为1;如果是负数,则signum为-1;如果为0,则signum为0.编写一个函数来计算这个值。</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> sigNum(num: Int):Int = {</div><div class="line">	<span class="keyword">if</span> (num &gt; <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">0</span>) -<span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></div><div class="line">}</div><div class="line"></div><div class="line">println(signum(<span class="number">10000</span>));</div><div class="line">println(signum(-<span class="number">22</span>));</div><div class="line">println(signum(<span class="number">0</span>));</div></pre></td></tr></table></figure>

<p><strong>2.2</strong><br>一个空的块表达式{}的值是什么？类型是什么？</p>
<p>答：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scala&gt; val x = {}</div><div class="line">x: Unit = ()</div></pre></td></tr></table></figure>

<p><strong>2.3</strong><br>指出在Scala中何种情况下赋值语句x=y=1是合法的。(提示：给x找个合适的类型定义)</p>
<p>答：<br>因为赋值语句的值是Unit型，所以x可定义为Unit型。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="keyword">var</span> y = <span class="number">5</span></div><div class="line">y: Int = <span class="number">5</span></div><div class="line"></div><div class="line">scala&gt; <span class="keyword">var</span> x = {}</div><div class="line">x: Unit = ()</div><div class="line"></div><div class="line">scala&gt; x = y= <span class="number">1</span></div><div class="line">x: Unit = ()</div></pre></td></tr></table></figure>

<p><strong>2.4</strong><br>针对下列Java循环编写一个Scala版本:<br> for(int i=10;i&gt;=0;i—) System.out.println(i);</p>
<p>答：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="keyword">for</span>(i &lt;- <span class="number">0</span> to <span class="number">10</span> reverse) println(i)</div><div class="line">warning: there was one feature warning; re-run <span class="keyword">with</span> -feature <span class="keyword">for</span> details</div><div class="line"><span class="number">10</span></div><div class="line"><span class="number">9</span></div><div class="line"><span class="number">8</span></div><div class="line"><span class="number">7</span></div><div class="line"><span class="number">6</span></div><div class="line"><span class="number">5</span></div><div class="line"><span class="number">4</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">0</span></div></pre></td></tr></table></figure>

<p><strong>2.5</strong><br>编写一个过程countdown(n:Int)，打印从n到0的数字。</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="keyword">def</span> countdown(n:Int){</div><div class="line">         <span class="keyword">for</span>(i &lt;- <span class="number">0</span> to n reverse){</div><div class="line">           println(i)</div><div class="line">         }</div><div class="line">       }</div><div class="line">warning: there was one feature warning; re-run <span class="keyword">with</span> -feature <span class="keyword">for</span> details</div><div class="line">countdown: (n: Int)Unit</div><div class="line"></div><div class="line">scala&gt; countdown(<span class="number">2</span>)</div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">0</span></div></pre></td></tr></table></figure>

<p><strong>2.6</strong><br>编写一个for循环,计算字符串中所有字母的Unicode代码的乘积。举例来说，”Hello”中所有字符串的乘积为9415087488L</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="keyword">def</span> test(str:String):Long = {</div><div class="line">         <span class="keyword">var</span> result:Long = <span class="number">1</span></div><div class="line">         <span class="keyword">for</span>(i &lt;- str) result *= i</div><div class="line">         result</div><div class="line">       }</div><div class="line">test: (str: String)Long</div><div class="line"></div><div class="line">scala&gt; test(<span class="string">"oh,yeah"</span>)</div><div class="line">res5: Long = <span class="number">62621117315328</span></div></pre></td></tr></table></figure>

<p><strong>2.7</strong><br>同样是解决前一个练习的问题，但这次不使用循环。（提示：在Scaladoc中查看StringOps）</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> test(str:String):Long = {</div><div class="line">  <span class="keyword">var</span> result:Long = <span class="number">1</span></div><div class="line">  str.foreach( ch =&gt; {result *= (ch.toLong)})</div><div class="line">  result</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>2.8</strong><br>编写一个函数product(s:String), 计算前面习题中提到的乘积。</p>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> product(str:String):Long = {</div><div class="line">  <span class="keyword">var</span> result:Long = <span class="number">1</span></div><div class="line">  str.foreach( result *= _.toLong )</div><div class="line">  result</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>2.9</strong><br>把前一个练习中的函数改成递归函数。</p>
<p>答:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> product(str:String):Long = {</div><div class="line">  <span class="keyword">var</span> result:Long = <span class="number">1</span></div><div class="line">  <span class="keyword">if</span> (str.length==<span class="number">1</span>)</div><div class="line">    result = str.head.toLong</div><div class="line">  <span class="keyword">else</span></div><div class="line">    result = str.head.toLong * product(str.tail)</div><div class="line">  result</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>2.10</strong><br>编写函数计算x^n, 其中n为整数。使用如下的递归定义：</p>
<ul>
<li>x^n = y^2,如果</li>
<li>x^n = x*x^(n-1)</li>
<li>x^0 = 1</li>
<li>x^n = 1/x^(-n)</li>
</ul>
<p>答：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> getPower(x:Double, n:Int):Double = {</div><div class="line">  <span class="keyword">if</span> (n == <span class="number">0</span> ) <span class="number">1</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( n&gt;<span class="number">0</span> && n % <span class="number">2</span> != <span class="number">0</span> ) x * getPower(x, n-<span class="number">1</span>)</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;<span class="number">0</span> && n % <span class="number">2</span> == <span class="number">0</span> ) getPower (x, n/<span class="number">2</span>) * getPower (x, n/<span class="number">2</span>)</div><div class="line">  <span class="keyword">else</span> <span class="number">1</span>/getPower( x, -n) </div><div class="line">}</div></pre></td></tr></table></figure>

<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><]]>
    </summary>
    
      <category term="scala" scheme="http://vernonzheng.com/tags/scala/"/>
    
      <category term="习题答案" scheme="http://vernonzheng.com/tags/%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88/"/>
    
      <category term="scala" scheme="http://vernonzheng.com/categories/scala/"/>
    
  </entry>
  
</feed>
