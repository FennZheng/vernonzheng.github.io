<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.3"/>


    <meta name="description" content="tech | life | thiking | note" />



  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="Vern Zheng" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/img/favicon.ico?v=0.4.3" />



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    analytics: {
      google: ''
    },
    sidebar: 'post'
  };
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?1c6aeb80f79b63b35b25a0e55ca39b3c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <title> Vern Zheng </title>
</head>

<body>
<!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">Vern Zheng</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
     
    
      
      <li class="menu-item menu-item-home">
        <a href="/">
          <i class="menu-item-icon icon-home"></i> <br />
          Home
        </a>
      </li>
    
      
      <li class="menu-item menu-item-categories">
        <a href="/categories">
          <i class="menu-item-icon icon-categories"></i> <br />
          Categories
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="/archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          Archives
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        <a href="/tags">
          <i class="menu-item-icon icon-tags"></i> <br />
          Tags
        </a>
      </li>
    
      
      <li class="menu-item menu-item-about">
        <a href="/about">
          <i class="menu-item-icon icon-about"></i> <br />
          About
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <div id="posts" class="posts-expand">
    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/03/19/《快学scala》习题解答-第十九章-解析/">
                《快学scala》习题解答-第十九章-解析
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          Posted on 2015-03-19
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; In
            
              <a href="/categories/scala/">scala</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/03/19/《快学scala》习题解答-第十九章-解析/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/03/19/《快学scala》习题解答-第十九章-解析/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第十九章_解析">第十九章 解析</h2>
<p><strong>19.1</strong><br>为算术表达式求值器添加/和%操作符。</p>
<p><strong>19.2</strong><br>为算术表达式求值器添加^操作符。在数学运算当中，^应该比乘法的优先级更高，并且它应该是右结合的。也就是说，4^2^3应该得到4^(2^3)，即65536。</p>
<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/02/15/《快学scala》习题解答-第二十章-Actor/">
                《快学scala》习题解答-第二十章-Actor
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          Posted on 2015-02-15
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; In
            
              <a href="/categories/scala/">scala</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/02/15/《快学scala》习题解答-第二十章-Actor/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/02/15/《快学scala》习题解答-第二十章-Actor/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第二十章_Actor">第二十章 Actor</h2>
<p><strong>20.1</strong><br>编写一个程序，生成由n个随机数组成的数组（其中n是一个很大的值，比如1000000），然后通过将工作分发给多个actor的同时计算这些数的平均值，每个actor计算区间内的值之和，将结果发送给一个能组合出结果的actor。<br>如果你在双核或四核处理器上运行这个程序，和单线程的解决方案相比，会快多少？<br>双核上差不多</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.actors.Actor</div><div class="line"><span class="keyword">import</span> scala.actors.Actor._</div><div class="line"><span class="keyword">val</span> taskCount = Runtime.getRuntime().availableProcessors()</div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">SumPart</span><span class="params">(items:Array[Int],partCount:Int)</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">CollectSum</span><span class="params">(sum:Int,partCount:Int)</span></span></div><div class="line"></div><div class="line"><span class="keyword">def</span> randomArray(num:Int):Array[Int] = {</div><div class="line">  <span class="keyword">val</span> result = <span class="keyword">new</span> Array[Int](num)</div><div class="line">  <span class="keyword">for</span>(i &lt;- <span class="number">0</span> to num-<span class="number">1</span>) {</div><div class="line">    result(i) = (Math.random() * num).toInt</div><div class="line">  }</div><div class="line">  result</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">val</span> ReduceActor = actor {</div><div class="line">  <span class="keyword">var</span> result = <span class="number">0</span>D</div><div class="line">  <span class="keyword">var</span> receiveCount = <span class="number">0</span></div><div class="line">  loop{</div><div class="line">    receive{</div><div class="line">      <span class="keyword">case</span> CollectSum(sum,partCount)=&gt;</div><div class="line">        receiveCount += <span class="number">1</span></div><div class="line">        result += sum</div><div class="line">        println(sum)</div><div class="line">        <span class="keyword">if</span>(receiveCount&gt;=partCount){</div><div class="line">          result = result/partCount</div><div class="line">          println(<span class="string">"Actor result:"</span>+result)</div><div class="line">          exit()</div><div class="line">        }</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div><div class="line"><span class="keyword">val</span> MapActor = actor{</div><div class="line">  loop{</div><div class="line">    react{</div><div class="line">      <span class="keyword">case</span> SumPart(items,partCount) =&gt;</div><div class="line">        ReduceActor ! CollectSum(items.sum, partCount)</div><div class="line">        exit()</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">def</span> actorMain(num:Int, partCount:Int) = {</div><div class="line">  <span class="keyword">val</span> array = randomArray(num)</div><div class="line">  <span class="keyword">val</span> startTime = System.currentTimeMillis()</div><div class="line">  <span class="keyword">var</span> range = <span class="number">1</span></div><div class="line">  <span class="keyword">if</span>(array.length&gt;=partCount)</div><div class="line">    range = array.length/partCount</div><div class="line">  <span class="keyword">var</span> start = <span class="number">0</span></div><div class="line">  <span class="keyword">var</span> end = <span class="number">0</span></div><div class="line">  <span class="keyword">var</span> flag = <span class="keyword">false</span></div><div class="line">  MapActor.start()</div><div class="line">  <span class="keyword">while</span>(!flag){</div><div class="line">    <span class="keyword">if</span>(end+range&gt;=array.length-<span class="number">1</span>){</div><div class="line">      end = array.length - <span class="number">1</span></div><div class="line">      flag = <span class="keyword">true</span></div><div class="line">    }<span class="keyword">else</span>{</div><div class="line">      end = end+range</div><div class="line">    }</div><div class="line">    MapActor ! SumPart(array.slice(start,end),partCount)</div><div class="line">    start = start+range</div><div class="line">  }</div><div class="line">  println(<span class="string">"Actor cost:"</span>+(System.currentTimeMillis()-startTime))</div><div class="line">}</div><div class="line"><span class="keyword">def</span> main(num:Int)={</div><div class="line">  <span class="keyword">val</span> array = randomArray(num)</div><div class="line">  <span class="keyword">val</span> startTime = System.currentTimeMillis()</div><div class="line">  println(<span class="string">"No-Actor result:"</span>+array.sum/array.length)</div><div class="line">  println(<span class="string">"No-Actor cost:"</span>+(System.currentTimeMillis()-startTime))</div><div class="line">}</div><div class="line"><span class="keyword">for</span>(i&lt;- <span class="number">1</span> to <span class="number">20</span>) {</div><div class="line">  actorMain(<span class="number">100000</span>, taskCount)</div><div class="line">  actorMain(<span class="number">100000</span>, <span class="number">100</span>)</div><div class="line">}</div><div class="line"><span class="keyword">for</span>(i&lt;- <span class="number">1</span> to <span class="number">20</span>) {</div><div class="line">  main(<span class="number">100000</span>)</div><div class="line">  main(<span class="number">100000</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>20.2</strong><br>编写一个程序，读取一个大型图片到BufferedImage对象中，用javax.imageio.ImangeIo.read方法。使用多个actor，每一个actor对图形的某一个条带区域进行反色处理。当所有条带都被反色后，输出结果。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.awt.image.BufferedImage</div><div class="line"><span class="keyword">import</span> java.io.File</div><div class="line"><span class="keyword">import</span> javax.imageio.ImageIO</div><div class="line"><span class="keyword">import</span> scala.actors.Actor</div><div class="line"><span class="keyword">import</span> scala.actors.Actor._</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">InversePart</span><span class="params">(bufImage:BufferedImage, imageRGB:Array[Int], start:Int, end:Int)</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">WriteImage</span><span class="params">(result:BufferedImage, imageRGB:Array[Int])</span></span></div><div class="line"></div><div class="line"><span class="keyword">val</span> inputPng = <span class="keyword">new</span> File(<span class="string">"./pic.png"</span>)</div><div class="line"><span class="keyword">val</span> outPng = <span class="keyword">new</span> File(<span class="string">"./pic_reverse.png"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageActor</span><span class="params">(var count:Int = 0)</span> <span class="keyword">extends</span> <span class="title">Actor</span></span>{</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> act()={</div><div class="line">    loop{</div><div class="line">      react{</div><div class="line">        <span class="keyword">case</span> InversePart(bufImage, imageRGB, start, end) =&gt;</div><div class="line">          <span class="keyword">for</span>(i &lt;- start to end){</div><div class="line">            imageRGB(i) = imageRGB(i)^<span class="number">0xffffffff</span></div><div class="line">          }</div><div class="line">          self ! WriteImage(bufImage, imageRGB)</div><div class="line">        <span class="keyword">case</span> WriteImage(bufImage, imageRGB) =&gt;</div><div class="line">          count -= <span class="number">1</span></div><div class="line">          <span class="keyword">if</span>(count==<span class="number">1</span>) {</div><div class="line">            <span class="keyword">val</span> width = bufImage.getWidth</div><div class="line">            <span class="keyword">val</span> height = bufImage.getHeight</div><div class="line">            <span class="keyword">val</span> resultImage = <span class="keyword">new</span> BufferedImage(bufImage.getWidth, bufImage.getHeight, BufferedImage.TYPE_INT_RGB)</div><div class="line">            resultImage.setRGB(<span class="number">0</span>, <span class="number">0</span>, width, height, imageRGB, <span class="number">0</span>, width)</div><div class="line">            ImageIO.write(resultImage , <span class="string">"png"</span>, outPng)</div><div class="line">            exit()</div><div class="line">          }</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div><div class="line"><span class="keyword">def</span> inverse = {</div><div class="line">  <span class="keyword">val</span> bufImage = ImageIO.read(inputPng)</div><div class="line">  <span class="keyword">if</span> (bufImage != <span class="keyword">null</span>) {</div><div class="line">    <span class="keyword">val</span> width = bufImage.getWidth</div><div class="line">    <span class="keyword">val</span> height = bufImage.getHeight</div><div class="line">    <span class="keyword">val</span> imageRGB = <span class="keyword">new</span> Array[Int](width * height)</div><div class="line">    bufImage.getRGB(<span class="number">0</span>, <span class="number">0</span>, width, height, imageRGB, <span class="number">0</span>, width)</div><div class="line">    <span class="keyword">var</span> step = <span class="number">5</span></div><div class="line">    <span class="keyword">var</span> start = <span class="number">0</span></div><div class="line">    <span class="keyword">var</span> end = <span class="number">0</span></div><div class="line">    <span class="keyword">var</span> flag = <span class="keyword">false</span></div><div class="line">    <span class="keyword">val</span> count = imageRGB.length / step + <span class="number">1</span></div><div class="line">    <span class="keyword">val</span> imageActor = <span class="keyword">new</span> ImageActor(count)</div><div class="line">    imageActor.start()</div><div class="line">    <span class="keyword">while</span> (!flag) {</div><div class="line">      <span class="keyword">if</span> (end + step &gt;= imageRGB.length) {</div><div class="line">        end = imageRGB.length - <span class="number">1</span></div><div class="line">        flag = <span class="keyword">true</span></div><div class="line">      } <span class="keyword">else</span> {</div><div class="line">        end += step</div><div class="line">      }</div><div class="line">      imageActor ! InversePart(bufImage, imageRGB, start, end)</div><div class="line">      start += step</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div><div class="line">inverse</div></pre></td></tr></table></figure>

<p><strong>20.3</strong><br>编写一个程序，对给定目录下所有子目录的所有文件中匹配某个给定的正则表达式的单词进行计数。对每一个文件各采用一个actor，另外再加上一个actor用来遍历所有子目录，还有一个actor将结果汇总到一起。</p>
<p><strong>20.4</strong><br>修改前一个练习的程序，显示所有匹配的单词。</p>
<p><strong>20.5</strong><br>修改前一个练习的程序，显示所有匹配的单词，每一个都带有一个包含它的文件的列表。</p>
<p><strong>20.6</strong><br>编写一个程序，构造100个actor，这些actor使用while(true)/receive循环，当接收到‘Hello消息时，调用println(Thread.currentThread)，同时构造另外100个actor，他们做同样的事，不过采用loop/react。将它们全部启动，给它们全部都发送一个消息。第一种actor占用了多少线程，第二种actor占用了多少线程？</p>
<p><strong>20.7</strong><br>给练习3的程序添加一个监管actor，监控读取文件的actor并记录任何因IOException退出的actor。尝试通过移除那些计划要被处理的文件的方式触发IOException。</p>
<p><strong>20.8</strong><br>展示一个基于actor的程序是如何在发送同步消息时引发死锁的。</p>
<p><strong>20.9</strong><br>做出一个针对练习3的程序的有问题的实现，在这个实现当中，actor将更新一个共享的计数器。你能展现出程序运行是错误的吗？</p>
<p><strong>20.10</strong><br>重写练习1的程序，使用消息通道来进行通信。</p>
<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/02/11/《快学scala》习题解答-第十八章-高级类型/">
                《快学scala》习题解答-第十八章-高级类型
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          Posted on 2015-02-11
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; In
            
              <a href="/categories/scala/">scala</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/02/11/《快学scala》习题解答-第十八章-高级类型/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/02/11/《快学scala》习题解答-第十八章-高级类型/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第十八章_高级类型">第十八章 高级类型</h2>
<p><strong>18.1</strong><br>实现一个Bug类，对沿着水平线爬行的虫子建模。move方法向当前方向移动，turn方法让虫子转身，show方法打印出当前的位置。让这些方法可以被串接调用。例如：<br>bugsy.move(4).show().move(6).show().turn().move(5).show()<br>上述代码应显示4 10 5。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> _1801 {</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bug</span><span class="params">(var pos: Int = 0)</span> </span>{</div><div class="line">  <span class="keyword">var</span> forword: Int = <span class="number">1</span></div><div class="line"></div><div class="line">  <span class="keyword">def</span> move(up: Int):<span class="keyword">this</span>.<span class="keyword">type</span> = {</div><div class="line">    pos += forword * up</div><div class="line">    <span class="keyword">this</span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> show():<span class="keyword">this</span>.<span class="keyword">type</span> = {</div><div class="line">    print(pos + <span class="string">" "</span>)</div><div class="line">    <span class="keyword">this</span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> turn():<span class="keyword">this</span>.<span class="keyword">type</span> = {</div><div class="line">    forword = -forword</div><div class="line">    <span class="keyword">this</span></div><div class="line">  }</div><div class="line">}</div><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span> </span>{</div><div class="line">   <span class="keyword">val</span> bugsy = <span class="keyword">new</span> Bug</div><div class="line">   bugsy.move(<span class="number">4</span>).show().move(<span class="number">6</span>).show().turn().move(<span class="number">5</span>).show()</div><div class="line"> }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>18.2</strong><br>为前一个练习中的Bug类提供一个流利接口，达到能编写如下代码的效果：<br>bugsy move 4 and show and then move 6 and show turn around move 5 and show</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> _1802 {</div><div class="line">  <span class="comment">//非动词 non-verb</span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">then</span></span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">show</span></span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">around</span></span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bug</span><span class="params">(var pos: Int = 0)</span> </span>{</div><div class="line">  <span class="keyword">var</span> forword: Int = <span class="number">1</span></div><div class="line"></div><div class="line">  <span class="keyword">def</span> move(num: Int): <span class="keyword">this</span>.<span class="keyword">type</span> = { pos += num; <span class="keyword">this</span> }</div><div class="line">  <span class="keyword">def</span> and(obj: then.<span class="keyword">type</span>): <span class="keyword">this</span>.<span class="keyword">type</span> = <span class="keyword">this</span></div><div class="line">  <span class="keyword">def</span> and(obj: show.<span class="keyword">type</span>): <span class="keyword">this</span>.<span class="keyword">type</span> = { print(pos + <span class="string">" "</span>); <span class="keyword">this</span>}</div><div class="line">  <span class="keyword">def</span> turn(obj: around.<span class="keyword">type</span>): <span class="keyword">this</span>.<span class="keyword">type</span> = { pos = <span class="number">0</span>; <span class="keyword">this</span>}</div><div class="line">}</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span> </span>{</div><div class="line">  <span class="keyword">val</span> bugsy = <span class="keyword">new</span> Bug</div><div class="line">  bugsy move <span class="number">4</span> and show and then move <span class="number">6</span> and show turn around move <span class="number">5</span> and show</div><div class="line">}</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>18.3</strong><br>完成18.1节中的流利接口，以便我们可以做出如下调用：<br>book set Title to “Scala for the Impatient” set Author to “Cay Horstmann”</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Document</span> </span>{</div><div class="line">  <span class="keyword">var</span> title: String = <span class="string">""</span></div><div class="line">  <span class="keyword">var</span> author: String = <span class="string">""</span></div><div class="line">  <span class="keyword">def</span> setTitle(title: String):<span class="keyword">this</span>.<span class="keyword">type</span> = {<span class="keyword">this</span>.title = title; <span class="keyword">this</span>}</div><div class="line">  <span class="keyword">def</span> setAuthor(author: String):<span class="keyword">this</span>.<span class="keyword">type</span> = {<span class="keyword">this</span>.author= author; <span class="keyword">this</span>}</div><div class="line">}</div><div class="line"><span class="comment">//可枚举</span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Title</span></span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Author</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">extends</span> <span class="title">Document</span></span>{</div><div class="line">  <span class="keyword">private</span> <span class="keyword">var</span> useNextArgAs:Any = <span class="keyword">null</span></div><div class="line">  <span class="keyword">def</span> set(obj: Any): <span class="keyword">this</span>.<span class="keyword">type</span> = {useNextArgAs = obj; <span class="keyword">this</span>}</div><div class="line">  <span class="keyword">def</span> to(obj:String) = {</div><div class="line">    useNextArgAs <span class="keyword">match</span>{</div><div class="line">      <span class="keyword">case</span> Title =&gt; setTitle(obj)</div><div class="line">      <span class="keyword">case</span> Author =&gt; setAuthor(obj)</div><div class="line">      <span class="keyword">case</span> _ =&gt;</div><div class="line">    }</div><div class="line">    <span class="keyword">this</span></div><div class="line">  }</div><div class="line">}</div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">App</span> </span>{</div><div class="line">  <span class="keyword">val</span> book = <span class="keyword">new</span> Book</div><div class="line">  book set Title to <span class="string">"Scala for the Impatient"</span> set Author to <span class="string">"Cay Horstmann"</span></div><div class="line">  println(book.title)</div><div class="line">  println(book.author)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>18.4</strong><br>实现18.2节中被嵌套在Network类中的Member类的equals方法。两个成员要想相等，必须属于同一个网络。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.collection.mutable.ArrayBuffer</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Network</span> </span>{</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Member</span><span class="params">(val name: String)</span> </span>{</div><div class="line">    <span class="keyword">val</span> contacts = <span class="keyword">new</span> ArrayBuffer[Member]</div><div class="line"></div><div class="line">    <span class="keyword">def</span> canEqual(other: Any): Boolean = other.isInstanceOf[Member]</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="keyword">def</span> equals(other: Any): Boolean = other <span class="keyword">match</span> {</div><div class="line">      <span class="keyword">case</span> that: Member =&gt;</div><div class="line">        (that canEqual <span class="keyword">this</span>) &&</div><div class="line">          name == that.name</div><div class="line">      <span class="keyword">case</span> _ =&gt; <span class="keyword">false</span></div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keyword">private</span> <span class="keyword">val</span> members = <span class="keyword">new</span> ArrayBuffer[Member]</div><div class="line"></div><div class="line">  <span class="keyword">def</span> join(name: String) = {</div><div class="line">    <span class="keyword">val</span> m = <span class="keyword">new</span> Member(name)</div><div class="line">    members += m</div><div class="line">    m</div><div class="line">  }</div><div class="line"></div><div class="line">}</div><div class="line"><span class="keyword">val</span> network1 = <span class="keyword">new</span> Network().join(<span class="string">"1"</span>)</div><div class="line"><span class="keyword">val</span> network2 = <span class="keyword">new</span> Network().join(<span class="string">"1"</span>)</div><div class="line">println(network1.equals(network2))</div></pre></td></tr></table></figure>

<p><strong>18.5</strong><br>考虑如下类型别名<br>type NetworkMember = n.Member forSome { val n : Network }<br>和函数<br>def process(m1: NetworkMember, m2: NetworkMember) = (m1, m2)<br>这与18.8节中的process函数有什么不同？</p>
<p>与18.8不同，允许不同网络作为参数</p>
<p><strong>18.6</strong><br>Scala类库中的Either类型可以被用于要么返回结果，要么返回某种失败信息的算法。编写一个带有两个参数的函数：一个已排序整数数组和一个整数值。要么返回该整数值在数组中的下标，要么返回最接近该值的元素的下标。使用一个中置类型作为返回类型。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> getIndex(arr: Seq[Int], v: Int): Int Either Int = {</div><div class="line">  <span class="keyword">if</span> (arr.contains(v)) {</div><div class="line">    Left(arr.indexOf(v))</div><div class="line">  } <span class="keyword">else</span> {</div><div class="line">    Right(arr.indexOf(arr.reduce((a,b) =&gt; <span class="keyword">if</span> (math.abs(v - a) &gt; math.abs(v - b)) b <span class="keyword">else</span> a)))</div><div class="line">  }</div><div class="line">}</div><div class="line">println(getIndex(Seq(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,-<span class="number">2</span>,-<span class="number">3</span>),<span class="number">1</span>))</div></pre></td></tr></table></figure>

<p><strong>18.7</strong><br>实现一个方法，接受任何具备如下方法的类的对象和一个处理该对象的函数。<br>调用该函数，并在完成或有任何异常发生时调用close方法。<br>def close(): Unit</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> tryWithClose[T&lt;:{<span class="keyword">def</span> close():Unit}](obj:T,func: T =&gt; Unit)={</div><div class="line">  <span class="keyword">try</span>{</div><div class="line">    func(obj)</div><div class="line">  }<span class="keyword">finally</span> {</div><div class="line">    obj.close()</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>18.8</strong><br>编写一个函数printValues，带有三个参数f、from和to，打印出所有给定区间范围内的输入值经过f计算后的结果。这里的f应该是任何带有接受Int产出Int的apply方法的对象。例如：<br>printValues((x: Int) =&gt; x*x, 3, 6) //将打印 9 16 25 36<br>printValues(Array(1, 1, 2, 3, 5, 8, 13, 21, 34, 55), 3, 6) //将打印 3 5 8 13</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> printValues(f:{<span class="keyword">def</span> apply(param:Int):Int}, from:Int, to:Int)={</div><div class="line">  <span class="keyword">for</span>(i &lt;- from to to) {</div><div class="line">    print(f.apply(i) + <span class="string">" "</span>)</div><div class="line">  }</div><div class="line">}</div><div class="line">printValues((x: Int) =&gt; x*x, <span class="number">3</span>, <span class="number">6</span>) <span class="comment">//将打印 9 16 25 36</span></div><div class="line">printValues(Array(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>), <span class="number">3</span>, <span class="number">6</span>) <span class="comment">//将打印 3 5 8 13</span></div></pre></td></tr></table></figure>

<p><strong>18.9</strong><br>考虑如下对物理度量建模的类：<br>abstract class Dim<a href="val value: Double, val name: String">T</a>{<br>    protected def create(v: Double): T<br>    def + (other: Dim[T]) = create(value + other.value)<br>    override def toString() = value + “ “ + name<br>}<br>以下是具体子类：<br>class Seconds(v: Double) extends Dim<a href="v," title="s">Seconds</a>{<br>    override def create(v: Double) = new Seconds(v)<br>}<br>但现在不清楚状况的人可能会定义<br>class Meters(v: Double) extends Dim<a href="v," title="m">Seconds</a>{<br>    override def create(v: Double) = new Seconds(v)<br>}<br>允许米（Meters）和秒（Seconds）相加。使用自身类型来防止发生这样的情况。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Dim</span>[<span class="title">T</span>]<span class="params">(val value: Double, val name: String)</span></span>{</div><div class="line">  <span class="keyword">this</span>: T =&gt;</div><div class="line">  <span class="keyword">protected</span> <span class="keyword">def</span> create(v: Double): T</div><div class="line">  <span class="keyword">def</span> + (other: Dim[T]) = create(value + other.value)</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> toString() = value + <span class="string">" "</span> + name</div><div class="line">}</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Seconds</span><span class="params">(v: Double)</span> <span class="keyword">extends</span> <span class="title">Dim</span>[<span class="title">Seconds</span>]<span class="params">(v, <span class="string">"s"</span>)</span></span>{</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> create(v: Double) = <span class="keyword">new</span> Seconds(v)</div><div class="line">}</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meters</span><span class="params">(v: Double)</span> <span class="keyword">extends</span> <span class="title">Dim</span>[<span class="title">Seconds</span>]<span class="params">(v, <span class="string">"m"</span>)</span></span>{</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> create(v: Double) = <span class="keyword">new</span> Seconds(v)</div><div class="line">}</div><div class="line"><span class="comment">//Meters can not extends Dim[Seconds] and compile fail</span></div></pre></td></tr></table></figure>

<p><strong>18.10</strong><br>自身类型通常可以被扩展自身的特质替代，但某些情况下使用自身类型会改变初始化和重写的顺序。构造出这样的一个示例。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">A</span> </span>{</div><div class="line">  <span class="keyword">def</span> sing() = <span class="string">"from a"</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">C</span> </span>{</div><div class="line">  <span class="keyword">this</span>: A =&gt;</div><div class="line">  <span class="keyword">val</span> w = sing + <span class="string">"from c"</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>{</div><div class="line">  <span class="keyword">this</span>: C =&gt;</div><div class="line">  <span class="keyword">val</span> k = w</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">val</span> b = <span class="keyword">new</span> B <span class="keyword">with</span> C <span class="keyword">with</span> A</div><div class="line">println(b.k)</div></pre></td></tr></table></figure>

<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/02/10/《快学scala》习题解答-第十七章-类型参数/">
                《快学scala》习题解答-第十七章-类型参数
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          Posted on 2015-02-10
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; In
            
              <a href="/categories/scala/">scala</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/02/10/《快学scala》习题解答-第十七章-类型参数/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/02/10/《快学scala》习题解答-第十七章-类型参数/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第十七章_类型参数">第十七章 类型参数</h2>
<p><strong>17.1</strong><br>定义一个不可变类Pair[T,S], 带一个swap方法，返回组件交换过位置的新对偶</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>[<span class="title">T</span>,<span class="title">S</span>]<span class="params">(val t:T,val s:S)</span></span>{</div><div class="line">  <span class="keyword">def</span> swap() = <span class="keyword">new</span> Pair(s,t)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>17.2</strong><br>定义一个可变类Pair[T]，带一个swap方法，交换对偶中组件的位置。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>[<span class="title">T</span>]<span class="params">(val s:T,val t:T)</span></span>{</div><div class="line">  <span class="keyword">def</span> swap() = <span class="keyword">new</span> Pair(t,s)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>17.3</strong><br>给定类Pair[T, S] ，编写一个泛型方法swap，接受对偶作为参数并返回组件交换过位置的新对偶。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>[<span class="title">T</span>,<span class="title">S</span>]<span class="params">(val t:T, val s:S)</span></span>{</div><div class="line">  <span class="keyword">def</span> swap[T,S](t:T,s:S) = <span class="keyword">new</span> Pair(s,t)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>17.4</strong><br>在17.3节中，如果我们想把Pair[Person]的第一个组件替换成Student，为什么不需要给replaceFirst方法定一个下界？</p>
<p>因为Student是Person的子类，是可以转成T类型的，不必定义下界</p>
<p><strong>17.5</strong><br>为什么RichInt实现的是Comparable[Int]而不是Comparable[RichInt]?</p>
<p>T &lt;% Comparable[T] ,是隐含参数转化的，T是Int的时候将自动调用RichInt中的Comparable[RichInt]</p>
<p><strong>17.6</strong><br>编写一个泛型方法middle，返回任何Iterable[T]的中间元素。举例来说，middle(“World”)应得到’r’。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> middle[T](iter:Iterable[T]):T={</div><div class="line">  <span class="keyword">val</span> seq = iter.toArray</div><div class="line">  seq(seq.length/<span class="number">2</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>17.7</strong><br>查看Iterable[+A]特质。哪些方法使用了类型参数A？为什么在这些方法中类型参数位于协变点？</p>
<p>如min, max, last 等。这些方法都会返回A类型，所以位于协变点。</p>
<p><strong>17.8</strong><br>在17.10节中，replaceFirst方法带有一个类型界定。为什么你不能对可变的Pair[T]定义一个等效的方法？<br>def replaceFirst<a href="newFirst: R" target="_blank" rel="external">R &gt;: T</a> { first = newFirst } //错误</p>
<p>因为first是子类，newFirst是超类，超类不能被赋值给子类。</p>
<p><strong>17.9</strong><br>在一个不可变类Pair[+T]中限制方法参数看上去可能有些奇怪。不过，先假定你可以在Pair[+T]定义<br>def replaceFirst(newFirst: T)<br>问题在于，该方法可能会被重写（以某种不可靠的方式）。构造出这样的一个示例。定义一个Pair[Double]的类型NastyDoublePair，重写replaceFirst方法，用newFirst的平方根来做新对偶。然后对实际类型为NastyDoublePair的Pair[Any]调用replaceFirst(“Hello”)。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Anyone resolve this, please contact me</span></div><div class="line"><span class="keyword">package</span> _1709 {</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>[+<span class="title">T</span>]<span class="params">(val t:T, val s:T)</span> </span>{</div><div class="line">  <span class="keyword">def</span> replaceFirst[T](newFirst: T) {}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NastyDoublePair</span>[<span class="title">Double</span>]<span class="params">(t1:Double, s1:Double)</span> <span class="keyword">extends</span> <span class="title">Pair</span>[<span class="title">Double</span>]<span class="params">(t1,s1)</span> </span>{</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> replaceFirst(newFirst: Double) ={</div><div class="line">    <span class="javadoc">/**</span></div><div class="line">     *  error: type mismatch;</div><div class="line">       found   : Double(in class NastyDoublePair)</div><div class="line">       required: scala.Double</div><div class="line">                 new NastyDoublePair(newFirst,math.sqrt(newFirst))</div><div class="line">     */</div><div class="line">    <span class="keyword">new</span> NastyDoublePair(newFirst,math.sqrt(newFirst))</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">test</span> <span class="keyword">extends</span> <span class="title">App</span> </span>{</div><div class="line">  <span class="keyword">val</span> p: Pair[Any] = <span class="keyword">new</span> NastyDoublePair(<span class="number">1.0</span>, <span class="number">2.0</span>)</div><div class="line">  p.replaceFirst(<span class="string">"Hello"</span>)</div><div class="line">}</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>17.10</strong><br>给定可变类Pair[S,T]，使用类型约束定义一个swap方法，当类型参数相同时可以被调用。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>[<span class="title">S</span>,<span class="title">T</span>]<span class="params">(val s:S, val t:T)</span></span>{</div><div class="line">  <span class="keyword">def</span> swap(implicit env: S =:= T) = <span class="keyword">new</span> Pair(t,s)</div><div class="line">}</div></pre></td></tr></table></figure>

<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/02/09/开源分布式配置中心选型/">
                开源分布式配置中心选型
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          Posted on 2015-02-09
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; In
            
              <a href="/categories/中间件/">中间件</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/02/09/开源分布式配置中心选型/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/02/09/开源分布式配置中心选型/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h1 id="一、目标">一、目标</h1>
<p>实现分布式配置中心：<br>（1）集中管理外部依赖的服务配置和服务内部配置<br>（2）提供web管理平台进行配置和查询<br>（3）支持服务注册与发现<br>（4）支持客户端拉取配置<br>（5）支持订阅与发布，配置变更主动通知到client，实时变更配置</p>
<p>备注：client为nodeJS，java等</p>
<h1 id="二、开源解决方案调研">二、开源解决方案调研</h1>
<h2 id="2-1_disconf">2.1 disconf</h2>
<p>百度开源<br>与spring集成的很好，有web管理，client只支持java。</p>
<h3 id="2-1-1_介绍">2.1.1 介绍</h3>
<p><a href="https://github.com/knightliao/disconf/wiki" target="_blank" rel="external">https://github.com/knightliao/disconf/wiki</a></p>
<h3 id="2-1-2_源码">2.1.2 源码</h3>
<p><a href="https://github.com/knightliao/disconf" target="_blank" rel="external">https://github.com/knightliao/disconf</a></p>
<h2 id="2-2_diamond">2.2 diamond</h2>
<p>阿里开源<br>阿里内部应用广泛，由http server(nameservers), diamond-server ，web组成，diamond-server连接同一个mysql，数据同步通过mysql dump文件同步（同步效率？），支持订阅发布，client只支持java。</p>
<h3 id="2-2-1_介绍">2.2.1 介绍</h3>
<p><a href="http://code.taobao.org/p/diamond/wiki/index/" target="_blank" rel="external">http://code.taobao.org/p/diamond/wiki/index/</a></p>
<h3 id="2-2-2_源码">2.2.2 源码</h3>
<p><a href="http://code.taobao.org/svn/diamond/trunk" target="_blank" rel="external">http://code.taobao.org/svn/diamond/trunk</a> </p>
<h2 id="2-3_doozer">2.3 doozer</h2>
<p>已停止更新，设计倾向于实时的数据变更通知，数据全部放于内存，不会持久化文件。（有独立工具支持，不知支持性怎样？）</p>
<h2 id="2-4_etcd">2.4 etcd</h2>
<p>CoreOS开源。<br>轻量级分布式key-value数据库，同时为集群环境的服务发现和注册而设计。<br>它提供了数据TTL失效（通过TTL更新来判断机器下线，来避免一定的网络分区问题）、数据改变监视、多值、目录监听、分布式锁原子操作等功能，来管理节点状态。</p>
<h3 id="2-4-1_特性">2.4.1 特性</h3>
<ul>
<li>简单: curl可访问的用户的API（HTTP+JSON）</li>
<li>安全: 可选的SSL客户端证书认证</li>
<li>快速: 单实例每秒 1000 次写操作</li>
<li>可靠: 使用Raft保证一致性<br>注：zookeeper使用的比较复杂基于Paxos的Zab协议，etcd使用的Standford新的一致性算法Raft，概念上会简单些，0.4.6版本依赖于go-raft，0.5.0以上重新设计。</li>
</ul>
<h3 id="2-4-2_目前版本">2.4.2 目前版本</h3>
<p>网上的介绍文章基本停留到稳定版0.4.6上。目前版本已从0.x直接跳到了2.0版本。（2015-1-28）<br><a href="https://coreos.com/blog/etcd-2.0-release-first-major-stable-release/" target="_blank" rel="external">https://coreos.com/blog/etcd-2.0-release-first-major-stable-release/</a><br>2.0介绍（需要翻墙）：<br><a href="https://www.youtube.com/watch?v=z6tjawXZ71E" target="_blank" rel="external">https://www.youtube.com/watch?v=z6tjawXZ71E</a></p>
<p>使用go语言，部署简单，同时项目较年轻。</p>
<h3 id="2-4-3_介绍">2.4.3 介绍</h3>
<p>从实现原理到应用场景多方位解读（2015-1-30）<br><a href="http://www.infoq.com/cn/articles/etcd-interpretation-application-scenario-implement-principle" target="_blank" rel="external">http://www.infoq.com/cn/articles/etcd-interpretation-application-scenario-implement-principle</a></p>
<h3 id="2-4-4_源码">2.4.4 源码</h3>
<p><a href="https://github.com/coreos/etcd" target="_blank" rel="external">https://github.com/coreos/etcd</a></p>
<h2 id="2-5_zookeeper">2.5 zookeeper</h2>
<p>成熟的分布式配置解决方案，待续。。</p>
<h2 id="2-6_比较etcd和zookeeper">2.6 比较etcd和zookeeper</h2>
<p>Jason Wilder的一篇博客分别对常见的服务发现开源项目Zookeeper、Doozer、etcd进行了总结。<br><a href="http://jasonwilder.com/blog/2014/02/04/service-discovery-in-the-cloud/" target="_blank" rel="external">http://jasonwilder.com/blog/2014/02/04/service-discovery-in-the-cloud/</a></p>
<p>重点关注etcd是否能取代zookeeper。</p>
<h3 id="2-6-1_性能">2.6.1 性能</h3>
<p>只从实现语言上考虑，golang性能近c，java在大型集群的多线程能力较好，总体相差不多。都能支持上千节点。</p>
<h3 id="2-6-2_功能性：关注订阅发布、ttl特性">2.6.2 功能性：关注订阅发布、ttl特性</h3>
<h4 id="2-6-2-1_订阅发布">2.6.2.1 订阅发布</h4>
<p>etcd 可以使用递归的Watcher，递归式的监控应用（主题）目录下所有信息的变动。这样就实现了机器IP（消息）变动的时候，能够实时通知到收集器调整任务分配。</p>
<p><strong>递归订阅</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">etcd递归 watcher</div><div class="line">$ etcdctl watch /foo-service --recursive</div><div class="line">$ curl -L http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">4001</span>/v2/keys/foo-service?wait=<span class="literal">true</span>\&recursive=<span class="literal">true</span></div></pre></td></tr></table></figure>

<p><strong>订阅通知</strong>，在/foo-service增加container2，返回：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">etcd 递归监听 返回</div><div class="line">$ etcdctl watch /foo-service --recursive</div><div class="line">localhost:<span class="number">2222</span></div><div class="line">$ curl -L http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">4001</span>/v2/keys/foo-service?wait=<span class="literal">true</span>\&recursive=<span class="literal">true</span></div><div class="line">{<span class="string">"action"</span>:<span class="string">"set"</span>,<span class="string">"node"</span>:{<span class="string">"key"</span>:<span class="string">"/foo-service/container2"</span>,<span class="string">"value"</span>:<span class="string">"localhost:2222"</span>,<span class="string">"modifiedIndex"</span>:<span class="number">23</span>,<span class="string">"createdIndex"</span>:<span class="number">23</span>}}</div></pre></td></tr></table></figure>

<h4 id="2-6-2-2_TTL机制">2.6.2.2 TTL机制</h4>
<p><strong>更新方式</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">etcd ttl更新</div><div class="line">$ etcdctl <span class="keyword">set</span> /foo <span class="string">"Expiring Soon"</span> --ttl <span class="number">20</span></div><div class="line">Expiring Soon</div><div class="line">$ curl -L -X PUT http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">4001</span>/v2/keys/foo?ttl=<span class="number">20</span> <span class="operator">-d</span> value=bar</div><div class="line">{<span class="string">"action"</span>:<span class="string">"set"</span>,<span class="string">"node"</span>:{<span class="string">"key"</span>:<span class="string">"/foo"</span>,<span class="string">"value"</span>:<span class="string">"bar"</span>,<span class="string">"expiration"</span>:<span class="string">"2014-02-10T19:54:49.357382223Z"</span>,<span class="string">"ttl"</span>:<span class="number">20</span>,<span class="string">"modifiedIndex"</span>:<span class="number">31</span>,<span class="string">"createdIndex"</span>:<span class="number">31</span>}}</div></pre></td></tr></table></figure>

<p><strong>get ttl过期的数据</strong>，返回errorCode：100</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">etcd ttl 过期数据返回</div><div class="line">$ etcdctl get /foo</div><div class="line">Error: <span class="number">100</span>: Key not found (/foo) [<span class="number">32</span>]</div><div class="line">$ curl -L http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">4001</span>/v2/keys/foo</div><div class="line">{<span class="string">"errorCode"</span>:<span class="number">100</span>,<span class="string">"message"</span>:<span class="string">"Key not found"</span>,<span class="string">"cause"</span>:<span class="string">"/foo"</span>,<span class="string">"index"</span>:<span class="number">32</span>}</div></pre></td></tr></table></figure>

<h3 id="2-6-3_部署结构">2.6.3 部署结构</h3>
<p>etcd支持<strong>普通节点</strong>模式和<strong>proxy模式</strong>两种：<br>启动设置集群大小，超过集群大小的etcd节点自动转化为proxy模式。</p>
<h4 id="2-6-3-1_proxy模式">2.6.3.1 proxy模式</h4>
<p>etcd作为一个反向代理把客户的请求转发给可用的etcd集群。这样，你就可以在每一台机器都部署一个Proxy模式的etcd作为本地服务，如果这些etcd Proxy都能正常运行，那么你的服务发现必然是稳定可靠的。<br>如图：</p>
<p><img src="http://7te9ul.com1.z0.glb.clouddn.com/etcd_proxy" alt="etcd-proxy"> </p>
<h3 id="2-6-4_总结">2.6.4 总结</h3>
<p>etcd特性略胜于zookeeper两点：<br>（1）etcd在订阅发布机制上能提供的功能与zookeeper相似。但是更轻量级，使用api更简单，依赖少，可直接使用curl/http+json或etcdctl的方式。<br>（2）etcd的TTL机制能避免一定的网络分区问题（如网络间断误认为注册服务下线）</p>
<p>zookeeper胜于etcd两点：<br>（1）成熟，稳定性高，多数坑已被踩过。<br>（2）配套工具：etcd没有web监控平台，client有node-etcd 3.0，较年轻。zookeeper有简单易用的exhibitor监控，java client的curator替代zkclient，非常成熟易用，避免掉坑。</p>
<h4 id="2-6-4-1_综合实际情况">2.6.4.1 综合实际情况</h4>
<p>线上已有zookeeper集群，考虑部署成本，避免踩坑，和zookeeper稳定和成熟配套工具，风险等，建议基于zookeeper进行封装开发。<br>如果小型集群，也是可以尝试etcd，毕竟架构部署简单省事。</p>
<hr>
<p>参考：</p>
<ul>
<li>Open-Source Service Discovery：<a href="http://jasonwilder.com/blog/2014/02/04/service-discovery-in-the-cloud/" target="_blank" rel="external">http://jasonwilder.com/blog/2014/02/04/service-discovery-in-the-cloud/</a></li>
<li>etcd：从应用场景到实现原理的全方位解读：<a href="http://www.infoq.com/cn/articles/etcd-interpretation-application-scenario-implement-principle" target="_blank" rel="external">http://www.infoq.com/cn/articles/etcd-interpretation-application-scenario-implement-principle</a></li>
<li>etcd：用于服务发现的键值存储系统：<a href="http://www.infoq.com/cn/news/2014/07/etcd-cluster-discovery" target="_blank" rel="external">http://www.infoq.com/cn/news/2014/07/etcd-cluster-discovery</a></li>
<li>构建一个高可用及自动发现的Docker基础架构-HECD[原创]：<a href="http://blog.liuts.com/post/242/" target="_blank" rel="external">http://blog.liuts.com/post/242/</a></li>
<li>CoreOS 实战：剖析 etcd：<a href="http://www.infoq.com/cn/articles/coreos-analyse-etcd/" target="_blank" rel="external">http://www.infoq.com/cn/articles/coreos-analyse-etcd/</a></li>
<li>diamond wiki：<a href="http://code.taobao.org/p/diamond/wiki/index/" target="_blank" rel="external">http://code.taobao.org/p/diamond/wiki/index/</a></li>
<li>disconf github：<a href="https://github.com/knightliao/disconf/wiki" target="_blank" rel="external">https://github.com/knightliao/disconf/wiki</a></li>
<li>etcd github：<a href="https://github.com/coreos/etcd" target="_blank" rel="external">https://github.com/coreos/etcd</a></li>
<li>Paxos在大型系统中常见的应用场景：<a href="http://timyang.net/distributed/paxos-scenarios/" target="_blank" rel="external">http://timyang.net/distributed/paxos-scenarios/</a></li>
<li>The Raft Consensus Algorithm：<a href="http://raftconsensus.github.io/" target="_blank" rel="external">http://raftconsensus.github.io/</a></li>
</ul>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/02/08/《快学scala》习题解答-第十六章-XML处理/">
                《快学scala》习题解答-第十六章-XML处理
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          Posted on 2015-02-08
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; In
            
              <a href="/categories/scala/">scala</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/02/08/《快学scala》习题解答-第十六章-XML处理/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/02/08/《快学scala》习题解答-第十六章-XML处理/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第十六章_XML处理">第十六章 XML处理</h2>
<p><strong>16.1</strong></p>
<p><fred>(0)得到什么？<fred>(0)(0)呢？为什么？</fred></fred></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">scala&gt; println(&lt;fred/&gt;(<span class="number">0</span>))</div><div class="line">&lt;fred/&gt;</div><div class="line"></div><div class="line">scala&gt; println(&lt;fred/&gt;(<span class="number">0</span>)(<span class="number">0</span>))</div><div class="line">&lt;fred/&gt;</div></pre></td></tr></table></figure>

<p>因为都是scala.xml.Node，是NodeSeq的子类，等同于长度为1的序列。</p>
<p><strong>16.2</strong><br>如下代码的值是什么？</p>
<p><ul><br>  <li>Opening bracket:[</li><br>  <li>Closing bracket:]</li><br>  <li>Opening bracket:{</li><br>  <li>Closing bracket:}</li><br></ul><br>你如何修复它？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">scala&gt; &lt;ul&gt;</div><div class="line">     |   &lt;li&gt;Opening bracket:[&lt;/li&gt;</div><div class="line">     |   &lt;li&gt;Closing bracket:]&lt;/li&gt;</div><div class="line">     |   &lt;li&gt;Opening bracket:\{\{&lt;/li&gt;</div><div class="line">     |   &lt;li&gt;Closing bracket:\}\}&lt;/li&gt;</div><div class="line">     | &lt;/ul&gt;</div><div class="line">res9: scala.xml.Elem =</div><div class="line">&lt;ul&gt;</div><div class="line">  &lt;li&gt;Opening bracket:[&lt;/li&gt;</div><div class="line">  &lt;li&gt;Closing bracket:]&lt;/li&gt;</div><div class="line">  &lt;li&gt;Opening bracket:{&lt;/li&gt;</div><div class="line">  &lt;li&gt;Closing bracket:}&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure>

<p>花括号作为字面量，需要连写两个</p>
<p><strong>16.3</strong><br>对比<br>  <li>Fred</li> match { case <li>{Text(t)}</li> =&gt; t }<br>和<br>  <li>{“Fred”}</li> match { case <li>{Text(t)}</li> =&gt; t}<br>为什么它们的行为不同？</p>
<p>scala 2.11.4查不到Text api。。略</p>
<p><strong>16.4</strong><br>读取一个XHTML文件并打印所有不带alt属性的img元素</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.xml.XML</div><div class="line"></div><div class="line"><span class="keyword">var</span> html = <span class="string">"&lt;html&gt;&lt;head&gt;&lt;title&gt;第一个网页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;img alt='a'&gt;&lt;img src='1'&gt;&lt;/img&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"</span></div><div class="line"><span class="keyword">val</span> images = (html \\ <span class="string">"img"</span>).filterNot(_.attributes(<span class="string">"alt"</span>).isDefined)</div><div class="line"><span class="keyword">val</span> images1 = html <span class="keyword">match</span>{</div><div class="line">  <span class="keyword">case</span> n @ &lt;img/&gt; <span class="keyword">if</span> (!n.attributes(<span class="string">"alt"</span>)) =&gt; n</div><div class="line">}</div><div class="line"></div><div class="line">println(images.mkString(<span class="string">"\n"</span>));</div><div class="line">println(images1.mkString(<span class="string">"\n"</span>));</div></pre></td></tr></table></figure>

<p><strong>16.5</strong><br>打印XHTML文件中所有图像的名称，即打印所有位于img元素内的src属性值</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.xml.XML</div><div class="line"></div><div class="line"><span class="keyword">var</span> html = <span class="string">"&lt;html&gt;&lt;head&gt;&lt;title&gt;第一个网页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;img alt='a'&gt;&lt;img src='1'&gt;&lt;/img&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"</span></div><div class="line"><span class="keyword">val</span> images = (html \\ <span class="string">"img"</span>).flatMap(_.attributes(<span class="string">"src"</span>))</div><div class="line"><span class="keyword">val</span> images1 = html <span class="keyword">match</span>{</div><div class="line">  <span class="keyword">case</span> n @ &lt;img/&gt; =&gt; Some(n.attributes(<span class="string">"src"</span>))</div><div class="line">}</div><div class="line"></div><div class="line">println(images.mkString(<span class="string">"\n"</span>));</div><div class="line">println(images1.mkString(<span class="string">"\n"</span>));</div></pre></td></tr></table></figure>

<p><strong>16.6</strong><br>读取XHTML文件并打印一个包含了文件中给出的所有超链接及其url的表格。即，打印所有a元素的child文本和href属性。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.xml._</div><div class="line"></div><div class="line"><span class="keyword">val</span> html = <span class="string">""</span></div><div class="line"><span class="keyword">val</span> links = (html \\ <span class="string">"a"</span>) map { (x: Node) =&gt; (x.attribute(<span class="string">"href"</span>).getOrElse(<span class="string">""</span>).toString, x.text) } filter {_._1.startsWith(<span class="string">"http"</span>)}</div><div class="line"></div><div class="line">println(links.mkString(<span class="string">"\n"</span>));</div></pre></td></tr></table></figure>

<p><strong>16.7</strong><br>编写一个函数，带一个类型为Map[String,String]的参数，返回一个dl元素，其中针对映射中每个键对应有一个dt，每个值对应有一个dd，例如：<br>Map(“A”-&gt;”1”,”B”-&gt;”2”)<br>应产出<dl><dt>A</dt><dd>1</dd><dt>B</dt><dd>2</dd></dl></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> mapToHTML(map: Map[String, String]) = {</div><div class="line">  &lt;dl&gt;{<span class="keyword">for</span> ((k,v) &lt;- map) <span class="keyword">yield</span> &lt;dt&gt;{k}&lt;/dt&gt;&lt;dd&gt;{v}&lt;/dd&gt;}&lt;/dl&gt;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">val</span> x = Map(<span class="string">"A"</span> -&gt; <span class="string">"1"</span>, <span class="string">"B"</span> -&gt; <span class="string">"2"</span>)</div><div class="line"></div><div class="line">println(mapToHTML(x))</div></pre></td></tr></table></figure>

<p><strong>16.8</strong><br>编写一个函数，接受dl元素，将它转成Map[String,String]。该函数应该是前一个练习中的<br>反向处理，前提是所有dt后代都是唯一的。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> htmlToMap(str:String):Map[String,String] = {</div><div class="line">  <span class="keyword">val</span> dtMap = (str \\ <span class="string">"dt"</span>).toMap</div><div class="line">  <span class="keyword">val</span> ddMap = (str \\ <span class="string">"dd"</span>).toMap</div><div class="line">  dtMap.zip(ddMap)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">val</span> html = &lt;dl&gt;&lt;dt&gt;A&lt;/dt&gt;&lt;dd&gt;<span class="number">1</span>&lt;/dd&gt;&lt;dt&gt;B&lt;/dt&gt;&lt;dd&gt;<span class="number">2</span>&lt;/dd&gt;&lt;/dl&gt;</div><div class="line">println(htmlToMap(html).mkString(<span class="string">","</span>))</div></pre></td></tr></table></figure>

<p><strong>16.9</strong><br>对一个XHTML文档进行变换，对所有不带alt属性的img元素添加一个alt=”TODO”属性，其他内容完全不变。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.xml._</div><div class="line"><span class="keyword">val</span> html = <span class="string">""</span></div><div class="line"><span class="keyword">val</span> replaceNoneAlt = html <span class="keyword">match</span>{</div><div class="line">  <span class="keyword">case</span> img @ &lt;img/&gt; <span class="keyword">if</span>(_.attribute(alt)==<span class="string">"NONE"</span>) =&gt; img % Attribute(<span class="keyword">null</span>,<span class="string">"alt"</span>,<span class="string">"TODO"</span>,<span class="keyword">null</span>)</div><div class="line">  <span class="keyword">case</span> _ =&gt; html</div><div class="line">}</div><div class="line">println(replaceNoneAlt)</div></pre></td></tr></table></figure>

<p><strong>16.10</strong><br>编写一个函数，读取XHTML文档，执行前一个练习中的变换，并保存结果。确保保留了DTD以及所有CDATA内容。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> xml._</div><div class="line"><span class="keyword">import</span> xml.transform._</div><div class="line"><span class="keyword">import</span> xml.parsing.ConstructingParser</div><div class="line"><span class="keyword">import</span> xml.dtd.DocType</div><div class="line"><span class="keyword">import</span> java.io.File</div><div class="line"></div><div class="line"><span class="keyword">val</span> doc = ConstructingParser.fromFile(<span class="keyword">new</span> File(<span class="string">"./test.xml"</span>),</div><div class="line">  <span class="keyword">true</span>).document</div><div class="line"><span class="keyword">val</span> a = doc.docElem</div><div class="line"></div><div class="line"><span class="keyword">val</span> imgRule = <span class="keyword">new</span> RewriteRule {</div><div class="line">  <span class="keyword">override</span> <span class="keyword">def</span> transform(n:Node) = n <span class="keyword">match</span> {</div><div class="line">    <span class="keyword">case</span> i @ &lt;img&gt;{_*}&lt;/img&gt; <span class="keyword">if</span>(i.attribute(<span class="string">"alt"</span>) == None) =&gt;</div><div class="line">      i % Attribute(<span class="keyword">null</span>, <span class="string">"alt"</span>, <span class="string">"TODO"</span>, Null)</div><div class="line">    <span class="keyword">case</span> _ =&gt; n</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">val</span> result = <span class="keyword">new</span> RuleTransformer(imgRule).transform(a)</div><div class="line">XML.save(<span class="string">"./test.xml"</span>, result(<span class="number">0</span>), <span class="string">"UTF-8"</span>, <span class="keyword">false</span>,</div><div class="line">  DocType(<span class="string">"html"</span>, doc.dtd.externalID, Nil))</div></pre></td></tr></table></figure>

<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/02/08/《快学scala》习题解答-第十五章-注解/">
                《快学scala》习题解答-第十五章-注解
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          Posted on 2015-02-08
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; In
            
              <a href="/categories/scala/">scala</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/02/08/《快学scala》习题解答-第十五章-注解/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/02/08/《快学scala》习题解答-第十五章-注解/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第十五章_注解">第十五章 注解</h2>
<p><strong>15.1</strong><br>编写四个JUnit测试用例，分别使用带或不带某个参数的@Test注解。用JUnit执行这些测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.junit.Test</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScalaTest</span> </span>{</div><div class="line"></div><div class="line">  <span class="annotation">@Test</span></div><div class="line">  <span class="keyword">def</span> test1(){</div><div class="line">    print(<span class="string">"test1"</span>)</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="annotation">@Test</span>(timeout = <span class="number">1</span>L)</div><div class="line">  <span class="keyword">def</span> test2(){</div><div class="line">    print(<span class="string">"test2"</span>)</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>15.2</strong><br>创建一个类的示例，展示注解可以出现的所有位置。用@deprecated作为你的示例注解。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@deprecated</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>{</div><div class="line"></div><div class="line">  <span class="annotation">@deprecated</span></div><div class="line">  <span class="keyword">val</span> t = _;</div><div class="line"></div><div class="line">  <span class="annotation">@deprecated</span>(message = <span class="string">"unuse"</span>)</div><div class="line">  <span class="keyword">def</span> hello(){</div><div class="line">    println(<span class="string">"hello"</span>)</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="annotation">@deprecated</span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>{</div><div class="line">  <span class="keyword">val</span> t = <span class="keyword">new</span> Test()</div><div class="line">  t.hello()</div><div class="line">  t.t</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>15.3</strong><br>Scala类库中的哪些注解用到了元注解@param,@field,@getter,@setter,@beanGetter或@beanSetter?</p>
<p>略</p>
<p><strong>15.4</strong><br>编写一个Scala方法sum,带有可变长度的整型参数，返回所有参数之和。从Java调用该方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.annotation.varargs</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</div><div class="line">  <span class="annotation">@varargs</span> <span class="keyword">def</span> sum(nums: Int*): Int = {</div><div class="line">    nums.sum</div><div class="line">  }</div><div class="line">}</div><div class="line"><span class="javadoc">/** Test2.java</span></div><div class="line">class Test2 {</div><div class="line"></div><div class="line">  public static void main(String[] args){</div><div class="line">    Test t = new Test();</div><div class="line">    System.out.println(t.sum(1,2,3));</div><div class="line">  }</div><div class="line">}</div><div class="line">  **/</div></pre></td></tr></table></figure>

<p><strong>15.5</strong><br>编写一个返回包含某文件所有行的字符串的方法。从Java调用该方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> io.Source</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test5</span></span>{</div><div class="line"></div><div class="line">  <span class="keyword">def</span> read()={</div><div class="line">    Source.fromFile(<span class="string">"test.txt"</span>).mkString</div><div class="line">  }</div><div class="line">}</div><div class="line"><span class="javadoc">/*** Test2.java</span></div><div class="line">public class Hello {</div><div class="line">  public static void main(String[] args){</div><div class="line">    Test5 t = new Test5();</div><div class="line">    System.out.println(t.read());</div><div class="line">  }</div><div class="line">}</div><div class="line">  ***/</div></pre></td></tr></table></figure>

<p><strong>15.6</strong><br>编写一个Scala对象，该对象带有一个易失(volatile)的Boolean字段。让某一个线程睡眠一段时间，之后将该字段设为true，打印消息，然后退出。而另一个线程不停的检查该字段是否为true。如果是，它将打印一个消息并退出。如果不是，则它将短暂睡眠，然后重试。如果变量不是易失的，会发生什么？</p>
<p>没区别</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> concurrent.ops.spawn</div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test06</span></span>{</div><div class="line">  <span class="annotation">@volatile</span> <span class="keyword">var</span> value = <span class="keyword">false</span></div><div class="line">}</div><div class="line"></div><div class="line">spawn {</div><div class="line">  Thread.sleep(<span class="number">100</span>);</div><div class="line">  Test06.value = <span class="keyword">true</span></div><div class="line">  println(<span class="string">"Thread1: setting value to TRUE!"</span>)</div><div class="line">}</div><div class="line"></div><div class="line">spawn {</div><div class="line">  <span class="keyword">while</span>(!Test06.value) Thread.sleep(<span class="number">20</span>);</div><div class="line">  println(<span class="string">"Thread2: value is TRUE!"</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>15.7</strong><br>给出一个示例，展示如果方法可被重写，则尾递归优化为非法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> annotation.tailrec</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">App</span></span>{</div><div class="line">  <span class="annotation">@tailrec</span></div><div class="line">  <span class="keyword">def</span> sum2(xs : Seq[Int],partial : BigInt) : BigInt = {</div><div class="line">    <span class="keyword">if</span> (xs.isEmpty) partial <span class="keyword">else</span> sum2(xs.tail,xs.head + partial)</div><div class="line">  }</div><div class="line"></div><div class="line">  println(sum2(<span class="number">1</span> to <span class="number">1000000</span>,<span class="number">0</span>))</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>15.8</strong><br>将allDifferent方法添加到对象，编译并检查字节码。@specialized注解产生了哪些方法?</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span></span>{</div><div class="line">  <span class="keyword">def</span> allDifferent[<span class="annotation">@specialized</span> T](x:T,y:T,z:T) = x != y && x!= z && y != z</div><div class="line">}</div></pre></td></tr></table></figure>

<p>javap Test$得到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>$ <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span></span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Test$ MODULE$;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> {};</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allDifferent</span>(java.lang.Object, java.lang.Object, java.lang.Ob</div><div class="line">ject);</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> allDifferent$mZc$<span class="title">sp</span>(<span class="keyword">boolean</span>, <span class="keyword">boolean</span>, <span class="keyword">boolean</span>);</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> allDifferent$mBc$<span class="title">sp</span>(<span class="keyword">byte</span>, <span class="keyword">byte</span>, <span class="keyword">byte</span>);</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> allDifferent$mCc$<span class="title">sp</span>(<span class="keyword">char</span>, <span class="keyword">char</span>, <span class="keyword">char</span>);</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> allDifferent$mDc$<span class="title">sp</span>(<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>);</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> allDifferent$mFc$<span class="title">sp</span>(<span class="keyword">float</span>, <span class="keyword">float</span>, <span class="keyword">float</span>);</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> allDifferent$mIc$<span class="title">sp</span>(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>);</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> allDifferent$mJc$<span class="title">sp</span>(<span class="keyword">long</span>, <span class="keyword">long</span>, <span class="keyword">long</span>);</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> allDifferent$mSc$<span class="title">sp</span>(<span class="keyword">short</span>, <span class="keyword">short</span>, <span class="keyword">short</span>);</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> allDifferent$mVc$<span class="title">sp</span>(scala.runtime.BoxedUnit, scala.runtime.Bo</div><div class="line">xedUnit, scala.runtime.BoxedUnit);</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>15.9</strong><br>Range.foreach方法被注解为@specialized(Unit)。为什么？通过以下命令检查字节码:<br>javap -classpath /path/to/scala/lib/scala-library.jar scala.collection.immutable.Range<br>并考虑Function1上的@specialized注解。点击Scaladoc中的Function1.scala链接进行查看</p>
<p>首先来看Function1的源码</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">......</div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Function1</span>[@<span class="title">specialized</span><span class="params">(scala.Int, scala.Long, scala.Float, scala.Double/*, scala.AnyRef*/)</span> -<span class="title">T1</span>, @<span class="title">specialized</span><span class="params">(scala.Unit, scala.Boolean, scala.Int, scala.Float, scala.Long, scala.Double/*, scala.AnyRef*/)</span> +<span class="title">R</span>] <span class="keyword">extends</span> <span class="title">AnyRef</span> </span>{ self =&gt;</div><div class="line">  <span class="javadoc">/** Apply the body of this function to the argument.</span></div><div class="line">   *  <span class="javadoctag">@return</span>   the result of function application.</div><div class="line">   */</div><div class="line">  <span class="keyword">def</span> apply(v1: T1): R</div><div class="line">......</div></pre></td></tr></table></figure>

<p>可以看到Function1参数可以是scala.Int,scala.Long,scala.Float,scala.Double，返回值可以是scala.Unit,scala.Boolean,scala.Int,scala.Float,scala.Long,scala.Double 再来看Range.foreach的源码</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">...... </div><div class="line"><span class="annotation">@inline</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">def</span> foreach[<span class="annotation">@specialized</span>(Unit) U](f: Int =&gt; U) {</div><div class="line">    <span class="keyword">if</span> (validateRangeBoundaries(f)) {</div><div class="line">      <span class="keyword">var</span> i = start</div><div class="line">      <span class="keyword">val</span> terminal = terminalElement</div><div class="line">      <span class="keyword">val</span> step = <span class="keyword">this</span>.step</div><div class="line">      <span class="keyword">while</span> (i != terminal) {</div><div class="line">        f(i)</div><div class="line">        i += step</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div><div class="line">......</div></pre></td></tr></table></figure>

<p>首先此方法是没有返回值的，也就是Unit。而Function1的返回值可以是scala.Unit,scala.Boolean,scala.Int,scala.Float,scala.Long,scala.Double 如果不限定@specialized(Unit),则Function1可能返回其他类型，但是此方法体根本就不返回，即使设置了也无法获得返回值</p>
<p><strong>15.10</strong><br>添加assert(n &gt;= 0)到factorial方法。在启用断言的情况下编译并校验factorial(-1)会抛异常。在禁用断言的情况下编译。会发生什么？用javap检查该断言调用</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>{</div><div class="line">  <span class="keyword">def</span> factorial(n: Int): Int = {</div><div class="line">    assert(n &gt; <span class="number">0</span>)</div><div class="line">    n</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">def</span> main(args: Array[String]) {</div><div class="line">    factorial(-<span class="number">1</span>)</div><div class="line">  }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>编译报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Exception in thread <span class="string">"main"</span> java.lang.AssertionError: assertion failed</div><div class="line">        at scala.Predef$.<span class="keyword">assert</span>(Predef.scala:<span class="number">165</span>)</div><div class="line">        at Test$.factorial(Test.scala:<span class="number">6</span>)</div><div class="line">        at Test$.main(Test.scala:<span class="number">11</span>)</div><div class="line">        at Test.main(Test.scala)</div><div class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</div><div class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">39</span>)</div><div class="line">        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">25</span>)</div><div class="line">        at java.lang.reflect.Method.invoke(Method.java:<span class="number">597</span>)</div><div class="line">        at com.intellij.rt.execution.application.AppMain.main(AppMain.java:<span class="number">120</span>)</div></pre></td></tr></table></figure>

<p>禁用assert<br>-Xelide-below 2011<br>反编译此类javap -c Test$ 得到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">......</div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">factorial</span>(<span class="keyword">int</span>);</div><div class="line">  Code:</div><div class="line">   <span class="number">0</span>:   getstatic       #<span class="number">19</span>; <span class="comment">//Field scala/Predef$.MODULE$:Lscala/Predef$;</span></div><div class="line">   <span class="number">3</span>:   iload_1</div><div class="line">   <span class="number">4</span>:   iconst_0</div><div class="line">   <span class="number">5</span>:   if_icmple       <span class="number">12</span></div><div class="line">   <span class="number">8</span>:   iconst_1</div><div class="line">   <span class="number">9</span>:   goto    <span class="number">13</span></div><div class="line">   <span class="number">12</span>:  iconst_0</div><div class="line">   <span class="number">13</span>:  invokevirtual   #<span class="number">23</span>; <span class="comment">//Method scala/Predef$.assert:(Z)V</span></div><div class="line">   <span class="number">16</span>:  iload_1</div><div class="line">   <span class="number">17</span>:  ireturn</div><div class="line">......</div></pre></td></tr></table></figure>

<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/02/08/《快学scala》习题解答-第十四章-模式匹配和样例集合/">
                《快学scala》习题解答-第十四章-模式匹配和样例集合
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          Posted on 2015-02-08
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; In
            
              <a href="/categories/scala/">scala</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/02/08/《快学scala》习题解答-第十四章-模式匹配和样例集合/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/02/08/《快学scala》习题解答-第十四章-模式匹配和样例集合/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第十四章_模式匹配和样例类">第十四章 模式匹配和样例类</h2>
<p><strong>14.1</strong><br>JDK发行包有一个src.zip文件包含了JDK的大多数源代码。解压并搜索样例标签(用正则表达式case [^:]+:)。然后查找以//开头并包含[Ff]alls?thr的注释，捕获类似// Falls through或// just fall thru这样的注释。假定JDK的程序员们遵守Java编码习惯，在该写注释的地方写下了这些注释，有多少百分比的样例是会掉入到下一个分支的？</p>
<p>略</p>
<p><strong>14.2</strong><br>利用模式匹配，编写一个swap函数，接受一个整数的对偶，返回对偶的两个组成部件互换位置的新对偶</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> swap[S,T](tup: (S,T))={</div><div class="line">  tup <span class="keyword">match</span>{</div><div class="line">    <span class="keyword">case</span> (a,b) =&gt; (b,a)</div><div class="line">  }</div><div class="line">}</div><div class="line">println(swap[String,Int]((<span class="string">"1"</span>,<span class="number">2</span>)))</div></pre></td></tr></table></figure>

<p><strong>14.3</strong><br>利用模式匹配，编写一个swap函数，交换数组中的前两个元素的位置，前提条件是数组长度至少为2</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> swap(array:Array[Any])={</div><div class="line">  array <span class="keyword">match</span>{</div><div class="line">    <span class="keyword">case</span> Array(first,second,rest @_*)=&gt; Array(second,first)++rest</div><div class="line">    <span class="keyword">case</span> _ =&gt; array</div><div class="line">  }</div><div class="line">}</div><div class="line">println(swap(Array(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>)).mkString)</div></pre></td></tr></table></figure>

<p><strong>14.4</strong><br>添加一个样例类Multiple，作为Item的子类。举例来说，Multiple(10,Article(“Blackwell Toster”,29.95))描述的是10个烤面包机。当然了，你应该可以在第二个参数的位置接受任何Item，无论是Bundle还是另一个Multiple。扩展price函数以应对新的样例。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Multiple</span><span class="params">(num : Int,item : Item)</span> <span class="keyword">extends</span> <span class="title">Item</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Article</span><span class="params">(description : String , price : Double)</span> <span class="keyword">extends</span> <span class="title">Item</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Bundle</span><span class="params">(description : String , discount : Double , item : Item*)</span> <span class="keyword">extends</span> <span class="title">Item</span></span></div><div class="line"></div><div class="line"><span class="keyword">def</span> price(it : Item) : Double = it <span class="keyword">match</span> {</div><div class="line">  <span class="keyword">case</span> Article(_,p) =&gt; p</div><div class="line">  <span class="keyword">case</span> Bundle(_,disc,its @ _*) =&gt; its.map(price _).sum - disc</div><div class="line">  <span class="keyword">case</span> Multiple(n,it) =&gt; n * price(it)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">val</span> p = price(Multiple(<span class="number">10</span>,Article(<span class="string">"Blackwell Toster"</span>,<span class="number">29.95</span>)))</div><div class="line">println(p)</div></pre></td></tr></table></figure>

<p><strong>14.5</strong><br>我们可以用列表制作只在叶子节点存放值的树。举例来说，列表((3 8) 2 (5))描述的是如下这样一棵树:<br>      *<br>    / | \</p>
<ul>
<li>2  *<br>/  \    |<br>3   8    5<br>不过，有些列表元素是数字，而另一些是列表。在Scala中，你不能拥有异构的列表，因此你必须使用List[Any]。编写一个leafSum函数，计算所有叶子节点中的元素之和，用模式匹配来区分数字和列表。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> leafSum(list:List[Any]):Int={</div><div class="line">  <span class="keyword">var</span> total = <span class="number">0</span></div><div class="line">  list.foreach {</div><div class="line">    lst =&gt;</div><div class="line">      lst <span class="keyword">match</span> {</div><div class="line">        <span class="keyword">case</span> l: List[Any] =&gt; total += leafSum(l)</div><div class="line">        <span class="keyword">case</span> i: Int =&gt; total += i</div><div class="line">      }</div><div class="line">  }</div><div class="line">  total</div><div class="line">}</div><div class="line"><span class="keyword">val</span> l: List[Any] = List(List(<span class="number">3</span>, <span class="number">8</span>), <span class="number">2</span>, List(<span class="number">5</span>))</div><div class="line"></div><div class="line">println(leafSum(l))</div></pre></td></tr></table></figure>

<p><strong>14.6</strong><br>制作这样的树更好的做法是使用样例类。我们不妨从二叉树开始。<br>sealed abstract class BinaryTree<br>case class Leaf(value : Int) extends BinaryTree<br>case class Node(left : BinaryTree,right : BinaryTree) extends BinaryTree<br>编写一个函数计算所有叶子节点中的元素之和。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Leaf</span><span class="params">(value : Int)</span> <span class="keyword">extends</span> <span class="title">BinaryTree</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Node</span><span class="params">(left: BinaryTree, right:BinaryTree)</span> <span class="keyword">extends</span> <span class="title">BinaryTree</span></span></div><div class="line"></div><div class="line"><span class="keyword">def</span> leafSum(tree:BinaryTree):Int={</div><div class="line">  tree <span class="keyword">match</span> {</div><div class="line">    <span class="keyword">case</span> Node(a,b) =&gt; leafSum(a) + leafSum(b)</div><div class="line">    <span class="keyword">case</span> Leaf(v) =&gt; v</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">val</span> r = Node(Leaf(<span class="number">3</span>),Node(Leaf(<span class="number">3</span>),Leaf(<span class="number">9</span>)))</div><div class="line"></div><div class="line">println(leafSum(r))</div></pre></td></tr></table></figure>

<p><strong>13.7</strong><br>扩展前一个练习中的树，使得每个节点可以有任意多的后代，并重新实现leafSum函数。第五题中的树应该能够通过下述代码表示：<br>Node(Node(Leaf(3),Leaf(8)),Leaf(2),Node(Leaf(5)))</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Leaf</span><span class="params">(value: Int)</span> <span class="keyword">extends</span> <span class="title">BinaryTree</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Node</span><span class="params">(tr: BinaryTree*)</span> <span class="keyword">extends</span> <span class="title">BinaryTree</span></span></div><div class="line"></div><div class="line"><span class="keyword">def</span> leafSum(tree:BinaryTree):Int={</div><div class="line">  tree <span class="keyword">match</span> {</div><div class="line">    <span class="keyword">case</span> Node(r @_*) =&gt; r.map(leafSum).sum</div><div class="line">    <span class="keyword">case</span> Leaf(v) =&gt; v</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">val</span> r = Node(Node(Leaf(<span class="number">3</span>), Leaf(<span class="number">8</span>)), Leaf(<span class="number">2</span>), Node(Leaf(<span class="number">5</span>)))</div><div class="line"></div><div class="line">println(leafSum(r))</div></pre></td></tr></table></figure>

<p><strong>13.8</strong><br>扩展前一个练习中的树，使得每个非叶子节点除了后代之外，能够存放一个操作符。然后编写一个eval函数来计算它的值。举例来说：<br>      +<br>    / | \</p>
<ul>
<li>2  -<br>/  \    |<br>3   8    5<br>上面这棵树的值为(3 * 8) + 2 + (-5) = 21</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Leaf</span><span class="params">(value: Int)</span> <span class="keyword">extends</span> <span class="title">BinaryTree</span></span></div><div class="line"><span class="class"><span class="keyword">case</span> <span class="keyword">class</span> <span class="title">Node</span><span class="params">(op: Char, leafs: BinaryTree*)</span> <span class="keyword">extends</span> <span class="title">BinaryTree</span></span></div><div class="line"></div><div class="line"><span class="keyword">def</span> eval(tree:BinaryTree):Int= {</div><div class="line">  tree <span class="keyword">match</span> {</div><div class="line">    <span class="keyword">case</span> Node(op, leafs@_*) =&gt; op <span class="keyword">match</span> {</div><div class="line">      <span class="keyword">case</span> '+' =&gt; leafs.map(eval _).sum</div><div class="line">      <span class="keyword">case</span> '-' =&gt; -leafs.map(eval _).sum</div><div class="line">      <span class="keyword">case</span> '*' =&gt; leafs.map(eval _).product</div><div class="line">    }</div><div class="line">    <span class="keyword">case</span> Leaf(x) =&gt; x</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line">  <span class="keyword">val</span> x = Node('+', Node('*', Leaf(<span class="number">3</span>), Leaf(<span class="number">8</span>)), Leaf(<span class="number">2</span>),  Node('-', Leaf(<span class="number">5</span>)))</div><div class="line"></div><div class="line">  println(x)</div><div class="line">  println(eval(x))</div></pre></td></tr></table></figure>

<p><strong>14.9</strong><br>编写一个函数，计算List[Option[Int]]中所有非None值之和。不得使用match语句。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> sum(lst: List[Option[Int]]) = lst.map(_.getOrElse(<span class="number">0</span>)).sum</div><div class="line"></div><div class="line"><span class="keyword">val</span> x = List(Some(<span class="number">1</span>), None, Some(<span class="number">2</span>), None, Some(<span class="number">3</span>))</div><div class="line"></div><div class="line">println(sum(x))</div></pre></td></tr></table></figure>

<p><strong>14.10</strong><br>编写一个函数，将两个类型为Double=&gt;Option[Double]的函数组合在一起，产生另一个同样类型的函数。如果其中一个函数返回None，则组合函数也应返回None。例如：<br>def f(x : Double) = if ( x &gt;= 0) Some(sqrt(x)) else None<br>def g(x : Double) = if ( x != 1) Some( 1 / ( x - 1)) else None<br>val h = compose(f,g)<br>h(2)将得到Some(1)，而h(1)和h(0)将得到None</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> compose(f:Double=&gt;Option[Double],g:Double=&gt;Option[Double])={</div><div class="line">  (x : Double) =&gt;</div><div class="line">    <span class="keyword">if</span> (f(x) == None || g(x) == None) None</div><div class="line">    <span class="keyword">else</span> g(x)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">import</span> scala.math.sqrt</div><div class="line"></div><div class="line"><span class="keyword">def</span> f(x : Double) = <span class="keyword">if</span> ( x &gt;= <span class="number">0</span>) Some(sqrt(x)) <span class="keyword">else</span> None</div><div class="line"><span class="keyword">def</span> g(x : Double) = <span class="keyword">if</span> ( x != <span class="number">1</span>) Some( <span class="number">1</span> / ( x - <span class="number">1</span>)) <span class="keyword">else</span> None</div><div class="line"><span class="keyword">val</span> h = compose(f,g)</div><div class="line"></div><div class="line">println(h(<span class="number">2</span>))</div></pre></td></tr></table></figure>

<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/02/07/《快学scala》习题解答-第十三章-集合/">
                《快学scala》习题解答-第十三章-集合
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          Posted on 2015-02-07
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; In
            
              <a href="/categories/scala/">scala</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/02/07/《快学scala》习题解答-第十三章-集合/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/02/07/《快学scala》习题解答-第十三章-集合/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第十三章_集合">第十三章 集合</h2>
<p><strong>13.1</strong><br>编写一个函数，给定字符串，产出一个包含所有字符的下标的映射。举例来说：indexes(“Mississippi”)应返回一个映射，让’M’对应集{0}，’i’对应集{1,4,7,10}，依此类推。使用字符到可变集的映射。另外，你如何保证集是经过排序的？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> mapStrIndex(str:String)={</div><div class="line">  <span class="keyword">var</span> indexMap = <span class="keyword">new</span> HashMap[Char,SortedSet[Int]]()</div><div class="line">  <span class="keyword">var</span> i = <span class="number">0</span></div><div class="line">  str.toCharArray.foreach {</div><div class="line">    c =&gt;</div><div class="line">      indexMap.get(c) <span class="keyword">match</span> {</div><div class="line">        <span class="keyword">case</span> Some(result) =&gt; indexMap(c) = result + i</div><div class="line">        <span class="keyword">case</span> None =&gt; indexMap += (c -&gt; SortedSet {</div><div class="line">          i</div><div class="line">        })</div><div class="line">      }</div><div class="line">      i += <span class="number">1</span></div><div class="line">  }</div><div class="line">  indexMap</div><div class="line"></div><div class="line">}</div><div class="line">println(mapStrIndex(<span class="string">"Mississippi"</span>))</div></pre></td></tr></table></figure>

<p><strong>13.2</strong><br>重复前一个练习，这次用字符到列表的不可变映射。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">mport scala.collection.mutable.{ListBuffer, HashMap}</div><div class="line"><span class="keyword">def</span> mapStrIndex(str:String)={</div><div class="line">  <span class="keyword">var</span> indexMap = <span class="keyword">new</span> HashMap[Char,ListBuffer[Int]]()</div><div class="line">  <span class="keyword">var</span> i = <span class="number">0</span></div><div class="line">  str.toCharArray.foreach {</div><div class="line">    c =&gt;</div><div class="line">      indexMap.get(c) <span class="keyword">match</span> {</div><div class="line">        <span class="keyword">case</span> Some(result) =&gt; result += i</div><div class="line">        <span class="keyword">case</span> None =&gt; indexMap += (c -&gt; ListBuffer {</div><div class="line">          i</div><div class="line">        })</div><div class="line">      }</div><div class="line">      i += <span class="number">1</span></div><div class="line">  }</div><div class="line">  indexMap</div><div class="line"></div><div class="line">}</div><div class="line">println(mapStrIndex(<span class="string">"Mississippi"</span>))</div></pre></td></tr></table></figure>

<p><strong>13.3</strong><br>编写一个函数，从一个整型链表中去除所有的零值。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> removeZero(list:List[Int]):List[Int]={</div><div class="line">  list.filter(_!=<span class="number">0</span>)</div><div class="line">}</div><div class="line">println(removeZero(List(<span class="number">3</span>,<span class="number">25</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>)))</div></pre></td></tr></table></figure>

<p><strong>13.4</strong><br>编写一个函数，接受一个字符串的集合，以及一个从字符串到整数值的映射。返回整型的集合，其值为能和集合中某个字符串相对应的映射的值。举例来说，给定Array(“Tom”,”Fred”,”Harry”)和Map(“Tom”-&gt;3,”Dick”-&gt;4,”Harry”-&gt;5)，返回Array(3,5)。提示：用flatMap将get返回的Option值组合在一起</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> filterMap(array:Array[String],map:Map[String,Int]):Array[Int]={</div><div class="line">  array.flatMap(map.get(_))</div><div class="line">}</div><div class="line">println(filterMap(Array(<span class="string">"Tom"</span>,<span class="string">"Fred"</span>,<span class="string">"Harry"</span>),Map(<span class="string">"Tom"</span>-&gt;<span class="number">3</span>,<span class="string">"Dick"</span>-&gt;<span class="number">4</span>,<span class="string">"Harry"</span>-&gt;<span class="number">5</span>)).mkString(<span class="string">","</span>))</div></pre></td></tr></table></figure>

<p><strong>13.5</strong><br>实现一个函数，作用与mkString相同，使用reduceLeft。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> collection.mutable</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">MktString</span></span>{</div><div class="line">  <span class="keyword">this</span>:mutable.Iterable[String]=&gt;</div><div class="line">  <span class="keyword">def</span> mktString(split:String=<span class="string">""</span>) = <span class="keyword">if</span>( <span class="keyword">this</span> != Nil) <span class="keyword">this</span>.reduceLeft(_ + split + _)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> mutable.HashSet[String] <span class="keyword">with</span> MktString</div><div class="line">test += <span class="string">"1"</span></div><div class="line">test += <span class="string">"2"</span></div><div class="line">test += <span class="string">"3"</span></div><div class="line">println(test.mktString(<span class="string">","</span>))</div></pre></td></tr></table></figure>

<p><strong>13.6</strong><br>给定整型列表lst,(lst :\ List<a href="">Int</a>)(<em> :: </em> )得到什么?(List<a href="">Int</a> /: lst)(<em> :+ </em>)又得到什么？如何修改它们中的一个，以对原列表进行反向排序？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> lst = List(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</div><div class="line">println((lst :\ List[Int]())(_ :: _))</div><div class="line">println((List[Int]() /: lst)(_ :+ _))</div><div class="line">println((List[Int]() /: lst)((a,b) =&gt; b :: a))</div></pre></td></tr></table></figure>

<p><strong>13.7</strong><br>在13.11节中，表达式(prices zip quantities) map { p =&gt; p.<em>1 * p._2}有些不够优雅。我们不能用(prices zip quantities) map { </em> <em> <em>}，因为 </em> </em> _ 是一个带两个参数的函数，而我们需要的是一个带单个类型为元组的参数的函数，Function对象的tupled方法可以将带两个参数的函数改为以元俎为参数的函数。将tupled应用于乘法函数，以使我们可以用它来映射由对偶组成的列表。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> prices = List(<span class="number">5.0</span>,<span class="number">20.0</span>,<span class="number">9.95</span>)</div><div class="line"><span class="keyword">val</span> quantities = List(<span class="number">10</span>,<span class="number">2</span>,<span class="number">1</span>)</div><div class="line">println((prices zip quantities) map { Function.tupled(_ * _) })</div></pre></td></tr></table></figure>

<p><strong>13.8</strong><br>编写一个函数。将Double数组转换成二维数组。传入列数作为参数。举例来说，Array(1,2,3,4,5,6)和三列，返回Array(Array(1,2,3),Array(4,5,6))。用grouped方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> divArr(arr:Array[Double],i:Int)={</div><div class="line">  arr.grouped(i).toArray</div><div class="line">}</div><div class="line"><span class="keyword">val</span> arr = Array(<span class="number">1.0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</div><div class="line">divArr(arr,<span class="number">3</span>).foreach(a =&gt; println(a.mkString(<span class="string">","</span>)))</div></pre></td></tr></table></figure>

<p><strong>13.9</strong><br>Harry Hacker写了一个从命令行接受一系列文件名的程序。对每个文件名，他都启动一个新的线程来读取文件内容并更新一个字母出现频率映射，声明为：<br>val frequencies = new scala.collection.multable.HashMap[Char,Int] with scala.collection.mutable.SynchronizedMap[Char,Int]<br>当读到字母c时，他调用<br>frequencies(c) = frequencies.getOrElse(c,0) + 1<br>为什么这样做得不到正确答案？如果他用如下方式实现呢：<br>import scala.collection.JavaConversions.asScalaConcurrentMap<br>val frequencies:scala.collection.mutable.ConcurrentMap[Char,Int] = new java.util.concurrent.ConcurrentHashMap[Char,Int]</p>
<p>并发问题，并发修改集合不安全。</p>
<p><strong>13.10</strong><br>Harry Hacker把文件读取到字符串中，然后想对字符串的不同部分用并行集合来并发地更新字母出现频率映射。他用了如下代码：<br>val frequencies = new scala.collection.mutable.HashMap[Char,Int]<br>for(c &lt;- str.par) frequencies(c) = frequencies.getOrElse(c,0) + 1<br>为什么说这个想法很糟糕？要真正地并行化这个计算，他应该怎么做呢？（提示：用aggregate） 并行修改共享变量，结果无法估计。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.collection.immutable.HashMap</div><div class="line"></div><div class="line"><span class="keyword">val</span> str = <span class="string">"abdcsdcd"</span></div><div class="line"><span class="keyword">val</span> frequencies = str.par.aggregate(HashMap[Char,Int]())(</div><div class="line">  {</div><div class="line">    (a,b) =&gt;</div><div class="line">      a + (b -&gt; (a.getOrElse(b,<span class="number">0</span>) + <span class="number">1</span>))</div><div class="line">  }</div><div class="line">  ,</div><div class="line">  {</div><div class="line">    (map1,map2) =&gt;</div><div class="line">      (map1.keySet ++ map2.keySet).foldLeft( HashMap[Char,Int]() ) {</div><div class="line">        (result,k) =&gt;</div><div class="line">          result + ( k -&gt; ( map1.getOrElse(k,<span class="number">0</span> ) + map2.getOrElse(k,<span class="number">0</span>) ) )</div><div class="line">      }</div><div class="line">  }</div><div class="line">)</div></pre></td></tr></table></figure>

<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/02/04/《快学scala》习题解答-第十二章-高阶函数/">
                《快学scala》习题解答-第十二章-高阶函数
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          Posted on 2015-02-04
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; In
            
              <a href="/categories/scala/">scala</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/02/04/《快学scala》习题解答-第十二章-高阶函数/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/02/04/《快学scala》习题解答-第十二章-高阶函数/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <pre><code>《快学Scala》（英文版：《Scala <span class="keyword">for</span> <span class="operator">the</span> Impatient》），代码已传github：
</code></pre><p><a href="https://github.com/vernonzheng/scala-for-the-Impatient" target="_blank" rel="external">https://github.com/vernonzheng/scala-for-the-Impatient</a></p>
<p>书为第一版。scala为2.11.4，jdk1.7.45，操作系统Mac OS X Yosemite 10.10.1。</p>
<h2 id="第十二章_高阶函数">第十二章 高阶函数</h2>
<p><strong>12.1</strong><br>编写函数values(fun:(Int)=&gt;Int,low:Int,high:Int),该函数输出一个集合，对应给定区间内给定函数的输入和输出。比如，values(x=&gt;x*x,-5,5)应该产出一个对偶的集合(-5,25),(-4,16),(-3,9),…,(5,25)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> values(fun:(Int)=&gt;Int,low:Int,high:Int) ={</div><div class="line">  <span class="keyword">var</span> array = List[(Int,Int)]()</div><div class="line">  low to high foreach {</div><div class="line">    x =&gt;</div><div class="line">      array = (x, fun(x)) :: array</div><div class="line">  }</div><div class="line">  array</div><div class="line">}</div><div class="line">println(values(x =&gt; x * x, -<span class="number">5</span>, <span class="number">5</span>).mkString)</div></pre></td></tr></table></figure>

<p><strong>12.2</strong><br>如何用reduceLeft得到数组中的最大元素?</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> arr = Array(<span class="number">1</span>,<span class="number">333</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">32</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">2</span>)</div><div class="line">print(arr.reduceLeft((l,r)=&gt;<span class="keyword">if</span>(l&gt;=r) l <span class="keyword">else</span> r))</div></pre></td></tr></table></figure>

<p><strong>12.3</strong><br>用to和reduceLeft实现阶乘函数,不得使用循环或递归 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> factorial(n:Int): Unit ={</div><div class="line">  <span class="number">1</span> to n reduceLeft(_ * _)</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>12.4</strong><br>前一个实现需要处理一个特殊情况，即n&lt;1的情况。展示如何用foldLeft来避免这个需要。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> factorial(n:Int) = (<span class="number">1</span> to n).foldLeft(<span class="number">1</span>)(_ * _)</div><div class="line"></div><div class="line">factorial(-<span class="number">3</span>)</div><div class="line">factorial(<span class="number">3</span>)</div></pre></td></tr></table></figure>

<p><strong>12.5</strong><br>编写函数largest(fun:(Int)=&gt;Int,inputs:Seq[Int]),输出在给定输入序列中给定函数的最大值。举例来说，largest(x=&gt;10<em>x-x</em>x,1 to 10)应该返回25.不得使用循环或递归 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> largest1(fun:(Int)=&gt;Int, inputs:Seq[Int]) = inputs.foldLeft(<span class="number">1</span>)((a,b)=&gt; <span class="keyword">if</span>(fun(b)&gt;a) fun(b) <span class="keyword">else</span> a)</div><div class="line"></div><div class="line"><span class="keyword">def</span> largest2(fun:(Int)=&gt;Int, inputs:Seq[Int]) = inputs.map(fun(_)).max</div><div class="line"></div><div class="line">println(largest1(x =&gt; <span class="number">10</span> * x - x * x, <span class="number">1</span> to <span class="number">10</span>))</div><div class="line">println(largest2(x =&gt; <span class="number">10</span> * x - x * x, <span class="number">1</span> to <span class="number">10</span>))</div></pre></td></tr></table></figure>

<p><strong>12.6</strong><br>修改前一个函数，返回最大的输出对应的输入。举例来说,largestAt(fun:(Int)=&gt;Int,inputs:Seq[Int])应该返回5。不得使用循环或递归 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> largestAt1(fun:(Int)=&gt;Int, inputs:Seq[Int]) = inputs.reduce((a,b)=&gt; <span class="keyword">if</span>(fun(b)&gt;fun(a)) b <span class="keyword">else</span> a)</div><div class="line"></div><div class="line"><span class="keyword">def</span> largestAt2(fun: (Int) =&gt; Int, inputs: Seq[Int]) = inputs.map(x =&gt; (x, fun(x))).reduceLeft((x,y) =&gt; <span class="keyword">if</span> (x._2 &gt; y._2) x <span class="keyword">else</span> y)._1</div><div class="line"></div><div class="line">println(largestAt1(x =&gt; <span class="number">10</span> * x - x * x, <span class="number">1</span> to <span class="number">10</span>))</div><div class="line">println(largestAt2(x =&gt; <span class="number">10</span> * x - x * x, <span class="number">1</span> to <span class="number">10</span>))</div></pre></td></tr></table></figure>

<p><strong>12.7</strong><br>要得到一个序列的对偶很容易，比如:<br>val pairs = (1 to 10) zip (11 to 20)<br>假定你想要对这个序列做某中操作—比如，给对偶中的值求和，但是你不能直接使用:</p>
<p>pairs.map(<em> + </em>)<br>函数<em> + </em> 接受两个Int作为参数，而不是(Int,Int)对偶。编写函数adjustToPair,该函数接受一个类型为(Int,Int)=&gt;Int的函数作为参数，并返回一个等效的, 可以以对偶作为参数的函数。举例来说就是:adjustToPair(<em> * </em>)((6,7))应得到42。然后用这个函数通过map计算出各个对偶的元素之和</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> ajustToPair(fun: (Int, Int) =&gt; Int) = (x: (Int, Int)) =&gt; fun(x._1, x._2)</div><div class="line"></div><div class="line"><span class="keyword">val</span> x = ajustToPair(_ * _)((<span class="number">6</span>, <span class="number">7</span>))</div><div class="line">println(x)</div><div class="line"></div><div class="line"><span class="keyword">val</span> pairs = (<span class="number">1</span> to <span class="number">10</span>) zip (<span class="number">11</span> to <span class="number">20</span>)</div><div class="line">println(pairs)</div><div class="line"></div><div class="line"><span class="keyword">val</span> y = pairs.map(ajustToPair(_ + _))</div><div class="line">println(y)</div></pre></td></tr></table></figure>

<p><strong>12.8</strong><br>在12.8节中，你看到了用于两组字符串数组的corresponds方法。做出一个对该方法的调用，让它帮我们判断某个字符串数组里的所有元素的长度是否和某个给定的整数数组相对应 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = Array(<span class="string">"asd"</span>,<span class="string">"df"</span>,<span class="string">"abcd"</span>)</div><div class="line"><span class="keyword">val</span> b = Array(<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>)</div><div class="line"><span class="keyword">val</span> c = Array(<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)</div><div class="line"></div><div class="line">println(a.corresponds(b)(_.length == _))</div><div class="line">println(a.corresponds(c)(_.length == _))</div></pre></td></tr></table></figure>

<p><strong>12.9</strong><br>不使用柯里化实现corresponds。然后尝试从前一个练习的代码来调用。你遇到了什么问题？</p>
<p>没有柯里化则不能使用前一个练习里的代码方式来调用</p>
<p><strong>12.10</strong><br>实现一个unless控制抽象，工作机制类似if,但条件是反过来的。第一个参数需要是换名调用的参数吗？你需要柯里化吗？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> unless(condition: =&gt; Boolean)(block: =&gt; Unit) { <span class="keyword">if</span> (!condition) { block } }</div><div class="line"></div><div class="line">unless (<span class="number">0</span> &gt; <span class="number">1</span>) { println(<span class="string">"Unless!"</span>) }</div></pre></td></tr></table></figure>

<p>需要换名和柯里化</p>
<hr>
<p>参考：<br>《快学Scala》：<a href="http://book.douban.com/subject/19971952/" target="_blank" rel="external">http://book.douban.com/subject/19971952/</a></p>
<p><strong>（转载本站文章请注明作者和出处 Vernon Zheng(郑雪峰) – vernonzheng.com ，请勿用于任何商业用途）</strong></p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
    </div>
  </div>


    
  </div>

  
  <div class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">&raquo;</a>
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="/images/default_avatar.jpg" alt="Vern Zheng" />
          <p class="site-author-name">Vern Zheng</p>
        </div>
        <p class="site-description motion-element">tech | life | thiking | note</p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">32</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">10</span>
              <span class="site-state-item-name">categories</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">24</span>
              <span class="site-state-item-name">tags</span>
              </a>
          </div>

        </div>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml">
              <i class="menu-item-icon icon-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/vernonzheng" target="_blank">GitHub</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://www.douban.com/people/vernonzheng/" target="_blank">DouBan</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://www.zhihu.com/people/vernzheng" target="_blank">ZhiHu</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="mailto:kevonzheng@gmail.com" target="_blank">Email</a>
            </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

      </div>

      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp;  2014.12 - 
  2015
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">Vern Zheng</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js"></script>


  <script type="text/javascript" src="/js/helpers.js"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js" id="motion.global"></script>




  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
    });
  </script>

  

  
  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"vernonzheng"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  


  
  

</body>
</html>
